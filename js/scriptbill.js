		//=============================Scriptbill Class Main====================================
	class Scriptbill {
		
	static funcUp = [];
	//used to store current private key used.
	static #privKey  = false;
	static noteID;//The id of the note which changes on every transaction made.
	static noteAddress;//the address of the current note the user wants to use.
	static noteType		= 'SBCRD';//the class of the note.
	
	//save password variable. With this key, Scriptbill saves the password that decrypts a note
	//in the local Scriptbill storage for the session when the note was logged in. On log out,
	//this variable is deleted, when logging in again this variable will be recreated and will 
	//remain constant for the rest of the session. To ensure that we set the variable as false
	//and set it once. Only when it is false will we have to recreate it.
	static #passwordKey = false;
	
	//the private key of the current note.
	static #noteSecret  = false;
	
	//private key that holds the key of the creator of Scriptbill. This key can be used to 
	//override so many thing in the Scriptbill network. It is harded for security and transparency.
	//the overrider must hold the private key to this key which is the hash version of the 
	//original private key. This key may change only when the creator must have splitted the 
	//note. When this note is logged in, the creator can create any credit from any exchange 
	//market as he wishes. The owner of this note can also control the stock market of 
	//all credit invested by the exchange markets. The note can also split into new notes who 
	//may be given such privileges in the network. This note is also the employer of all 
	//labour force in the Scriptbill network.
	static #odogwu 		= "ufEdaN_fI_jtkDiINa_h20qPlYteG5aZYhlr_-822Nc6sqsYf4t-zNjROi_bjEClerU_t6QrQGgZAR23fCcf-k9Pp-5JLIvArL_SCBegwODkveNeYPelFtWkW1zDdYf3npYfHtztMAig82F_2GkTgcPcQPQwgDpLAmnP1rJA7Kc";
	
	static privateKey 	= {};
	
	static publicKey 	= {};
	
	//to be set whenever a note would be splitted either because of size or initiated by 
	//the user.
	static #splitNote   = false;
	
	//private key to a newly generated budget on the note.
	static #budgetSecret 	= '';
	
	//the rate at which credit leaves the exchange market, if set to 0.5, then only half of the credit will leave 
	//the exchange market at every demand. If we have 1 Scriptbills in the market, and 1 billion dollars was 
	//supplied in demand for the credit, the total value of the credit will be 2 billion dollars because only 0.5 
	//Scriptbills will be supplied at the $1 billion based on the mining rate.
	static #miningRate   = 0.5;
	
	//used by apps to tell Scriptbill where the motherKeys.json file is kept on
	//their server. This will save the Scriptbill Script from guessing this url
	static motherKeysURL 			= false;
	static #shareValue				= 0;
	static #isExchangeMarketMining 	= false;
	static #isExchangeDeposit		= false;
	//this identifies a product block during run time.
	static #productBlock			= null;
	//this tells if a bond or stock note is being quoted at run time
	static #isQuotedNote 			= false;
	static #createdAgreement		= null;
	static #noteHASH				= false;
	
	
	//this is where the agree block used for the AGREESEND transaction is stored.
	//if this variable is not set, the auto agreement transaction will not pull 
	//successfully
	static #agreeBlock				= null;
	static walletID; //Scriptbill is the unique identifier of a particular user in the network. With Scriptbill, all Scriptbill note that the person holds will be in one place.
	//scriptbill will store all the responses it gets from servers it communicate with in Scriptbill variable. 
	//set to be static async to help it eaily accessed outside the scope of Scriptbill class.
	static response;
	
	
	
	//the interest rate set by Scriptbank on crediter who will choose to use Scriptbill credit instead of demanding for it.
	static interestRate = 0.2;
	
	//the rate at which the interest will be calculated. Values include PT for "Per Transaction", DL for "Daily", 
	//HL for "Hourly" E{N}D for "Every N Days", E{N}H for "Every N Hours", E{N}M for "Every N Minutes", E{N}W for 
	//"Every N weeks" WL for "Every Week" E{N}M for "Every N Months" ML for "Monthly"
	static interestType = "PT";
	
	//JSEncrypt = new JSEncrypt({default_key_size: 2048});
	static default_key_size = 10;
	//important to set the default scriptbill server as a constant here so that the script can easily 
	//work with it and won't be causing difficulty while updating.
	static #default_scriptbill_server = "https://www.massagebookers.com/";//"http://localhost/oyo_money/";//"https://ssic.ng/";//"http://localhost/oyo_money/"; /*"https://dev-scriptbanking.pantheonsite.io/"*/ ;//"https://scriptbank.com.ng";//"https://dev-cmbf-bank.pantheonsite.io/";
	static #default_scriptbill_servers = ["https://ssic.ng","https://scriptnews.rf.gd","https://scriptmansion.rf.gd","https://scriptcribs.rf.gd","https://scriptautos.rf.gd","https://scriptcars.rf.gd","https://scriptair.rf.gd","https://scripttickets.rf.gd","https://scripthotels.rf.gd","https://scriptestates.rf.gd","https://scripttrucks.rf.gd","https://scriptlive.rf.gd","https://scripttravels.rf.gd"];
	//the current Scriptbill note that is being instantiated will rest in Scriptbill variable.
	//the session storage variable helps further share the information on the latest note.
	//the session storage of the current note is updated everytime a note is saved or gotten from the database.
    static #server_clients          = [];
	static #note;
	//the current note. Contains public keys of the private key stored on the note variable.
	static currentNote;
	//data that would be sent will be stored on this variable
	static data;
	//user inputted password that may be required to decrypt or encypt some important financial data from
	//the Scriptbill note.
	static #password;	
	//the exchange transaction variables for selling a credit type.
	static sellCredit;
	//the exchange transaction variable for buying a credit type.
	static buyCredit;
	//the transaction value of a particular transaction may be kept here for transactions like credit
	//and stock exchanges.
	static transValue;
	
	//used majorly to store strings that will be hashed later by the hash functions.
	static string;
	
	//used majorly to temporary save data in the class to avoid the localStorage.
	//being overloaded with data. Data from the storage are mostly gotten from indexedDB
	static storage 		= {};
	
	//alpha numeric
	static #alpha_numeric = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ1234567890";
	
	//extended varchar.
	static #varchar       = "~`!@#$%^&*()-_=+[]{}\\|;:\"'<,>.?/";
	static l = localStorage;//this.initStorage();//Scriptbill may represent the permanent storage of a particular user. Since Scriptbill torage is limited, few things can be stored on the user'this.s database, so we strink data everyday to ensure spaces are available for use on Scriptbill storage.
	static s = sessionStorage;//this.initSessionStorage();//Scriptbill storage is used to save things that would not be beyyond the current browaer session of the user, if data expected to be on Scriptbill storage is not found, then the user would be asked to log in again to rebuild the data
	//static test = this.test();
	//static checkStorage = this.checkStorage();
	//used to declare a mother note when creating a new credit for the note or saving any other note that must be present
	//when running an important transaction. For instance when running a transaction in an online store
	//the store can choose to process her transaction immediately, thereby storing note in this variable
	static #currentNote;
	
	//controls whether the current note should verify transaction blocks or not.
	//can be set from the frontend using the shouldVerifyTransactionBlock method.
	static #noVerify		= false;
	
	//to store mother keys belonging to Scriptbank exchange notes. This is to ensure.
	//everywhere the exchange note transactions are initiated, it can be processed even
	//without locating the exchange notes.
	static #motherKeys   = false;
	
	//to set if the current note running should be saved in the client or not. This 
	//variable help Scriptbill process exchange notes in the instance of a communicating
	//note without interference.
	static #saveNote     = true;
	
	//pays interest connected to a current note running Scriptbills if the note has
	//an agreement to recieve or pay a recipient interest. Also used to auto execute 
	//transactions belonging to the current note.
	static #interestPayment = this.payInterest();
	
	//checks the local storage space, cleans it up and set data from the local storage to index db
	//this function is intended to make the client store more data and manage more space.
	//static #manageSpace 	= this.#manageClientSpace();
	
	//monitors to check if the note has any response from the server on an activity
	static #getResponse  	= this.recieveResponse();
	
	//monitors and auto execute budget registered on the note.
	static #budgetMonitor 	= this.monitorScriptbillBudget();	
	
	//checks if the current note is larger than 3MB, the maximum size allowed for a 
	//current note because of the session storage size limit. Splits the note to store the 
	//private key of the current note to the new note, then downloads the splitted note 
	//for the user.
	static #runSplitNote = this.splitNote();

	static #channels = this.#subscribeChannels();
	
	/*
	@fiatCurrencies
	Holds an update to all fiat currencies that will be featured on the Scriptbill Network
	whose exchange market is held by Scriptbank.
	*/
	static #fiatCurrencies = {
  "42": "42 Coin",
  "300": "300 token",
  "433": "433 Token",
  "611": "SixEleven",
  "808": "808TA",
  "888": "Octocoin",
  "1337": "EliteCoin",
  "2015": "2015 coin",
  "ARC*": "Arcade City",
  "CLUB": "ClubCoin",
  "007": "007 coin",
  "ZCN": "0chain",
  "ZRX": "0x",
  "0xBTC": "0xBitcoin",
  "BIT16": "16BitCoin",
  "MCT": "1717 Masonic Commemorative Token",
  "1CR": "1Credit",
  "1WO": "1World",
  "CHAO": "23 Skidoo",
  "ARMS": "2Acoin",
  "2BACCO": "2BACCO Coin",
  "2GIVE": "2GiveCoin",
  "2TF": "2TF",
  "32BIT": "32Bitcoin",
  "3XD": "3DChain",
  "3DES": "3DES",
  "8BT": "8 Circuit Studios",
  "8BIT": "8BIT Coin",
  "ATKN": "A-Token",
  "AAA": "AAA Reserve Currency",
  "RTB": "AB-CHAIN",
  "ABC": "AB-Chain",
  "AT": "ABCC Token",
  "AC3": "AC3",
  "ACA": "ACA Token",
  "ACT": "ACT",
  "ACOIN": "ACoin",
  "AENT": "AEN",
  "AEON": "AEON",
  "AERGO": "AERGO",
  "AGT": "AGATE",
  "AIC": "AI Crypto",
  "AIDOC": "AI Doctor",
  "AIT": "AIChain Token",
  "XAI*": "AICoin",
  "AIOT": "AIOT Token",
  "AITT": "AITrading",
  "AXT": "AIX",
  "ALX": "ALAX",
  "ALIS": "ALISmedia",
  "ALT": "ALTcoin",
  "AMBT": "AMBT Token",
  "AMIS": "AMIS",
  "AMLT": "AMLT",
  "AMO": "AMO Coin",
  "ANON": "ANON",
  "ANTS": "ANTS Reloaded",
  "APIS": "APIS",
  "APS": "APRES",
  "QEY": "AQwire",
  "ARB*": "ARBITRAGE",
  "ARE": "ARENON",
  "ARK": "ARK",
  "ARNA": "ARNA Panacea",
  "ARR": "ARROUND",
  "ASGC": "ASG",
  "ASQT": "ASQ Protocol",
  "ATB": "ATB coin",
  "ATCC": "ATC Coin",
  "ATFS": "ATFS Project",
  "ATL": "ATLANT",
  "ATM": "ATMChain",
  "AUC*": "AU-Coin",
  "AWAX": "AWAX",
  "AXR": "AXRON",
  "AXS": "AXS",
  "ABELE": "Abele",
  "ABJ": "Abjcoin",
  "ABS": "Absolute Coin",
  "ACC*": "Accelerator Network",
  "ACCO": "Accolade",
  "AEC": "AcesCoin",
  "ACES": "AcesCoin",
  "ACT*": "Achain",
  "ACH": "AchieveCoin",
  "ACID": "AcidCoin",
  "OAK": "Acorn Collective",
  "ACM": "Actinium",
  "ACTN": "Action Coin",
  "AMT": "Acumen",
  "AAC": "Acute Angle Cloud",
  "ACC": "AdCoin",
  "ADX": "AdEx",
  "ADT": "AdToken",
  "ADAB": "Adab Solutions",
  "ADM": "Adamant",
  "ADB": "Adbank",
  "ADL": "Adelphoi",
  "ADH": "Adhive",
  "ADI": "Aditus",
  "ADST": "Adshares",
  "AIB": "AdvancedInternetBlock",
  "ADZ": "Adzcoin",
  "AGS": "Aegis",
  "AEN": "Aenco",
  "AERM": "Aerium",
  "AERO": "Aero Coin",
  "AM": "AeroMe",
  "ARN": "Aeron",
  "XRM": "Aerum",
  "AER": "Aeryus",
  "AE": "Aeternity",
  "ATT": "Aeternum",
  "AET": "AfterEther",
  "AGVC": "AgaveCoin",
  "ESTATE": "AgentMile",
  "AGRS": "Agoras Token",
  "DLT": "Agrello Delta",
  "AHT": "Ahoolee",
  "AIBB": "AiBB",
  "AID": "AidCoin",
  "ADN": "Aiden",
  "ADK": "Aidos Kuneen",
  "AIX": "Aigang",
  "AIM": "Aimedis",
  "AION": "Aion",
  "APOD": "AirPod",
  "AST": "AirSwap",
  "AIR": "AirToken",
  "AIRT": "Aircraft",
  "AKA": "Akroma",
  "ALCE": "Alcedo",
  "ALEX": "Alexandrite",
  "PLM": "Algo.Land",
  "ALG": "Algory",
  "ABBC": "Alibabacoin",
  "ALN": "AlienCoin",
  "SOC": "All Sports Coin",
  "AFO": "AllForOneBusiness",
  "ASAFE2": "Allsafe",
  "APC": "AlpaCoin",
  "ALPS": "Alpenschillling",
  "ALF": "AlphaCoin",
  "AX": "AlphaX",
  "ACAT": "Alphacat",
  "ALP": "Alphacon",
  "APZ": "Alprockz",
  "ALQO": "Alqo",
  "ALTCOM": "AltCommunity Coin",
  "ALTOCAR": "AltoCar",
  "ALUX": "Alux Bank",
  "AS": "AmaStar",
  "AMBER": "AmberCoin",
  "AMB": "Ambrosus",
  "AMC": "AmericanCoin",
  "AMX": "Amero",
  "AMMO": "Ammo Rewards",
  "AMN": "Amon",
  "AMOS": "Amos",
  "VEO": "Amoveo",
  "AMS": "Amsterdam Coin",
  "AMY": "Amygws",
  "ANCP": "Anacrypt",
  "ANAL": "AnalCoin",
  "ACP": "Anarchists Prime",
  "AND": "AndromedaCoin",
  "ANGL": "Angel Token",
  "AVH": "Animation Vision Cash",
  "ANI": "Animecoin",
  "ANK": "Ankorus Token",
  "ANKR": "Ankr Network",
  "ANC": "Anoncoin",
  "RYZ": "Anryze",
  "ANTI": "Anti Bitcoin",
  "ATHK": "AntiHACK.me",
  "ANTC": "AntiLitecoin",
  "CPX": "Apex Token",
  "APEX": "ApexCoin",
  "APH": "Aphelion",
  "APL": "Apollo Currency",
  "APXT": "ApolloX",
  "XAP": "Apollon",
  "APPC": "AppCoins",
  "APT": "Aptcoin",
  "APX": "Apx",
  "AQUA": "Aquachain",
  "ARCO": "AquariusCoin",
  "AR*": "Ar.cash",
  "ARQ": "ArQmA",
  "ALC": "Arab League Coin",
  "ANT": "Aragon",
  "ARAW": "Araw",
  "ARBI": "Arbi",
  "ARB": "Arbit Coin",
  "ARCT": "ArbitrageCT",
  "ABT": "ArcBlock",
  "ARCX": "ArcadierX",
  "ARCH": "ArchCoin",
  "ARC": "ArcticCoin",
  "ARDR": "Ardor",
  "ARENA": "Arena",
  "ARG": "Argentum",
  "AGM": "Argoneum",
  "ARGUS": "ArgusCoin",
  "ARI": "AriCoin",
  "ARO": "Arionum",
  "BOTS": "ArkDAO",
  "ARM": "Armory Coin",
  "ARPA": "ArpaCoin",
  "ABY": "ArtByte",
  "ATP": "ArtPro",
  "ARS": "Artcoin",
  "ARTE": "Artemine",
  "ATX": "ArtexCoin",
  "AUA": "ArubaCoin",
  "ASN": "Ascension Coin",
  "XAS": "Asch",
  "AC": "Asia Coin",
  "ADCN": "Asiadigicoin",
  "ATX*": "Aston",
  "AST*": "Astral",
  "ASTRO": "Astronaut",
  "ATH": "Atheios",
  "THO": "Athero",
  "ATMOS": "Atmos",
  "ATOM": "Atomic Coin",
  "AWC": "Atomic Wallet Coin",
  "ATMI": "Atonomi",
  "ATTR": "Attrace",
  "AUC": "Auctus",
  "ADC": "AudioCoin",
  "REP": "Augur",
  "AUK": "Aukcecoin",
  "AURS": "Aureus",
  "AURA": "Aurora",
  "AOA": "Aurora",
  "AUR": "Aurora Coin",
  "AURUM": "Aurum",
  "AUD": "Aussie Digital",
  "AUN": "Authoreon",
  "ATS": "Authorship",
  "AUPC": "Authpaper",
  "ABX": "AutoBay",
  "ATC": "AutoBlock",
  "NIO*": "Autonio",
  "AUT": "Autoria",
  "ATM*": "Autumncoin",
  "Auxilium": "Auxilium",
  "AVA": "Avalon",
  "AV": "Avatar Coin",
  "AVT": "AventCoin",
  "AOP": "Averopay",
  "AVE": "Avesta",
  "ACN": "AvonCoin",
  "WORK": "Aworker",
  "AXIOM": "Axiom Coin",
  "AXYS": "Axys",
  "AZART": "Azart",
  "AZ": "Azbit",
  "AZU": "Azultec",
  "B21": "B21",
  "B2B": "B2BX",
  "B3": "B3 Coin",
  "KB3": "B3Coin",
  "BAX": "BABB",
  "BAM": "BAM",
  "BANCA": "BANCA",
  "BKX": "BANKEX",
  "BBN": "BBNCOIN",
  "BCV": "BCV Blue Chip",
  "BEAT": "BEAT Token",
  "BEER": "BEER Coin",
  "BERN": "BERNcash",
  "BEX": "BEX token",
  "BFT": "BF Token",
  "BFEX": "BFEX",
  "BHPC": "BHPCash",
  "BITTO": "BITTO",
  "VEE": "BLOCKv",
  "BMT": "BMChain",
  "BSC*": "BOONSCoin",
  "BST*": "BOOSTO",
  "BOS": "BOScoin",
  "BQC": "BQCoin",
  "BQTX": "BQT",
  "BVO": "BRAVO Pay",
  "BRAT": "BROTHER",
  "BTCL": "BTC Lite",
  "BTCM": "BTCMoon",
  "BTU": "BTU Protocol",
  "BAAS": "BaaSid",
  "BAN": "Babes and Nerds",
  "BKC": "Balkancoin",
  "NANAS": "BananaBits",
  "BNT": "Bancor Network Token",
  "XBANK": "Bancryp",
  "B@": "BankCoin",
  "BNK": "Bankera",
  "BCOIN": "BannerCoin",
  "BBN*": "Banyan Network",
  "BBCC": "BaseballCardCoin",
  "BASHC": "BashCoin",
  "BAT": "Basic Attention Token",
  "BASIS": "Basis",
  "BTA": "Bata",
  "BCX": "BattleCoin",
  "BSTK": "BattleStake",
  "SAND": "BeachCoin",
  "BEAM": "Beam",
  "BEAN": "BeanCash",
  "BRDD": "BeardDollars",
  "XBTS": "Beats",
  "BTZC": "BeatzCoin",
  "BEC": "Beauty Chain",
  "BVC": "BeaverCoin",
  "BXY": "Beaxy",
  "BEE": "Bee Token",
  "BFDT": "Befund",
  "BELA": "Bela",
  "BBI": "BelugaPay",
  "BMK": "Benchmark",
  "BNC": "Benjacoin",
  "BENJI": "BenjiRolls",
  "BEST": "BestChain",
  "KNG": "BetKings",
  "CHART": "BetOnChart",
  "BET": "BetaCoin",
  "BFC": "Betform",
  "BETHER": "Bethereum",
  "KRO": "Betoken",
  "BTRM": "Betrium Token",
  "BETR": "BetterBetting",
  "BTXC": "Bettex coin",
  "BETT": "Bettium",
  "BC": "Beverage.cash",
  "BZNT": "Bezant",
  "BEZ": "Bezop",
  "BGG": "Bgogo Token",
  "BNR": "BiNeuro",
  "BBP": "BiblePay",
  "BIX": "BiboxCoin",
  "BID": "BidCoin",
  "BDP": "Bidipass",
  "DOOH": "Bidooh",
  "BDB": "Big Data Block",
  "BBG": "BigBang",
  "HUGE": "BigCoin",
  "LFC": "BigLifeCoin",
  "BIGUP": "BigUp",
  "BBO": "Bigbom",
  "BHC": "BighanCoin",
  "BIC": "Bikercoins",
  "BLRY": "BillaryCoin",
  "XBL": "Billionaire Token",
  "BNB": "Binance Coin",
  "BRC*": "BinaryCoin",
  "BIOB": "BioBar",
  "BIOC": "BioCrypt",
  "BIO": "Biocoin",
  "BIOS": "BiosCrypto",
  "BTRN": "Biotron",
  "BIPC": "BipCoin",
  "BIS": "Bismuth",
  "BZ": "Bit-Z",
  "BAS": "BitAsean",
  "BTB": "BitBar",
  "BAY": "BitBay",
  "BBK": "BitBlocks",
  "BBT": "BitBoost",
  "BOSS": "BitBoss",
  "BRONZ": "BitBronze",
  "BCD*": "BitCAD",
  "BEN": "BitCOEN",
  "BCNA": "BitCanna",
  "BITCAR": "BitCar",
  "CAT*": "BitClave",
  "COAL": "BitCoal",
  "BCCOIN": "BitConnect Coin",
  "BCR": "BitCredit",
  "BTCRY": "BitCrystal",
  "BCY": "BitCrystals",
  "BTCR": "BitCurrency",
  "BDG": "BitDegree",
  "CSNO": "BitDice",
  "HNY": "BitFence",
  "BFX": "BitFinex Tokens",
  "FLIP": "BitFlip",
  "FLX*": "BitFlux",
  "BF": "BitForex Token",
  "HIRE*": "BitHIRE",
  "BIH": "BitHostCoin",
  "STU": "BitJob",
  "BTLC": "BitLuckCoin",
  "LUX*": "BitLux",
  "BTM": "BitMark",
  "BMX": "BitMart Coin",
  "BTMX": "BitMax Token",
  "BTMI": "BitMiles",
  "BITM": "BitMoney",
  "BM": "BitMoon",
  "BITOK": "BitOKX",
  "BTQ": "BitQuark",
  "RNTB": "BitRent",
  "BIT": "BitRewards",
  "BSCH": "BitSchool",
  "BITX": "BitScreener",
  "XSEED": "BitSeeds",
  "BSD": "BitSend",
  "BTE*": "BitSerial",
  "BSR": "BitSoar Coin",
  "BTSG": "BitSong",
  "STASH": "BitStash",
  "BSTN": "BitStation",
  "BST": "BitStone",
  "SWIFT": "BitSwift",
  "BXT": "BitTokens",
  "BTT": "BitTorrent",
  "TUBE": "BitTube",
  "VEG": "BitVegan",
  "VOLT": "BitVolt",
  "BTW": "BitWhite",
  "ZNY": "BitZeny",
  "XBOND": "Bitacium",
  "BTCA": "Bitair",
  "BAC": "BitalphaCoin",
  "BB1": "Bitbond",
  "BOSE": "Bitbose",
  "BTMG": "Bitcademy Football",
  "BTD": "Bitcloud",
  "BTDX": "Bitcloud 2.0",
  "BTCN": "BitcoiNote",
  "B2G": "Bitcoiin2Gen",
  "BTC": "Bitcoin",
  "BCA": "Bitcoin Atom",
  "CDY": "Bitcoin Candy",
  "BCH": "Bitcoin Cash",
  "BTCC": "Bitcoin Core",
  "BCD": "Bitcoin Diamond",
  "BTG": "Bitcoin Gold",
  "BITG": "Bitcoin Green",
  "BTCH": "Bitcoin Hush",
  "XBI": "Bitcoin Incognito",
  "BCI": "Bitcoin Interest",
  "BTN": "Bitcoin Nova",
  "BTPL": "Bitcoin Planet",
  "BTCP": "Bitcoin Private",
  "BTCRED": "Bitcoin Red",
  "BCR*": "Bitcoin Royal",
  "BSV": "Bitcoin SV",
  "BTCS": "Bitcoin Scrypt",
  "BT2": "Bitcoin SegWit2X",
  "BTCS*": "Bitcoin Supreme",
  "BTCD": "BitcoinDark",
  "BTCE*": "BitcoinEX",
  "BCF": "BitcoinFast",
  "BIFI": "BitcoinFile",
  "BTF*": "BitcoinFor",
  "BTCGO": "BitcoinGo",
  "XBC": "BitcoinPlus",
  "BWS": "BitcoinWSpectrum",
  "BCX*": "BitcoinX",
  "BTCZ": "BitcoinZ",
  "BTCUS": "Bitcoinus",
  "BM*": "Bitcomo",
  "BTX": "Bitcore",
  "DARX": "Bitdaric",
  "BDL": "Bitdeal",
  "XBX": "BiteX",
  "BT1": "Bitfinex Bitcoin Future",
  "BTR": "Bither",
  "BTH": "Bithereum",
  "KAN": "Bitkan",
  "BTCL*": "BitluckCoin",
  "BIM": "BitminerCoin",
  "BMXT": "Bitmxittz",
  "XPAT": "Bitnation Pangea",
  "BQ": "Bitqy",
  "BRO": "Bitradio",
  "BTL": "Bitrolium",
  "BITSD": "Bits Digit",
  "BINS": "Bitsense",
  "BTS": "Bitshares",
  "BSX": "Bitspace",
  "XBS": "Bitstake",
  "BITS": "BitstarCoin",
  "BITS*": "Bitswift",
  "BWT": "Bittwatt",
  "BTV": "Bitvote",
  "BWT2": "Bitwin 2.0",
  "BITZ": "Bitz Coin",
  "BTZ": "BitzCoin",
  "BTZN": "Bitzon",
  "BXM": "Bixtrim",
  "BZKY": "Bizkey",
  "XBP": "Black Pearl Coin",
  "BLK": "BlackCoin",
  "BS": "BlackShadowCoin",
  "BBOS": "Blackbox Foundation",
  "BHC*": "BlackholeCoin",
  "BMC": "Blackmoon Crypto",
  "BSTAR": "Blackstar",
  "BBTC": "BlakeBitcoin",
  "BLC": "BlakeCoin",
  "BLAS": "BlakeStar",
  "BLAZR": "BlazerCoin",
  "BLKD": "Blinked",
  "BLITZ": "BlitzCoin",
  "XBP*": "BlitzPredict",
  "ARY": "Block Array",
  "BLTG": "Block-Logic",
  "BCAT": "BlockCAT",
  "BCDN": "BlockCDN",
  "LNC": "BlockLancer",
  "BCPT": "BlockMason Credit Protocol",
  "BMH": "BlockMesh",
  "BLOCK": "BlockNet",
  "BLOCKPAY": "BlockPay",
  "BPL": "BlockPool",
  "BCAP": "Blockchain Capital",
  "BCDT": "Blockchain Certified Data Token",
  "BLX": "Blockchain Index",
  "BCT": "Blockchain Terminal",
  "BTF": "Blockchain Traded Fund",
  "BCIO": "Blockchain.io",
  "BDT": "Blockonix",
  "PASS": "Blockpass",
  "BPT": "Blockport",
  "CCC*": "Blockshipping",
  "TIX": "Blocktix",
  "BKT": "Blocktrade token",
  "BLV": "Blockvest",
  "BNTN": "Blocnation",
  "CYS": "BlooCYS",
  "BLT": "Bloom Token",
  "CDT": "Blox",
  "BLU": "BlueCoin",
  "BDR": "BlueDragon",
  "BLZ": "Bluzelle",
  "BNX": "BnrtxCoin",
  "BOB": "Bob'this.s Repair",
  "BOT": "Bodhi",
  "BOE": "Bodhi",
  "BOG": "Bogcoin",
  "BOLD": "Bold",
  "BLN*": "Bolenum",
  "BOLI": "BolivarCoin",
  "BOLTT": "BolttCoin",
  "BOMB": "BombCoin",
  "BONA": "Bonafi",
  "BON*": "BonesCoin",
  "BON": "Bonpay",
  "BBR": "Boolberry",
  "BOST": "BoostCoin",
  "BMG": "Borneo",
  "BOSON": "BosonCoin",
  "BOS*": "Bostoken",
  "BOTC": "BotChain",
  "CAP": "BottleCaps",
  "BTO": "Bottos",
  "BOU": "Boulle",
  "BNTE": "Bountie",
  "XBTY": "Bounty",
  "BNTY": "Bounty0x",
  "BOUTS": "BoutsPro",
  "AHT*": "Bowhead Health",
  "BSC": "BowsCoin",
  "BOXY": "BoxyCoin",
  "IMPCN": "Brain Space",
  "BRAIN": "BrainCoin",
  "BRAZ": "Brazio",
  "BRD": "Bread token",
  "BRX": "Breakout Stake",
  "BRK": "BreakoutCoin",
  "BRIA": "Briacoin",
  "XBB": "BrickBlock",
  "BCO": "BridgeCoin",
  "BRC": "BrightCoin",
  "BRIK": "BrikBit",
  "BRIT": "BritCoin",
  "BRNX": "Bronix",
  "BXC": "BtcEX",
  "BUBO": "Budbo",
  "BUD": "Buddy",
  "BGL": "Buglab",
  "BT": "BuildTeam",
  "BULLS": "BullshitCoin",
  "BWK": "Bulwark",
  "BUN": "BunnyCoin",
  "BURST": "BurstCoin",
  "BUZZ": "BuzzCoin",
  "BYC": "ByteCent",
  "BTE": "ByteCoin",
  "BCN": "ByteCoin",
  "GBYTE": "Byteball",
  "BYTHER": "Bytether",
  "BTM*": "Bytom",
  "XCT": "C-Bits",
  "C25": "C25 Coin",
  "CAIx": "CAIx",
  "CBD": "CBD Crystals",
  "CCC": "CCCoin",
  "CDRX": "CDRX",
  "CDX": "CDX Network",
  "CEDEX": "CEDEX Coin",
  "CEEK": "CEEK Smart VR Token",
  "CETI": "CETUS Coin",
  "CHIPS": "CHIPS",
  "CIC": "CIChain",
  "CINX": "CINDX",
  "CINNI": "CINNICOIN",
  "CLAM": "CLAMS",
  "CO2": "CO2 Token",
  "CMS": "COMSA",
  "CNCT": "CONNECT",
  "CPY": "COPYTRACK",
  "COSS": "COSS",
  "COTI": "COTI",
  "CPC*": "CPChain",
  "MLS": "CPROP",
  "CPROP": "CPROP",
  "CRWD": "CRWD Network",
  "CMZ": "CRYPTOMAGZ",
  "CRS*": "CRYSTALS",
  "CYBR": "CYBR",
  "CAB": "CabbageUnit",
  "CHE": "Cache",
  "CACH": "Cachecoin",
  "CF": "Californium",
  "CALC": "CaliphCoin",
  "CLO": "Callisto Network",
  "CAM": "Camcoin",
  "CMPCO": "CampusCoin",
  "CAN": "CanYaCoin",
  "CND*": "Canada eCoin",
  "CDN": "Canada eCoin",
  "CAND": "Canlead",
  "CCN": "CannaCoin",
  "XCI": "Cannabis Industry Coin",
  "CANN": "CannabisCoin",
  "CNAB": "Cannabium",
  "XCD": "Capdax",
  "CAPP": "Cappasity",
  "CPC": "CapriCoin",
  "CAR": "CarBlock",
  "CTX": "CarTaxi",
  "CV": "CarVertical",
  "CARAT": "Carats Token",
  "CUSD": "Carbon",
  "CARBON": "Carboncoin",
  "ADA": "Cardano",
  "CARD": "Cardstack",
  "CARE*": "Care Token",
  "CARE": "Carebit",
  "CRGO": "CargoCoin",
  "TICS": "CargoConX",
  "CXO": "CargoX",
  "DIEM": "CarpeDiemCoin",
  "CTC": "CarterCoin",
  "CNBC": "Cash & Back Coin",
  "CASH*": "Cash Poker Pro",
  "CBC*": "CashBagCoin",
  "CBC": "CashBet Coin",
  "CASH": "CashCoin",
  "CSH": "CashOut",
  "CAS": "Cashaa",
  "CSC": "CasinoCoin",
  "CST": "Casper API",
  "CSP": "Caspian",
  "CSTL": "Castle",
  "CAT": "Catcoin",
  "CATT": "Catex",
  "CVTC": "CavatCoin",
  "CAV": "Caviar",
  "CCO": "Ccore",
  "CEL": "Celsius Network",
  "CTR": "Centra",
  "CENNZ": "Centrality Token",
  "CNT": "Centurion",
  "CBS": "Cerberus",
  "XCE": "Cerium",
  "CHC": "ChainCoin",
  "LINK": "ChainLink",
  "ZILLA": "ChainZilla",
  "CHX": "Chainium",
  "CHAN": "ChanCoin",
  "CAG": "Change",
  "CHA": "Charity Coin",
  "CHARM": "Charm Coin",
  "CXC": "CheckCoin",
  "CHK": "Chek",
  "CHESS": "ChessCoin",
  "CHILD": "ChildCoin",
  "CNC": "ChinaCoin",
  "CHIP": "Chip",
  "CHOOF": "ChoofCoin",
  "DAY": "Chronologic",
  "CRX": "ChronosCoin",
  "CHW": "Chrysalis Coin",
  "CLPX": "Chynge.net",
  "CIN": "CinderCoin",
  "CND": "Cindicator",
  "CIR": "CircuitCoin",
  "COVAL": "Circuits of Value",
  "CTL": "Citadel",
  "CTW": "Citowise",
  "CVC": "Civic",
  "CLRTY": "Clarity",
  "CAID": "ClearAid",
  "XCLR": "ClearCoin",
  "POLL": "ClearPoll",
  "CLV": "CleverCoin",
  "CHASH": "CleverHash",
  "CLICK": "Clickcoin",
  "CLIN": "Clinicoin",
  "CLINT": "Clinton",
  "CCCX": "Clipper Coin Capital",
  "CLOAK": "CloakCoin",
  "CKC": "Clockcoin",
  "CLD": "Cloud",
  "CLOUT": "Clout",
  "CLDX": "Cloverdex",
  "CLUD": "CludCoin",
  "COE": "CoEval",
  "COT": "CoTrader",
  "COVEX": "CoVEX",
  "COB": "Cobinhood",
  "COX": "CobraCoin",
  "CTT": "CodeTract",
  "CFC": "CoffeeCoin",
  "CFI": "Cofound.it",
  "COGEN": "Cogenero",
  "COGS": "Cogmento",
  "COG": "Cognitio",
  "COIN*": "Coin",
  "COY": "Coin Analyst",
  "XMG": "Coin Magi",
  "BTTF": "Coin to the Future",
  "C2": "Coin.2",
  "CONI": "CoinBene",
  "CET": "CoinEx token",
  "COFI": "CoinFi",
  "IMP": "CoinIMP",
  "XCJ": "CoinJob",
  "CL": "CoinLancer",
  "LION": "CoinLion",
  "MEE": "CoinMeet",
  "MEET": "CoinMeet",
  "XCM": "CoinMetro",
  "CPL": "CoinPlace Token",
  "CHP": "CoinPoker Token",
  "CPEX": "CoinPulseToken",
  "CCH": "Coinchase",
  "DAILY": "Coindaily",
  "CGT": "Coingrid",
  "CTIC": "Coinmatic",
  "COI": "Coinnec",
  "CNO": "Coino",
  "CNMT": "Coinomat",
  "CXT": "Coinonat",
  "XCXT": "CoinonatX",
  "TCJ": "Coinshare",
  "CEN": "Coinsuper Ecosystem Network",
  "COIN": "Coinvest",
  "CWT": "Coinware",
  "CXG": "Coinxes",
  "COLX": "ColossusCoinXT",
  "CLN": "Colu Local Network",
  "CBP": "ComBox",
  "CMTC": "CometCoin",
  "CBT": "CommerceBlock Token",
  "CMM": "Commercium",
  "COMM": "Community Coin",
  "COC": "Community Coin",
  "CMP": "Compcoin",
  "COMP": "Compound Coin",
  "CPN": "CompuCoin",
  "CYC": "ConSpiracy Coin",
  "CNL": "ConcealCoin",
  "RAIN": "Condensate",
  "CFD": "Confido",
  "CJR": "Conjure",
  "CJT": "ConnectJob Token",
  "CTY": "Connecty",
  "CQST": "ConquestCoin",
  "SEN*": "Consensus",
  "DAG": "Constellation",
  "CNN": "Content Neutrality Network",
  "CAN*": "Content and AD Network",
  "BOX": "ContentBox",
  "COS": "Contentos",
  "CUZ": "Cool Cousin",
  "COOL": "CoolCoin",
  "CCX": "CoolDarkCoin",
  "XCPO": "Copico",
  "CLR": "CopperLark",
  "CORAL": "CoralPay",
  "CORE": "Core Group Asset",
  "COR": "Corion",
  "CTXC": "Cortex",
  "COSX": "Cosmecoin",
  "CSMIC": "Cosmic",
  "CMOS": "Cosmo",
  "COSM": "CosmoChain",
  "ATOM*": "Cosmos",
  "CMC": "CosmosCoin",
  "COU": "Couchain",
  "XCP": "CounterParty",
  "CHT": "Countinghouse Fund",
  "COV*": "CovenCoin",
  "COV": "Covesting",
  "CPLO": "Cpollo",
  "CRAB": "CrabCoin",
  "CRACK": "CrackCoin",
  "CRAFT": "Craftcoin",
  "CFTY": "Crafty",
  "CRAIG": "CraigsCoin",
  "CRNK": "CrankCoin",
  "CRAVE*": "Crave-NG",
  "CRAVE": "CraveCoin",
  "CRV": "Cravy",
  "CZC": "Crazy Coin",
  "CRM": "Cream",
  "XCRE": "Creatio",
  "CREA": "CreativeChain",
  "CRDNC": "Credence Coin",
  "PESA": "Credible",
  "CREDIT": "Credit",
  "CRB": "Creditbit",
  "CRE*": "Creditcoin",
  "CCOIN": "Creditcoin",
  "CDPT": "Creditor Data Platform",
  "CRE": "Credits",
  "CRDS": "Credits",
  "CS*": "Credits",
  "CFT*": "Credo",
  "CREDO": "Credo",
  "CREVA": "Creva Coin",
  "CROAT": "Croat",
  "CMCT": "Crowd Machine",
  "CRC***": "CrowdCoin",
  "CCOS": "CrowdCoinage",
  "CRF": "CrowdForce",
  "CDP": "CrowdPrecision",
  "YUP": "Crowdholding",
  "WIZ": "Crowdwiz",
  "CRW": "Crown Coin",
  "CRC**": "CryCash",
  "IPT": "Crypt-ON",
  "CRYPT": "CryptCoin",
  "CPT": "Cryptaur",
  "CRL": "Cryptelo Coin",
  "CRPT": "Crypterium",
  "XCR": "Crypti",
  "CRYP": "CrypticCoin",
  "QRP": "Cryptics",
  "CTO": "Crypto",
  "ANGEL": "Crypto Angel",
  "CESC": "Crypto Escudo",
  "CIF": "Crypto Improvement Fund",
  "CSPN": "Crypto Sports",
  "TKT": "Crypto Tickets",
  "CWEX": "Crypto Wine Exchange",
  "CWIS": "Crypto Wisdom Coin",
  "CWX": "Crypto-X",
  "MCO": "Crypto.com",
  "CRO": "Crypto.com Chain Token",
  "C20": "Crypto20",
  "CABS": "CryptoABS",
  "BUK": "CryptoBuk",
  "CBX": "CryptoBullion",
  "CCRB": "CryptoCarbon",
  "CIRC": "CryptoCircuits",
  "FCS": "CryptoFocus",
  "CFT": "CryptoForecast",
  "CHBR": "CryptoHub",
  "TKR": "CryptoInsight",
  "CJ": "CryptoJacks",
  "CJC": "CryptoJournal",
  "LEU": "CryptoLEU",
  "CPAY": "CryptoPay",
  "CRPS": "CryptoPennies",
  "PING": "CryptoPing",
  "CP": "CryptoProfile",
  "CREV": "CryptoRevolution",
  "CR": "CryptoRiyal",
  "CS": "CryptoSpots",
  "CWV": "CryptoWave",
  "CWXT": "CryptoWorldXToken",
  "CRON": "Cryptocean",
  "CCIN": "Cryptocoin Insurance",
  "CDX*": "Cryptodex",
  "CGA": "Cryptographic Anomaly",
  "CIX100": "Cryptoindex",
  "CYT": "Cryptokenz",
  "CIX": "Cryptonetix",
  "CNX": "Cryptonex",
  "XCN": "Cryptonite",
  "CEFS": "CryptopiaFeeShares",
  "CRS": "Cryptoreal",
  "CXA": "CryptovationX",
  "OXY2": "Cryptoxygen",
  "MN": "Cryptsy Mining Contract",
  "POINTS": "Cryptsy Points",
  "CRTM": "Cryptum",
  "CVCOIN": "Crypviser",
  "CCT": "Crystal Clear Token",
  "AUTO": "Cube",
  "QBT": "Cubits",
  "CUR": "Cura Network",
  "CTKN": "Curaizon",
  "CURE": "Curecoin",
  "CRU": "Curium",
  "CBUK": "CurveBlock",
  "CHFT": "CustomCoin",
  "CCL": "CyClean",
  "XCS": "CybCSec Coin",
  "CCI": "Cyber Capital Invest",
  "CC": "CyberCoin",
  "CMT": "CyberMiles",
  "CABS*": "CyberTrust",
  "CVT": "CyberVein",
  "CRE**": "Cybereits Token",
  "CYDER": "Cyder Coin",
  "CYG": "Cygnus",
  "CYP": "CypherPunkCoin",
  "FUNK": "Cypherfunks Coin",
  "CYRS": "Cyrus Token",
  "DACH": "DACH Coin",
  "DAC": "DACash",
  "DADI": "DADI",
  "DAX": "DAEX",
  "BET*": "DAO.casino",
  "GEN*": "DAOstack",
  "DAPS": "DAPS Token",
  "DAS": "DAS",
  "DATX": "DATx",
  "DAV*": "DAV",
  "DRP": "DCORP",
  "DEEX": "DEEX",
  "CET*": "DICE Money",
  "DIM": "DIMCOIN",
  "DIW": "DIWtoken",
  "DMT": "DMarket",
  "DNTX": "DNAtix",
  "DNN": "DNN Token",
  "MTC": "DOCADEMIC",
  "DOV": "DOVU",
  "DREAM*": "DREAM",
  "DRPU": "DRP Utility",
  "DRACO": "DT Token",
  "DYNO": "DYNO",
  "DAI": "Dai",
  "DAN": "Daneel",
  "DXC*": "Daox",
  "DAR": "Darcrus",
  "PROD": "Darenta",
  "DEC": "Darico",
  "DARK": "Dark",
  "DISK": "Dark Lisk",
  "MOOND": "Dark Moon",
  "DB": "DarkBit",
  "DRKC": "DarkCash",
  "DCC": "DarkCrave",
  "DETH": "DarkEther",
  "DGDC": "DarkGold",
  "DKC": "DarkKnightCoin",
  "DANK": "DarkKush",
  "DSB": "DarkShibe",
  "DT": "DarkToken",
  "DRKT": "DarkTron",
  "DNET": "Darknet",
  "DASC": "DasCoin",
  "DASH": "Dash",
  "DSH": "Dashcoin",
  "DTA": "Data",
  "DTT*": "Data Trading",
  "DTX": "DataBroker DAO",
  "DXT": "DataWallet",
  "DTB": "Databits",
  "DBCCOIN": "Datablockchain",
  "DTC*": "Datacoin",
  "XDT": "Dataeum",
  "DTN": "Datareum",
  "DTRC": "Datarius",
  "DAT": "Datum",
  "DAV": "DavorCoin",
  "DAXX": "DaxxCoin",
  "DTC": "DayTrader Coin",
  "DAYTA": "Dayta",
  "DHT": "DeHedge Token",
  "DNET*": "DeNet",
  "XNA": "DeOxyRibose",
  "DBC*": "Debit Coin",
  "DBTC": "DebitCoin",
  "DEB": "Debitum Token",
  "DCT": "Decent",
  "DBET": "Decent.bet",
  "MANA": "Decentraland",
  "DACC": "Decentralized Accessible Content Chain",
  "DML": "Decentralized Machine Learning",
  "DUBI": "Decentralized Universal Basic Income",
  "HST": "Decision Token",
  "DCR": "Decred",
  "DEEP": "Deep Gold",
  "DBC": "DeepBrain Chain",
  "ONION": "DeepOnion",
  "DEA": "Degas Coin",
  "DEI": "Deimos",
  "DKD": "Dekado",
  "DEL": "DelChain",
  "DPAY": "DelightPay",
  "DPT": "Deliverers Power Token",
  "DPY": "Delphy",
  "DLXV": "Delta-X",
  "DCRE": "DeltaCredits",
  "DNR": "Denarius",
  "DNO": "Denaro",
  "DENT": "Dent",
  "DCN": "Dentacoin",
  "DFBT": "DentalFix",
  "DEPO": "Depository Network",
  "DERO": "Dero",
  "DESI": "Desico",
  "DSR": "Desire",
  "DES": "Destiny",
  "DTCT": "DetectorToken",
  "DTH": "Dether",
  "DVC": "DevCoin",
  "EVE": "Devery",
  "DEV": "Deviant Coin",
  "DXG": "DexAge",
  "DMD": "Diamond",
  "DCK": "DickCoin",
  "DIGS": "Diggits",
  "DGB": "DigiByte",
  "DGC": "DigiCoin",
  "CUBE": "DigiCube",
  "DEUR": "DigiEuro",
  "DIGIF": "DigiFel",
  "DFXT": "DigiFinexToken",
  "DGM": "DigiMoney",
  "DGPT": "DigiPulse",
  "DGMS": "Digigems",
  "DAGT": "Digital Asset Guarantee Token",
  "DPP": "Digital Assets Power Play",
  "DBG": "Digital Bullion Gold",
  "DDF": "Digital Developers Fund",
  "DFS": "Digital Fantasy Sports",
  "TMTG": "Digital Gold Exchange",
  "DRS": "Digital Rupees",
  "XDN": "DigitalNote",
  "DP": "DigitalPrice",
  "DGTX": "Digitex Futures",
  "WAGE": "Digiwage",
  "DGD": "Digix DAO",
  "DGX": "Digix Gold token",
  "DIG": "Dignity",
  "DIME": "DimeCoin",
  "DCY": "Dinastycoin",
  "DIN": "Dinero",
  "XDQ": "Dirac Coin",
  "DIS": "DiscoveryIoT",
  "DCC*": "Distributed Credit Chain",
  "DIT": "Ditcoin",
  "DIVX": "Divi Exchange Token",
  "DIVI": "Divi Project",
  "DTC**": "DivotyCoin",
  "DXC": "DixiCoin",
  "DLISK": "Dlisk",
  "NOTE": "Dnotes",
  "DOC": "Doc Coin",
  "NRN": "Doc.ai Neuron",
  "DOCK": "Dock.io",
  "DOGED": "DogeCoinDark",
  "DGORE": "DogeGoreCoin",
  "XDP": "DogeParty",
  "DOGE": "Dogecoin",
  "DLA": "Dolla",
  "DT1": "Dollar Token 1",
  "DLC": "DollarCoin",
  "DLR": "DollarOnline",
  "DRT": "DomRaider",
  "DON": "DonationCoin",
  "DDL": "Donocle",
  "DOPE": "DopeCoin",
  "DOR": "Dorado",
  "DOT": "Dotcoin",
  "BOAT": "Doubloon",
  "Dow": "DowCoin",
  "DRA": "DraculaCoin",
  "DFT": "Draftcoin",
  "DRG": "Dragon Coin",
  "XDB": "DragonSphere",
  "DRGN": "Dragonchain",
  "DRM8": "Dream8Coin",
  "DREAM": "DreamTeam Token",
  "DRF": "Drife",
  "DRZ": "Droidz",
  "DRC": "Dropcoin",
  "DROP": "Dropil",
  "DRXNE": "Droxne",
  "DUB": "DubCoin",
  "DBIC": "DubaiCoin",
  "DBIX": "DubaiCoin",
  "DUCK": "DuckDuckCoin",
  "DUSK": "Dusk Network",
  "DUTCH": "Dutch Coin",
  "DUX": "DuxCoin",
  "DYC": "Dycoin",
  "DYN": "Dynamic",
  "DTR": "Dynamic Trading Rights",
  "DYNCOIN": "Dyncoin",
  "DTEM": "Dystem",
  "DBR": "Dï¿½ber",
  "ECC*": "E-CurrencyCoin",
  "EDR": "E-Dinar Coin",
  "EFL": "E-Gulden",
  "EB3": "EB3coin",
  "EBC": "EBCoin",
  "ECC": "ECC",
  "OMI": "ECOMI",
  "ECO": "ECOcoin",
  "EDRC": "EDRCoin",
  "EGO": "EGOcoin",
  "EJAC": "EJA Coin",
  "ELTCOIN": "ELTCOIN",
  "EMANATE": "EMANATE",
  "EMX": "EMX",
  "ET": "ENDO",
  "ENTRC": "ENTER COIN",
  "ENTRY": "ENTRY",
  "EOT*": "EON",
  "EOS": "EOS",
  "EPIK": "EPIK Token",
  "EQL": "EQUAL",
  "EQ": "EQUI",
  "EQUI": "EQUI Token",
  "ERB": "ERBCoin",
  "EST": "ESports Chain",
  "XBASE": "ETERBASE",
  "ETS": "ETH Share",
  "ERA": "ETHA",
  "ETHO": "ETHER-1",
  "EGAS": "ETHGAS",
  "EUNO": "EUNO",
  "EVOS": "EVOS",
  "EXMR": "EXMR",
  "EXRN": "EXRNchain",
  "ETE": "EXTRADECOIN",
  "EYE": "EYE Token",
  "EZX": "EZ Exchange",
  "EZC": "EZCoin",
  "EZM": "EZMarket",
  "EZT": "EZToken",
  "EA": "EagleCoin",
  "EAGS": "EagsCoin",
  "EARTH": "Earth Token",
  "EAC": "EarthCoin",
  "EGDC": "EasyGuide",
  "EMT": "EasyMine",
  "ETKN": "EasyToken",
  "EBZ": "Ebitz",
  "EBS": "EbolaShare",
  "EKO": "EchoLink",
  "EC": "Eclipse",
  "ECOB": "EcoBit",
  "ECR": "EcoVerse",
  "EDDIE": "Eddie coin",
  "EDN": "EdenChain",
  "EDGE": "EdgeCoin",
  "EDG": "Edgeless",
  "EDU": "EduCoin",
  "LEDU": "Education Ecosystem",
  "EDC": "EducoinV",
  "EGG": "EggCoin",
  "EGT": "Egretia",
  "EDO": "Eidoo",
  "EMC2": "Einsteinium",
  "ELC": "Elacoin",
  "XEL": "Elastic",
  "ELA": "Elastos",
  "ECA": "Electra",
  "ELEC": "Electrify.Asia",
  "ELT": "Electron",
  "ETN": "Electroneum",
  "EKN": "Elektron",
  "ELE": "Elementrem",
  "ELM": "Elements",
  "ELES": "Elements Estates",
  "ELI*": "Elicoin",
  "ELI": "Eligma",
  "ELIX": "Elixir",
  "ELLA": "Ellaism",
  "ELP": "Ellerium",
  "ELLI": "ElliotCoin",
  "ELY": "Elysian",
  "ELS": "Elysium",
  "AEC*": "EmaratCoin",
  "EMB": "EmberCoin",
  "MBRS": "Embers",
  "EMD": "Emerald",
  "EMC": "Emercoin",
  "EMN": "Eminent Token",
  "EMIGR": "EmiratesGoldCoin",
  "EPY*": "Emphy",
  "PLEO": "Empleos",
  "EMPC": "EmporiumCoin",
  "EPY": "Empyrean",
  "ENCX": "Encrybit",
  "DNA": "EncrypGen",
  "ETT": "EncryptoTel",
  "ENCN": "EndChain",
  "EDR*": "Endor Protocol Token",
  "ENE": "EneCoin",
  "ENQ": "Enecuum",
  "NRG": "Energi",
  "ETK": "Energi Token",
  "TSL": "Energo",
  "ENRG": "EnergyCoin",
  "ENGT": "Engagement Token",
  "EGCC": "Engine",
  "XNG": "Enigma",
  "ENG": "Enigma",
  "ENJ": "Enjin Coin",
  "ENK": "Enkidu",
  "ENTER": "EnterCoin (ENTER)",
  "ENTRP": "Entropy Token",
  "ENU": "Enumivo",
  "ENV": "Envienta",
  "EVN": "Envion",
  "NVOY": "Envoy",
  "ZYM": "Enzym",
  "EQUAL": "EqualCoin",
  "EQT": "EquiTrader",
  "EQB": "Equibit",
  "EQM": "Equilibrium Coin",
  "EQY": "Eqwity",
  "ERE": "Erecoin",
  "EFYT": "Ergo",
  "ERT*": "Eristica",
  "ERO": "Eroscoin",
  "ERR": "ErrorCoin",
  "ERY": "Eryllium",
  "ESP": "Espers",
  "ERT": "Esports.com",
  "ESS": "Essentia",
  "ETALON": "Etalon",
  "XEC": "Eternal Coin",
  "XET": "Eternal Token",
  "ETT*": "Eternal Trusts",
  "ENT": "Eternity",
  "EBET": "EthBet",
  "ETBS": "EthBits",
  "LEND": "EthLend",
  "HEAL": "Etheal",
  "ETHB": "EtherBTC",
  "EDT": "EtherDelta",
  "DOGETH": "EtherDoge",
  "ETI": "EtherInc",
  "ETL": "EtherLite",
  "ESZ": "EtherSportz",
  "ETZ": "EtherZero",
  "ECH": "EthereCash",
  "ETH": "Ethereum",
  "ETBT": "Ethereum Black",
  "BLUE": "Ethereum Blue",
  "ECASH": "Ethereum Cash",
  "ETC": "Ethereum Classic",
  "ETHD": "Ethereum Dark",
  "ETG": "Ethereum Gold",
  "ETHM": "Ethereum Meta",
  "EMV": "Ethereum Movie Venture",
  "ETHPR": "Ethereum Premium",
  "EQC": "Ethereum Qchain Token",
  "LNK": "Ethereum.Link",
  "BTCE": "EthereumBitcoin",
  "ETF": "EthereumFog",
  "ELITE": "EthereumLite",
  "ETHS": "EthereumScrypt",
  "DIP": "Etherisc",
  "RIYA": "Etheriya",
  "DICE": "Etheroll",
  "FUEL": "Etherparty",
  "ESN": "Ethersocial",
  "ESC": "Ethersportcoin",
  "NEC*": "Ethfinex Nectar Token",
  "ETHIX": "EthicHub",
  "HORSE": "Ethorse",
  "ETHOS": "Ethos",
  "ET4": "Eticket4",
  "EUC": "Eurocoin",
  "ECTE": "EurocoinToken",
  "ERC": "EuropeCoin",
  "EVN*": "EvenCoin",
  "EVENT": "Event Token",
  "EVC": "Eventchain",
  "EGC": "EverGreenCoin",
  "EVER": "EverLife.AI",
  "EVX": "Everex",
  "IQ": "Everipedia",
  "EVR": "Everus",
  "EOC": "EveryonesCoin",
  "EVIL": "EvilCoin",
  "EXB": "ExaByte (EXB)",
  "XUC": "Exchange Union",
  "EXCC": "ExchangeCoin",
  "EXN": "ExchangeN",
  "EXCL": "Exclusive Coin",
  "EXE": "ExeCoin",
  "XNT": "Exenium",
  "EXC": "Eximchain",
  "EXIT": "ExitCoin",
  "EXO": "Exosis",
  "EXP": "Expanse",
  "EXPR": "Expercoin",
  "XP": "Experience Points",
  "EXT*": "Experience Token",
  "EXY": "Experty",
  "EON": "Exscudo",
  "TAURI": "Extauri",
  "EXTN": "Extensive Coin",
  "XTRA": "ExtraCredit",
  "ELT*": "ExtraLovers",
  "XSB": "Extreme Sportsbook",
  "XT": "ExtremeCoin",
  "F16": "F16Coin",
  "FARM": "FARM Coin",
  "FX": "FCoin",
  "FIBRE": "FIBRE",
  "eFIC": "FIC Network",
  "FLASH": "FLASH coin",
  "FLIK": "FLiK",
  "FLM": "FOLM coin",
  "FOREX": "FOREXCOIN",
  "FRED": "FREDEnergy",
  "FREE": "FREE coin",
  "FXP": "FXPay",
  "FABA": "Faba Invest",
  "FT": "Fabric Token",
  "FC": "Facecoin",
  "FACE": "Faceter",
  "FTR": "FactR",
  "FCT": "Factoids",
  "FAIR": "FairCoin",
  "FAIR*": "FairGame",
  "FAIRC": "Faireum Token",
  "FAME": "FameCoin",
  "FAN": "Fan360",
  "FANZ": "FanChain",
  "XFT": "Fantasy Cash",
  "FTM": "Fantom",
  "FCN": "FantomCoin",
  "FRD": "Farad",
  "F2K": "Farm2Kitchen",
  "FTT": "FarmaTrust",
  "FST": "FastCoin",
  "FTUM": "Fatum",
  "DROP*": "FaucetCoin",
  "FAZZ": "FazzCoin",
  "FTC": "FeatherCoin",
  "TIPS": "FedoraCoin",
  "FET": "Fetch.AI",
  "FIH": "Fidelity House",
  "FLC": "Fieldcoin",
  "FIII": "Fiii",
  "FIL": "FileCoin",
  "FFM": "Files.fm Library",
  "FILL": "Fillit",
  "FNTB": "FinTab",
  "FNX": "FinanceX",
  "FIND": "FindCoin",
  "FNL": "Finlocale",
  "FIN": "Finom FIN Token",
  "NOM": "Finom NOM Token",
  "FTX": "FintruX",
  "FIRE": "FireCoin",
  "FLOT": "FireLotto",
  "FRC": "FireRoosterCoin",
  "FFC": "FireflyCoin",
  "1ST": "FirstBlood",
  "FIRST": "FirstCoin",
  "FRST": "FirstCoin",
  "FIST": "FistBump",
  "FIT": "Fitcoin",
  "FRV": "Fitrova",
  "FLAP": "Flappy Coin",
  "FLX": "Flash",
  "FLVR": "FlavorCoin",
  "FNP": "FlipNpik",
  "FLIXX": "Flixxo",
  "FLO": "Flo",
  "FLT": "FlutterCoin",
  "FLUZ": "FluzFluz",
  "FLY": "FlyCoin",
  "FYP": "FlypMe",
  "FOAM": "Foam",
  "FLDC": "Folding Coin",
  "FLLW": "Follow Coin",
  "FNO": "Fonero",
  "FONZ": "FonzieCoin",
  "FOOD": "FoodCoin",
  "FOPA": "Fopacoin",
  "FOR": "Force Coin",
  "XFC": "Forever Coin",
  "FML": "FormulA",
  "FFCT": "FortFC",
  "FOTA": "Fortuna",
  "FSBT": "Forty Seven Bank",
  "FOXT": "Fox Trading",
  "FRAC": "FractalCoin",
  "FRN": "Francs",
  "FRK": "Franko",
  "FRWC": "Frankywillcoin",
  "FRAZ": "FrazCoin",
  "FGZ": "Free Game Zone",
  "FRE": "FreeCoin",
  "FRECN": "Freldo",
  "FREC": "Freyrchain",
  "FSC": "FriendshipCoin",
  "FDZ": "Friendz",
  "FUCK": "Fuck Token",
  "FC2": "Fuel2Coin",
  "FJC": "FujiCoin",
  "NTO": "Fujinto",
  "FLS": "Fuloos Coin",
  "FUNC": "FunCoin",
  "FUN": "FunFair",
  "FUND": "Fund Platform",
  "FUNDZ": "FundFantasy",
  "FND": "FundRequest",
  "FYN": "FundYourselfNow",
  "ATON": "Further Network",
  "FSN*": "Fusion",
  "FSN": "Fusion",
  "FUTC": "FutCoin",
  "FTRC": "FutureCoin",
  "FTP": "FuturePoints",
  "FTW": "FutureWorks",
  "FPC": "Futurepia",
  "FTO": "FuturoCoin",
  "FXT": "FuzeX",
  "FUZZ": "Fuzzballs",
  "GAIA": "GAIA Platform",
  "GAKH": "GAKHcoin",
  "GTX": "GALLACTIC",
  "GMB": "GAMB",
  "GAT": "GATCOIN",
  "GBRC": "GBR Coin",
  "GGP": "GGPro",
  "GGR": "GGRocket",
  "GTO": "GIFTO",
  "GIN": "GINcoin",
  "GIZ": "GIZMOcoin",
  "GMC*": "GMC Coin",
  "GPU": "GPU Coin",
  "GSM": "GSM Coin",
  "GXS": "GXChain",
  "GBO": "Gabro.io",
  "GEP": "Gaia",
  "GNR": "Gainer",
  "ORE": "Galactrum",
  "GES": "Galaxy eSolutions",
  "GLX": "GalaxyCoin",
  "GALI": "Galilel",
  "GLN": "Galion Token",
  "GAM": "Gambit coin",
  "GMCN": "GambleCoin",
  "GTC": "Game",
  "GXT": "Game Protocol",
  "GBT": "GameBetCoin",
  "GML": "GameLeagueCoin",
  "GST": "GameStars",
  "UNITS": "GameUnits",
  "GX": "GameX",
  "GAME": "Gamecredits",
  "GDX": "Gamedex",
  "FLP": "Gameflip",
  "GNJ": "GanjaCoin V2",
  "GAP": "Gapcoin",
  "GRLC": "Garlicoin",
  "GAS": "Gas",
  "FORK": "Gastro Advisor Token",
  "GBA": "Geeba",
  "GEMA": "Gemera",
  "GUSD": "Gemini Dollar",
  "GEM": "Gems",
  "GMS": "Gemstra",
  "GEMZ": "Gemz Social",
  "GXC*": "GenXCoin",
  "GNX": "Genaro Network",
  "GENX": "Genesis Network",
  "GVT": "Genesis Vision",
  "XGS": "GenesisX",
  "GSY": "GenesysCoin",
  "GEN": "Genstake",
  "GEO": "GeoCoin",
  "GUNS": "GeoFunders",
  "GEON": "Geon",
  "GER": "GermanCoin",
  "SPKTR": "Ghost Coin",
  "GHC": "GhostCoin",
  "GHOUL": "Ghoul Coin",
  "GIC": "Giant",
  "GIFT": "GiftNet",
  "GFT": "Giftcoin",
  "GIG": "GigCoin",
  "GBTC": "GigTricks",
  "WTT": "Giga Watt",
  "GZB": "Gigzi",
  "GGS": "Gilgam",
  "GIM": "Gimli",
  "GMR": "Gimmer",
  "GGC": "Gingr",
  "GOT": "Giotto Coin",
  "GIVE": "GiveCoin",
  "GLA": "Gladius",
  "GLOBE": "Global",
  "GCR": "Global Currency Reserve",
  "GJC": "Global Jobcoin",
  "GSC": "Global Social Chain",
  "GTC*": "Global Tour Coin",
  "GTIB": "Global Trust Coin",
  "BSTY": "GlobalBoost",
  "GLC": "GlobalCoin",
  "GLT": "GlobalToken",
  "GVE": "Globalvillage Ecosystem",
  "GSI": "Globex SCI",
  "GBXT": "Globitex Token",
  "GSX": "GlowShares",
  "GLYPH": "GlyphCoin",
  "GNO": "Gnosis",
  "xGOx": "Go!",
  "GBX": "GoByte",
  "GO": "GoChain",
  "GOT*": "GoToken",
  "GOA": "GoaCoin",
  "GOAL": "Goal Bonanza",
  "GOAT": "Goat",
  "GBE": "Godbex",
  "GDL": "GodlyCoin",
  "XR": "Gofind XR",
  "GPL": "Gold Pressed Latinum",
  "GRX": "Gold Reward Token",
  "GB": "GoldBlocks",
  "GLD": "GoldCoin",
  "MNTP": "GoldMint",
  "GP": "GoldPieces",
  "XGR": "GoldReserve",
  "GMA": "Goldchip Mining Asset",
  "GEA": "Goldea",
  "XGH": "Golden Hash",
  "XGB": "GoldenBird",
  "GLDR": "Golder Coin",
  "GMX": "Goldmaxcoin",
  "GNT": "Golem Network Token",
  "GOLF": "GolfCoin",
  "GOLOS": "Golos",
  "GBG": "Golos Gold",
  "GOOD": "GoodCoin",
  "GOOD*": "Goodomy",
  "GOON": "Goonies",
  "BUCKS*": "GorillaBucks",
  "GOTX": "GothicCoin",
  "GRFT": "Graft Blockchain",
  "GDC": "GrandCoin",
  "GAI": "GraphGrail AI",
  "77G": "GraphenTech",
  "GRAV": "Graviton",
  "GBIT": "GravityBit",
  "WPP": "Green Energy Token",
  "GRE": "GreenCoin",
  "GRMD": "GreenMed",
  "GEX": "GreenX",
  "GNC": "Greencoin",
  "GTN": "Greentoken",
  "GREXIT": "GrexitCoin",
  "GC": "Gric Coin",
  "GRID": "Grid+",
  "GRC": "GridCoin",
  "GRM": "GridMaster",
  "GMC": "Gridmaster",
  "GRIN": "Grin",
  "GRS": "Groestlcoin",
  "GRO": "Gron Digital",
  "GRWI": "Growers International",
  "GROW": "GrownCoin",
  "GRW": "GrowthCoin",
  "GTR": "Gturbo",
  "GET": "Guaranteed Entrance Token",
  "GETX": "Guaranteed Ethurance Token Extra",
  "GUAR": "Guarium",
  "GCC": "GuccioneCoin",
  "GUE": "GuerillaCoin",
  "NLG": "Gulden",
  "GUN": "GunCoin",
  "GUP": "Guppy",
  "GXC": "Gx Coin",
  "HIDU": "H-Education World",
  "HART": "HARA",
  "HBZ": "HBZ Coin",
  "HIX": "HELIX Orange",
  "HELL": "HELL COIN",
  "HRO": "HEROIC.com",
  "PLAY": "HEROcoin",
  "HOLD": "HOLD",
  "HLDY": "HOLIDAY",
  "HQX": "HOQU",
  "HODL": "HOdlcoin",
  "HTML": "HTML Coin",
  "HTML5": "HTML5 Coin",
  "HUS": "HUSSY",
  "HYC": "HYCON",
  "HYGH": "HYGH",
  "HKN": "Hacken",
  "HKG": "Hacker Gold",
  "HAC": "Hackspace Capital",
  "HPAY": "HadePay",
  "HLC": "Halal-Chain",
  "HAL": "Halcyon",
  "HALLO": "Halloween Coin",
  "HALO": "Halo Platform",
  "HMT": "Hamster Marketplace Token",
  "HAMS": "HamsterCoin",
  "HANA": "Hanacoin",
  "HPC": "HappyCoin",
  "HCC": "HappyCreatorCoin",
  "HRBE": "Harambee Token",
  "HRB": "Harbour DAO",
  "HMN": "Harvest Masternode Coin",
  "HSC": "HashCoin",
  "HGS": "HashGains",
  "HASH": "Hashbon",
  "GARD": "Hashgard",
  "XHV": "Haven Protocol",
  "HAT": "Hawala.Exchange",
  "HZT": "HazMatCoin",
  "HAZE": "HazeCoin",
  "HDAC": "Hdac",
  "HHEM": "Healthureum",
  "WORM": "HealthyWorm",
  "HB": "HeartBout",
  "HEAT": "Heat Ledger",
  "HVC": "HeavyCoin",
  "HDG": "Hedge Token",
  "HEDG": "HedgeTrade",
  "HEDGE": "Hedgecoin",
  "HEEL": "HeelCoin",
  "HYS": "Heiss Shares",
  "HLM": "Helium",
  "HLX": "Helix3",
  "HNC": "Hellenic Coin",
  "HGT": "Hello Gold",
  "HMP": "HempCoin",
  "HERB": "HerbCoin",
  "HERO": "Hero",
  "HER": "Hero Node",
  "HETA": "HetaChain",
  "HEX": "HexCoin",
  "HXC": "HexanCoin",
  "HXT": "HextraCoin",
  "HXX": "HexxCoin",
  "HMC": "Hi Mutual Society",
  "XHI": "HiCoin",
  "HIH": "HiHealth",
  "HPB": "High Performance Blockchain",
  "HVCO": "High Voltage Coin",
  "AIMS": "HighCastle Token",
  "HV": "HighVibe.Network",
  "HGO": "HireGo",
  "HIRE": "HireMatch",
  "HFT": "Hirefreehands",
  "HIT": "HitChain",
  "HTC": "Hitcoin",
  "HIVE": "Hive",
  "HVN": "Hiveterminal Token",
  "HBN": "HoboNickels",
  "HWC": "HollyWoodCoin",
  "HOT*": "Holo",
  "HBC": "HomeBlockCoin",
  "HMD": "Homelend",
  "HONEY": "Honey",
  "HZ": "Horizon",
  "HSP": "Horse Power",
  "HORUS": "HorusPay",
  "HYT": "HoryouToken",
  "HSR": "Hshare",
  "HBT": "Hubii Network",
  "HMQ": "Humaniq",
  "HNC*": "Huncoin",
  "HUC": "HunterCoin",
  "HT": "Huobi Token",
  "HUR": "Hurify",
  "HUSH": "Hush",
  "HOT": "Hydro Protocol",
  "HYDRO": "Hydrogen",
  "H2O": "Hydrominer",
  "H3O": "Hydrominer",
  "HC": "HyperCash",
  "HYPER": "HyperCoin",
  "HLD": "HyperLending",
  "HQT": "HyperQuant",
  "HBX": "Hyperbridge",
  "TREE": "HyperionX",
  "HPSP": "Hyperspace",
  "HYP": "Hyperstake",
  "IHT": "I-House Token",
  "I0C": "I0coin",
  "IAG": "IAGON",
  "IAM": "IAME Identity",
  "ICASH": "ICASH",
  "ICOO": "ICO OpenLedger",
  "ICOS": "ICOBox",
  "ICX": "ICON Project",
  "ICST": "ICST",
  "IDAC": "IDAC",
  "IDAP": "IDAP",
  "IDXM": "IDEX Membership",
  "IDM": "IDM",
  "IG": "IG Token",
  "IGTT": "IGT",
  "ILC": "ILCoin",
  "ILCT": "ILCoin Token",
  "IML": "IMMLA",
  "ITR": "INTRO",
  "IOC": "IOCoin",
  "IOST": "IOS token",
  "IOT": "IOTA",
  "IOTW": "IOTW",
  "IOUX": "IOU",
  "IOU": "IOU1",
  "IOV": "IOV",
  "IPSX": "IP Exchange",
  "IPC*": "IPChain",
  "IQN": "IQeon",
  "IRC": "IRONCOIN",
  "IVN": "IVN Security",
  "IXC": "IXcoin",
  "IZX": "IZX",
  "ROCK2": "Ice Rock Mining",
  "ICB": "IceBergCoin",
  "ICHX": "IceChain",
  "ICOB": "Icobid",
  "ICON": "Iconic",
  "ICN": "Iconomi",
  "IDC": "IdealCoin",
  "IGNIS": "Ignis",
  "IC": "Ignition",
  "REX": "Imbrex",
  "IMGZ": "Imigize",
  "IMVR": "ImmVRse",
  "IMX": "Impact",
  "IMPCH": "Impeach",
  "IPC": "ImperialCoin",
  "XIM": "Impresso",
  "IMPS": "Impulse Coin",
  "IN": "InCoin",
  "INX": "InMax",
  "NKA": "IncaKoin",
  "INCNT": "Incent",
  "INCP": "InceptionCoin",
  "INC": "Incrementum",
  "IDH": "IndaHash",
  "IMS": "Independent Money System",
  "ERC20": "Index ERC20",
  "INDI": "IndiCoin",
  "IND": "Indorse",
  "IFX": "Infinex",
  "IFC": "Infinite Coin",
  "XIN": "Infinity Economics",
  "INF8": "Infinium-8",
  "IFLT": "InflationCoin",
  "IFUM": "Infleum",
  "INFLR": "Inflr",
  "INTO": "Influ Token",
  "INFX": "Influxcoin",
  "INK": "Ink",
  "XNK": "Ink Protocol",
  "ILK": "Inlock",
  "SOUND": "Inmusik",
  "INN": "Innova",
  "MINX": "InnovaMinex",
  "INSN": "Insane Coin",
  "INSANE": "InsaneCoin",
  "WOLF": "Insanity Coin",
  "INSTAR": "Insights Network",
  "INS": "Insolar",
  "ICC": "Insta Cash Coin",
  "MINE": "Instamine Nuggets",
  "SPON": "Instant Sponsor Token",
  "INSUR": "InsurChain Coin",
  "IPL": "InsurePal",
  "ISR": "Insureum",
  "IQB": "Intelligence Quotient Benefit",
  "ITT": "Intelligent Trading",
  "XID*": "International Diamond Coin",
  "INT": "Internet Node Token",
  "IOP": "Internet of People",
  "INXT": "Internxt",
  "ISH": "Interstellar Holdings",
  "ITZ": "Interzone",
  "ICT": "Intrachain",
  "INV*": "Invacio",
  "IDT": "InvestDigital",
  "IFT": "InvestFeed",
  "INVX": "Investx",
  "IVC": "Investy Coin",
  "INV": "Invictus",
  "IHF": "Invictus Hyperion Fund",
  "IVZ": "InvisibleCoin",
  "INVOX": "Invox Finance",
  "IZA": "Inzura",
  "ITC": "IoT Chain",
  "IOTX": "IoTeX Network",
  "ION": "Ionomy",
  "TLU": "Irene Energy",
  "IRL": "IrishCoin",
  "ISL": "IslaCoin",
  "ITL": "Italian Lira",
  "ITA": "Italocoin",
  "ING": "Iungo",
  "IEC": "IvugeoEvolutionCoin",
  "IVY": "IvyKoin",
  "IWT": "IwToken",
  "J8T": "JET8",
  "JEX": "JEX Token",
  "JIO": "JIO Token",
  "JOYS": "JOYS",
  "JOY*": "JOYSO",
  "JSE": "JSEcoin",
  "JANE": "JaneCoin",
  "JNS": "Janus",
  "JVY": "Javvy",
  "JC": "JesusCoin",
  "JET": "Jetcoin",
  "JWL": "Jewels",
  "JIB": "Jibbit",
  "JNT": "Jibrel Network Token",
  "JIF": "JiffyCoin",
  "JCR": "Jincor",
  "JINN": "Jinn",
  "JOBS": "JobsCoin",
  "J": "JoinCoin",
  "JOINT": "Joint Ventures",
  "JOK": "JokerCoin",
  "XJO": "JouleCoin",
  "JOYT": "JoyToken",
  "JOY": "Joycoin",
  "JUDGE": "JudgeCoin",
  "JBS": "JumBucks Coin",
  "JUMP": "Jumpcoin",
  "JKC": "JunkCoin",
  "JMC": "Junson Ming Chan Coin",
  "JDC": "JustDatingSite",
  "KSYS": "K-Systems",
  "KAAS": "KAASY.AI",
  "KAT": "KATZcoin",
  "KEC": "KEYCO",
  "KIBIS": "KIBIS",
  "TOS": "KRATOS",
  "KRC": "KRCoin",
  "KREDS": "KREDS",
  "KUBO": "KUBO",
  "KWH": "KWHCoin",
  "KZC": "KZCash",
  "KLKS": "Kalkulus",
  "KAPU": "Kapu",
  "KBC": "Karatgold coin",
  "KRB": "Karbo",
  "KRM": "Karma",
  "KARMA": "Karma",
  "K2G": "Kasko2go",
  "KAYI": "Kayi",
  "KCASH": "Kcash",
  "KEK": "KekCoin",
  "KEN": "Kencoin",
  "KEP": "Kepler",
  "KC": "Kernalcoin",
  "KETAN": "Ketan",
  "KEX": "KexCoin",
  "KEY*": "KeyCoin",
  "KMX": "KiMex",
  "KICK": "KickCoin",
  "KLC": "KiloCoin",
  "KIN": "Kin",
  "KIND": "Kind Ads",
  "KVT": "Kinesis Velocity Token",
  "KING": "King93",
  "KNC**": "KingN Coin",
  "MEOW": "Kittehcoin",
  "KLK": "Klickzie",
  "KED": "Klingon Empire Darsek",
  "KDC": "Klondike Coin",
  "KNW": "Knowledge",
  "KOBO": "KoboCoin",
  "KOLION": "Kolion",
  "KMD": "Komodo",
  "KORE": "Kore",
  "KOTO": "Koto",
  "KUSD": "Kowala",
  "KRAK": "Kraken",
  "KRONE": "Kronecoin",
  "KSS": "Krosscoin",
  "KGC": "KrugerCoin",
  "KRL": "Kryll",
  "KTK": "KryptCoin",
  "KRP": "Kryptoin",
  "KR": "Krypton",
  "KBX": "KuBitX",
  "KBR": "Kubera Coin",
  "KUBOS": "KubosCoin",
  "KCS": "Kucoin",
  "KUE": "Kuende",
  "KURT": "Kurrent",
  "KUSH": "KushCoin",
  "KUV": "Kuverit",
  "KVT*": "Kvantor",
  "KNC": "Kyber Network",
  "LAX": "LAPO",
  "LA": "LATOKEN",
  "LBC": "LBRY Credits",
  "LAO": "LC Token",
  "LEO": "LEOcoin",
  "LGBTQ": "LGBTQoin",
  "LHC": "LHCoin",
  "LIFE": "LIFE",
  "LN": "LINK",
  "LNKC": "LINKCHAIN",
  "VEEN": "LIVEEN",
  "LIPC": "LIpcoin",
  "LTBC": "LTBCoin",
  "LTO": "LTO Network",
  "LUMA": "LUMA Token",
  "LUX": "LUXCoin",
  "LVX": "LVX",
  "LYN": "LYNCHPIN Token",
  "LALA": "LaLa World",
  "LBR": "LaborCrypto",
  "LAB": "Labrys",
  "BAC*": "LakeBanker",
  "TAU": "Lamden Tau",
  "PIX": "Lampix",
  "LANA": "LanaCoin",
  "AXIS": "LaneAxis",
  "LTH": "Lathaan",
  "LAT": "Latium",
  "LATX": "LatiumX",
  "LAZ": "Lazarus",
  "LEPEN": "LePenCoin",
  "LEA": "LeaCoin",
  "LDC": "LeadCoin",
  "LEAF": "LeafCoin",
  "LGD": "Legends Cryptocurrency",
  "LGO": "Legolas Exchange",
  "LELE": "Lelecoin",
  "LEMON": "LemonCoin",
  "LCT": "LendConnect",
  "LND": "Lendingblock",
  "LOAN": "Lendoit",
  "LST": "Lendroid Support Token",
  "LENIN": "LeninCoin",
  "LIR": "Let it Ride",
  "LTHN": "Lethean",
  "LVL*": "LevelNet Token",
  "LVG": "Leverage Coin",
  "LEV": "Leverj",
  "XLC": "LeviarCoin",
  "LIB": "Libellum",
  "XLB": "LibertyCoin",
  "LBA": "Libra Credit",
  "LXC": "LibrexCoin",
  "LIGER": "Ligercoin",
  "LSD": "LightSpeedCoin",
  "LPC*": "Lightpaycoin",
  "LIKE": "LikeCoin",
  "LK": "Liker",
  "LIMX": "LimeCoinX",
  "LTD": "Limited Coin",
  "LINDA": "Linda",
  "LET": "LinkEye",
  "LNC*": "Linker Coin",
  "LINX": "Linx",
  "LIPS": "LipChain",
  "LEN": "Liqnet",
  "LQD": "Liquid",
  "LQ8": "Liquid8",
  "LQDN": "Liquidity Network",
  "LSK": "Lisk",
  "LTCC": "Listerclassic Coin",
  "LBTC": "LiteBitcoin",
  "LTG": "LiteCoin Gold",
  "LTCU": "LiteCoin Ultra",
  "LCWP": "LiteCoinW Plus",
  "LTCR": "LiteCreed",
  "LDOGE": "LiteDoge",
  "LTB": "Litebar",
  "LTC": "Litecoin",
  "LTCH": "Litecoin Cash",
  "LCP": "Litecoin Plus",
  "LCASH": "LitecoinCash",
  "LCC": "LitecoinCash",
  "LTCD": "LitecoinDark",
  "LTCP": "LitecoinPro",
  "LTCX": "LitecoinX",
  "LTZ": "Litecoinz",
  "LNT": "Litenett",
  "LTS": "Litestar Coin",
  "LIT": "Lithium",
  "LITION": "Lition",
  "LTA": "Litra",
  "LPC": "Little Phil",
  "LIVE": "Live Stars",
  "LVN": "LivenPay",
  "LPT": "Livepeer",
  "LIV": "LiviaCoin",
  "LIZ": "Lizus Payment",
  "LTE": "Local Token Exchange",
  "LWF": "Local World Forwarders",
  "LCS": "LocalCoinSwap",
  "LOCI": "LociCoin",
  "LOC*": "LockTrip",
  "LOC": "Loco",
  "LGR": "Logarithm",
  "LOKI": "Loki",
  "LLG": "Loligo",
  "LMC": "LomoCoin",
  "LOOK": "LookCoin",
  "LOOM": "Loom Network",
  "LRC": "Loopring",
  "LOT": "LottoCoin",
  "LYK": "Loyakk Vega",
  "LYL": "LoyalCoin",
  "BASH": "LuckChain",
  "LCK": "Luckbox",
  "LK7": "Lucky7Coin",
  "LUCKY": "LuckyBlocks",
  "LKY": "LuckyCoin",
  "LCR": "Lucre",
  "LDM": "Ludum token",
  "LNL": "LunarLink",
  "LUN": "Lunyr",
  "LC": "Lutetium Coin",
  "LUX**": "Luxmi Coin",
  "LYC": "LycanCoin",
  "LDN": "Lydiancoin",
  "LYFE": "Lyfe",
  "LKK": "Lykke",
  "LYM": "Lympo",
  "LYNK": "Lynked.World",
  "LYNX": "Lynx",
  "LYB": "LyraBar",
  "M2O": "M2O Token",
  "MDN": "MADANA",
  "MAKE": "MAKE",
  "MRK": "MARK.SPACE",
  "MCAP": "MCAP",
  "MCV": "MCV Token",
  "MTEL": "MEDoctor",
  "MEETONE": "MEET.ONE",
  "MFX": "MFChain",
  "MIMI": "MIMI Money",
  "MIODIO": "MIODIOCOIN",
  "MIS": "MIScoin",
  "MILC": "MIcro Licensing Coin",
  "MMNXT": "MMNXT",
  "MMO": "MMOCoin",
  "MMXVI": "MMXVI",
  "MOAC": "MOAC",
  "MOBU": "MOBU",
  "MODEX": "MODEX Token",
  "MOS": "MOS Coin",
  "XDMC": "MPCX",
  "MSD": "MSD",
  "MTCMN": "MTC Mesh",
  "MUN": "MUNcoin",
  "MUSD": "MUSDcoin",
  "MUST": "MUST Protocol",
  "MVL": "MVL",
  "YCE": "MYCE",
  "MAC": "MachineCoin",
  "MCRN": "MacronCoin",
  "MRV": "Macroverse",
  "MDC*": "MadCoin",
  "ART": "Maecenas",
  "MAP": "Maester Protocol",
  "MAG**": "Maggie Token",
  "MGN": "MagnaCoin",
  "MAG": "Magnet",
  "MAG*": "Magos",
  "MAID": "MaidSafe Coin",
  "MMXIV": "MaieutiCoin",
  "MNC": "MainCoin",
  "MFT": "Mainframe",
  "MSC*": "MaisCoin",
  "MIV": "MakeItViral",
  "MKR": "Maker",
  "MAT*": "Manet Coin",
  "MANNA": "Manna",
  "MAPC": "MapCoin",
  "MAR": "MarijuanaCoin",
  "MASP": "Market.space",
  "MRS": "MarsCoin",
  "MARS": "MarsCoin",
  "MXT": "MartexCoin",
  "MARV": "Marvelous",
  "MARX": "MarxCoin",
  "MARYJ": "MaryJane Coin",
  "MSR": "Masari",
  "MC": "Mass Coin",
  "MASS": "Mass.Cloud",
  "MGD": "MassGrid",
  "MCAR": "MasterCar",
  "MSC": "MasterCoin",
  "MM": "MasterMint",
  "MTR": "MasterTraderCoin",
  "MAN*": "Matrix AI Network",
  "MTX": "Matryx",
  "MPG": "Max Property Group",
  "MAX": "MaxCoin",
  "MYC": "MayaCoin",
  "MZC": "MazaCoin",
  "MBIT": "Mbitbooks",
  "MLITE": "MeLite",
  "MDT*": "Measurable Data Token",
  "MED*": "MediBloc",
  "MEDI": "MediBond",
  "MCU": "MediChain",
  "MDS": "MediShares",
  "MNT*": "Media Network Coin",
  "MPT": "Media Protocol Token",
  "MEDX": "Mediblock",
  "MDC": "MedicCoin",
  "MEDIC": "MedicCoin",
  "MTN*": "Medicalchain",
  "MHP": "MedicoHealth",
  "MED": "MediterraneanCoin",
  "MPRO": "MediumProject",
  "MEC": "MegaCoin",
  "MEGA": "MegaFlash",
  "XMS": "Megastake",
  "MEL": "Melior AI",
  "MLN": "Melon",
  "MBN": "Membrana",
  "MET": "Memessenger",
  "EMT*": "Memority",
  "MMC": "MemoryCoin",
  "MPAY": "Menapay",
  "ONE": "Menlo One",
  "MENU": "MenuBuzz",
  "MRN": "Mercoin",
  "MVP": "Merculet",
  "MER": "Mercury",
  "GMT": "Mercury Protocol",
  "MHC": "MetaHash",
  "METM": "MetaMorph",
  "META": "Metadium",
  "MTL": "Metal",
  "MTLM3": "Metal Music v3",
  "METAL": "MetalCoin",
  "ETP": "Metaverse",
  "MET*": "Metronome",
  "MIT": "MiMiner",
  "MBTC": "MicroBitcoin",
  "AMM": "MicroMoney",
  "MDT": "Midnight",
  "MON": "MilionCoin",
  "MUU": "MilkCoin",
  "MIL": "Milllionaire Coin",
  "MILO": "MiloCoin",
  "MINC": "MinCoin",
  "MG": "Mind Gene",
  "MND": "MindCoin",
  "MIC": "Mindexcoin",
  "MAI": "Mindsync",
  "MINT*": "Mineable Token",
  "MIO": "Miner One token",
  "MIN": "Minerals Coin",
  "MNE": "Minereum",
  "MRT": "MinersReward",
  "MNM": "Mineum",
  "MINEX": "Minex",
  "MNX": "MinexCoin",
  "MAT": "MiniApps",
  "MNTS": "Mint",
  "MINT": "MintCoin",
  "BIP": "Minter",
  "MITH": "Mithril",
  "XIN*": "Mixin",
  "MIB": "Mobile Integrated Blockchain",
  "CHF*": "MobileBridge Momentum",
  "MGO": "MobileGo",
  "MOLK": "Mobilink Token",
  "MOBI": "Mobius",
  "MTRC": "ModulTrade",
  "MDL*": "Modulum",
  "MOD": "Modum",
  "MDA": "Moeda",
  "MOIN": "MoinCoin",
  "MOJO": "Mojocoin",
  "MOF": "Molecular Future",
  "MOL": "Molecule",
  "TAB": "MollyCoin",
  "MMTM": "Momentum",
  "MONA": "MonaCoin",
  "MNZ": "Monaize",
  "XMR": "Monero",
  "ZMR": "Monero 0",
  "XMC": "Monero Classic",
  "XMRG": "Monero Gold",
  "XMO": "Monero Original",
  "XMV": "MoneroV",
  "MONETA": "Moneta",
  "MNV": "MonetaVerde",
  "MUE": "MonetaryUnit",
  "MTH": "Monetha",
  "MTZ": "Monetizr",
  "MNB": "MoneyBag",
  "MONEY": "MoneyCoin",
  "MRP*": "MoneyRebel",
  "IMT": "MoneyToken",
  "MNY": "Monkey",
  "MONK": "Monkey Project",
  "XMCC": "Monoeci",
  "MNR": "Monoreto",
  "MBI": "Monster Byte Inc",
  "MBLC": "Mont Blanc",
  "MOON": "MoonCoin",
  "LX": "Moonlight",
  "MZG": "Moozicore",
  "MITX": "Morpheus Infrastructure Token",
  "MRPH": "Morpheus Network",
  "MRP": "MorpheusCoin",
  "MZX": "Mosaic Network",
  "MOAT": "Mother Of All Tokens",
  "MSP": "Mothership",
  "XMN": "Motion",
  "MTN**": "Motion",
  "MOTO": "Motocoin",
  "MOV": "MovieCoin",
  "MTK": "Moya Token",
  "MRSA": "MrsaCoin",
  "MUDRA": "MudraCoin",
  "MTT": "MulTra",
  "MLT": "MultiGames",
  "MWC": "MultiWallet Coin",
  "MBT": "Multibot",
  "MTCN": "Multiven",
  "MRY": "MurrayCoin",
  "MUSE": "Muse",
  "MITC": "MusicLife",
  "MUSIC": "Musicoin",
  "MCI": "Musiconomi",
  "MST": "MustangCoin",
  "MUT": "Mutual Coin",
  "MBC": "My Big Coin",
  "MYB": "MyBit",
  "MCB": "MyCryptoBank",
  "MYDFS": "MyDFS",
  "MAZC": "MyMazzu",
  "MT*": "MyToken",
  "WISH": "MyWish",
  "MT": "Mycelium Token",
  "MYO": "Mycro",
  "MPXT": "Myplacex",
  "XMY": "MyriadCoin",
  "MYST": "Mysterium",
  "NANJ": "NANJCOIN",
  "XEM": "NEM",
  "NEO": "NEO",
  "NEOG": "NEO Gold",
  "NEXO": "NEXO",
  "NOX": "NITRO",
  "NIX": "NIX",
  "NKN": "NKN",
  "NOAH": "NOAHCOIN",
  "NBAR": "NOBAR",
  "NOIA": "NOIA Network",
  "NOIZ": "NOIZ",
  "CHFN": "NOKU CHF",
  "EURN": "NOKU EUR",
  "NOKU": "NOKU Master token",
  "NSP": "NOMAD.space",
  "NOW": "NOW Token",
  "NPC": "NPCcoin",
  "NPER": "NPER",
  "NVST": "NVO",
  "NWP": "NWPSolution",
  "NXE": "NXEcoin",
  "NXTI": "NXTI",
  "NXTTY": "NXTTY",
  "NYN": "NYNJA",
  "NYX": "NYXCOIN",
  "NFN": "Nafen",
  "NGC": "NagaCoin",
  "NZE": "Nagezeni",
  "NKT": "NakomotoDark",
  "NAM": "Namacoin",
  "NMH": "Namahe",
  "NMC": "Namecoin",
  "NMK": "Namek",
  "NAMO": "NamoCoin",
  "NANO": "Nano",
  "NHCT": "Nano Healthcare Token",
  "NAN": "NanoToken",
  "NPX": "Napoleon X",
  "NRVE": "Narrative",
  "NAS2": "Nas2Coin",
  "NAUT": "Nautilus Coin",
  "NAV": "NavCoin",
  "NAVI": "NaviAddress",
  "NAVIB": "Navibration",
  "NEBL": "Neblio",
  "NEBU": "Nebuchadnezzar",
  "NBAI": "Nebula AI",
  "NAS": "Nebulas",
  "NDC*": "NeedleCoin",
  "NEF": "NefariousCoin",
  "NRX": "Neironix",
  "NEC": "NeoCoin",
  "NEX": "Neonexchange",
  "NEOS": "NeosCoin",
  "NTCC": "NeptuneClassic",
  "NBIT": "NetBit",
  "NET": "NetCoin",
  "NTM": "NetM",
  "NETKO": "Netko",
  "OUT": "Netscouters",
  "NTWK": "Network Token",
  "NETC": "NetworkCoin",
  "NEU*": "NeuCoin",
  "NEU": "Neumark",
  "NRP": "Neural Protocol",
  "NRO": "Neuro",
  "NRC": "Neurocoin",
  "NRM": "Neuromachine",
  "NTK": "Neurotoken",
  "NTRN": "Neutron",
  "NEVA": "NevaCoin",
  "NDC": "NeverDie",
  "NIC": "NewInvestCoin",
  "NYC": "NewYorkCoin",
  "NZC": "NewZealandCoin",
  "NEWB": "Newbium",
  "NEW": "Newton",
  "NCP": "Newton Coin",
  "NXC": "Nexium",
  "NEXT": "Next.exchange Token",
  "Pakka": "NextPakk",
  "NXS": "Nexus",
  "NEXXO": "Nexxo",
  "NGIN": "Ngin",
  "NICE": "NiceCoin",
  "NIHL": "Nihilo Coin",
  "NMB": "Nimbus Coin",
  "NIMFA": "Nimfamoney",
  "NIM": "Nimiq",
  "NTC": "NineElevenTruthCoin",
  "NDOGE": "NinjaDoge",
  "NBR": "Niobio Cash",
  "NBC": "Niobium",
  "$NOBS": "No BS Crypto",
  "NLC": "NoLimitCoin",
  "NLC2": "NoLimitCoin",
  "NOBL": "NobleCoin",
  "NODE": "Node",
  "NODIS": "Nodis",
  "NVDX": "Nodvix",
  "NRB": "NoirBits",
  "NRS": "NoirShares",
  "NUSD": "Nomin USD",
  "NZO": "NonZero",
  "NOO": "Noocoin",
  "NVC": "NovaCoin",
  "MNVM": "Novam",
  "NWCN": "NowCoin",
  "NBX": "Noxbox",
  "NBT": "NuBits",
  "NSR": "NuShares",
  "NUBIS": "NubisCoin",
  "NCASH": "Nucleus Vision",
  "NUKE": "NukeCoin",
  "NKC": "Nukecoinz",
  "NLX": "Nullex",
  "NULS": "Nuls",
  "N7": "Number7",
  "NUM": "NumbersCoin",
  "NMR": "Numeraire",
  "XNC*": "Numismatic Collections",
  "NMS": "Numus",
  "NXT": "Nxt",
  "NYAN": "NyanCoin",
  "NBL": "Nybble",
  "OATH": "OATH Protocol",
  "ODE": "ODEM",
  "ODMC": "ODMCoin",
  "OK": "OKCash",
  "OKOIN": "OKOIN",
  "ONAM": "ONAM",
  "OPC": "OP Coin",
  "OPP*": "OPP Open WiFi",
  "ORET": "ORET Token",
  "ORM": "ORIUM",
  "ORS": "ORS Group",
  "OASC": "Oasis City",
  "OBITS": "Obits Coin",
  "OBS": "Obscurebay",
  "ODN": "Obsidian",
  "OCL": "Oceanlab",
  "OTX": "Octanox",
  "OCTO*": "OctoBit Coin",
  "OCTO": "OctoCoin",
  "OWC": "Oduwa",
  "OCN": "Odyssey",
  "OFCR": "OfficerCoin",
  "OJX": "Ojooo",
  "OKB": "Okex",
  "OLM": "Olam",
  "ODNT": "Old Dogs New Tricks",
  "OLDSF": "OldSafeCoin",
  "OLV": "OldV",
  "OLE": "Olive",
  "OLYMP": "OlympCoin",
  "MOT": "Olympus Labs",
  "OMA": "OmegaCoin",
  "OMGC": "OmiseGO Classic",
  "OMG": "OmiseGo",
  "OMNI": "Omni",
  "OMC": "OmniCron",
  "ECOM": "Omnitude",
  "ONL": "On.Live",
  "OGT": "One Game",
  "OSF": "One Solution",
  "OLT": "OneLedger",
  "RNT": "OneRoot Network",
  "ONX": "Onix",
  "OIO": "Online",
  "ONT": "Ontology",
  "ONGAS": "Ontology Gas",
  "OPQ": "Opacity",
  "XPO": "Opair",
  "OPAL": "OpalCoin",
  "OPEN": "Open Platform",
  "OTN": "Open Trading Network",
  "OAX": "OpenANX",
  "BRIX": "OpenBrix",
  "CHAT": "OpenChat",
  "OSC": "OpenSourceCoin",
  "ZNT": "OpenZen",
  "OPES": "Opes",
  "OPP": "Opporty",
  "OPEX": "Optherium Token",
  "OSA": "Optimal Shelf Availability Token",
  "OPTION": "OptionCoin",
  "OPU": "Opu Coin",
  "OPT": "Opus",
  "OCT": "OracleChain",
  "OC": "OrangeCoin",
  "ORBS": "Orbis",
  "ORB": "Orbitcoin",
  "RDC": "Ordocoin",
  "ORGT": "Organic Token",
  "ORC": "Organicco",
  "ORI": "Origami",
  "ORS*": "OriginSport",
  "TRAC": "OriginTrail",
  "OCC": "Original Crypto Coin",
  "ORLY": "OrlyCoin",
  "ORME": "Ormeus Coin",
  "ORO": "OroCoin",
  "OROC": "Orocrypt",
  "ORV": "Orvium",
  "OICOIN": "Osmium Investment Coin",
  "OS76": "OsmiumCoin",
  "OWD": "Owlstand",
  "ZXC": "Oxcert",
  "OXY": "Oxycoin",
  "PRL": "Oyster Pearl",
  "OYS": "Oyster Platform",
  "SHL": "Oyster Shell",
  "P2PS": "P2P Solutions Foundation",
  "GENE": "PARKGENE",
  "PAT": "PATRON",
  "PAXEX": "PAXEX",
  "PQT": "PAquarium",
  "PAI": "PCHAIN",
  "PGF7T": "PGF500",
  "PHI": "PHI Token",
  "PITCH": "PITCH",
  "PLNC": "PLNCoin",
  "PCH": "POPCHAIN",
  "PPOVR": "POVR",
  "TOSS": "PROOF OF TOSS",
  "PROUD": "PROUD Money",
  "PROOF": "PROVER",
  "PSI": "PSIcoin",
  "PVP": "PVPChain",
  "PWR": "PWR Coin",
  "PX": "PXcoin",
  "PCS": "Pabyosi Coin",
  "PBC": "PabyosiCoin",
  "PAC": "PacCoin",
  "PAK": "Pakcoin",
  "PLMT": "Pallium",
  "PND": "PandaCoin",
  "PINKX": "PantherCoin",
  "PAN": "Pantos",
  "PRT": "Papusha",
  "PRP": "Papyrus",
  "PRG": "Paragon",
  "DUO": "ParallelCoin",
  "PARA": "ParanoiaCoin",
  "PARETO": "Pareto Network Token",
  "PKB": "ParkByte",
  "PAR": "Parlay",
  "PART": "Particl",
  "PASC": "Pascal Coin",
  "PASL": "Pascal Lite",
  "PAS": "Passive Coin",
  "PTO": "Patentico",
  "PTOY": "Patientory",
  "PAVO": "Pavocoin",
  "PAX": "Paxos Standard",
  "PBLK": "PayBlock",
  "PYC": "PayCoin",
  "XPY": "PayCoin",
  "PFR": "PayFair",
  "PAYP": "PayPeer",
  "PPP": "PayPie",
  "PYP": "PayPro",
  "PYN": "Paycentos",
  "CON_": "Paycon",
  "PGC*": "Paygine",
  "PMNT": "Paymon",
  "PYT": "Payther",
  "PEC": "PeaceCoin",
  "PRLPAY": "PearlPay",
  "XPB": "Pebble Coin",
  "PBL": "Pebbles",
  "PCL": "Peculium",
  "PCO": "Pecunio",
  "PCN": "PeepCoin",
  "PMTN": "Peer Mountain",
  "PPC": "PeerCoin",
  "GUESS": "Peerguess",
  "PPY": "Peerplays",
  "PGC": "Pegascoin",
  "PEN*": "PenCoin",
  "PNT": "Penta",
  "PTA": "PentaCoin",
  "PNY": "Peony Coin",
  "MAN": "People",
  "MEME": "Pepe",
  "PEPECASH": "Pepe Cash",
  "XPR": "Permian",
  "PIE": "Persistent Information Exchange",
  "PERU": "PeruCoin",
  "PTC": "PesetaCoin",
  "PSB": "PesoBit",
  "PETL": "Petlife",
  "PTR": "Petro",
  "XPD": "PetroDollar",
  "PXL": "Phalanx",
  "SOUL*": "Phantasma",
  "PNX": "PhantomX",
  "XPH": "PharmaCoin",
  "PHS": "PhilosophersStone",
  "PXC": "PhoenixCoin",
  "PHM": "Phomeum",
  "PHR*": "Phore",
  "PHTC": "Photochain",
  "PHO": "Photon",
  "PHT": "Photon Token",
  "PHR": "Phreak",
  "PGN": "Pigeoncoin",
  "PIGGY": "Piggy Coin",
  "PKC": "Pikciochain",
  "PLR": "Pillar",
  "PTT": "Pink Taxi Token",
  "PINK": "PinkCoin",
  "PINMO": "Pinmo",
  "PCOIN": "Pioneer Coin",
  "PIO": "Pioneershares",
  "SKULL": "Pirate Blocks",
  "PIRATE": "PirateCash",
  "PIRL": "Pirl",
  "PIZZA": "PizzaCoin",
  "PLAI": "Plair",
  "PLAN": "Plancoin",
  "PLANET": "PlanetCoin",
  "PLNX": "Planumex",
  "XPT": "Plata",
  "PTNX": "Platin",
  "PLC*": "PlatinCoin",
  "PNC": "PlatiniumCoin",
  "XPTX": "PlatinumBAR",
  "LUC": "Play 2 Live",
  "PLA": "PlayChip",
  "PXG": "PlayGame",
  "PKT": "Playkey",
  "DN8": "Pldgr",
  "PLG": "Pledgecamp",
  "PLX": "PlexCoin",
  "PLURA": "PluraCoin",
  "PLC": "PlusCoin",
  "PLUS1": "PlusOneCoin",
  "GPPT": "Pluto Project Coin",
  "PTC**": "Plutocoin",
  "PLU": "Pluton",
  "PLTX": "PlutusX",
  "POE": "Po.et",
  "POS": "PoSToken",
  "POA": "Poa Network",
  "XPS": "PoisonIvyCoin",
  "XPOKE": "PokeChain",
  "POKER": "PokerCoin",
  "XPST": "PokerSports",
  "PAL": "PolicyPal Network",
  "POLIS": "PolisPay",
  "POLY": "PolyBit",
  "NCT": "PolySwarm",
  "PLBT": "Polybius",
  "POLY*": "Polymath Network",
  "PON": "Ponder",
  "PSK": "Pool of Stake",
  "XSP": "PoolStamp",
  "PPS": "PopulStay",
  "POP": "PopularCoin",
  "PPT": "Populous",
  "PEX": "PosEx",
  "PSD": "Poseidon",
  "PCCM": "Poseidon Chain",
  "OCEAN": "Poseidon Foundation",
  "POSQ": "Poseidon Quark",
  "POST": "PostCoin",
  "POT": "PotCoin",
  "POWR": "Power Ledger",
  "PSM": "Prasm",
  "PRE": "Premium",
  "ENTT": "Presale Ventures",
  "PRE*": "Presearch",
  "HILL": "President Clinton",
  "PRES": "President Trump",
  "PBT": "Primalbase",
  "PST": "Primas",
  "PSF": "Prime Shipping Foundation",
  "PXI": "Prime-X1",
  "PRIME": "PrimeChain",
  "XPM": "PrimeCoin",
  "PRX": "Printerium",
  "PRM": "PrismChain",
  "PIVX": "Private Instant Verified Transaction",
  "PRIX": "Privatix",
  "PZM": "Prizm",
  "PRA": "ProChain",
  "XPRO": "ProCoin",
  "PROC": "ProCurrency",
  "PCM": "Procom",
  "PROD*": "Productivist",
  "PHC": "Profit Hunters Coin",
  "PDC": "Project Decorum",
  "JTX": "Project J",
  "PAI*": "Project Pai",
  "OMX": "Project Shivom",
  "PRFT": "Proof Suite Token",
  "PROPS": "Props",
  "PTC*": "Propthereum",
  "PRO": "Propy",
  "VRP": "Prosense.tv",
  "PGL": "Prospectors",
  "PRC": "ProsperCoin",
  "PROTON": "Proton",
  "XES": "Proxeus",
  "XPX": "ProximaX",
  "PSEUD": "PseudoCash",
  "PSY": "Psilocybin",
  "PULSE": "Pulse",
  "PMA": "PumaPay",
  "NPXS": "Pundi X",
  "PUPA": "PupaCoin",
  "PURA": "Pura",
  "PURE": "Pure",
  "VIDZ": "PureVidz",
  "PGT": "Puregold token",
  "PURK": "Purk",
  "PRPL": "Purple Token",
  "PRPS": "Purpose",
  "HLP": "Purpose Coin",
  "PUSHI": "Pushi",
  "PUT": "PutinCoin",
  "PYLNT": "Pylon Network",
  "QLC": "QLC Chain",
  "QTUM": "QTUM",
  "QUSD": "QUSD",
  "QBT*": "Qbao",
  "QOBI": "Qobit",
  "QORA": "QoraCoin",
  "XQR": "Qredit",
  "QBK": "QuBuck Coin",
  "eQUAD": "Quadrant Protocol",
  "QNT": "Quant",
  "QNTU": "Quanta",
  "QUANT": "Quantler",
  "QNTR": "Quantor",
  "QSP": "Quantstamp",
  "QAU": "Quantum",
  "QRL": "Quantum Resistant Ledger",
  "Q1S": "Quantum1Net",
  "QKC": "QuarkChain",
  "QRK": "QuarkCoin",
  "QTZ": "Quartz",
  "QUA": "Quasa",
  "QTL": "Quatloo",
  "QCN": "Quazar Coin",
  "Q2C": "QubitCoin",
  "QBC": "Quebecoin",
  "QCX": "QuickX Protocol",
  "QSLV": "Quicksilver coin",
  "QUIZ": "Quizando",
  "QUN": "QunQun",
  "QASH": "Quoine Liquid",
  "XQN": "Quotient",
  "QVT": "Qvolta",
  "QWARK": "Qwark",
  "QWC": "Qwertycoin",
  "RFL": "RAFL",
  "RAIZER": "RAIZER",
  "KRX": "RAVN Korrax",
  "RAWG": "RAWG",
  "RAC": "RAcoin",
  "RHOC": "RChain",
  "RCN*": "RCoin",
  "REAL": "REAL",
  "REBL": "REBL",
  "MWAT": "RED MegaWatt",
  "RST": "REGA Risk Sharing Token",
  "REME": "REME-Coin",
  "REM": "REMME",
  "RENC": "RENC",
  "RGC": "RG Coin",
  "RIF": "RIF Token",
  "ROI": "ROIcoin",
  "ROS": "ROS Coin",
  "RFT": "RYFTS",
  "RADI": "RadicalCoin",
  "RADS": "Radium",
  "RDN": "RadonPay",
  "RDN*": "Raiden Network",
  "RF": "Raido Financial",
  "RAINC": "RainCheck",
  "RAP": "Rapture",
  "ROC": "Rasputin Online Coin",
  "RTE": "Rate3",
  "XRA": "Ratecoin",
  "RATIO": "Ratio",
  "RAVE": "Ravelous",
  "RVN": "Ravencoin",
  "RAYS": "Rays Network",
  "RZR": "RazorCoin",
  "RWE": "Real-World Evidence",
  "RCT": "RealChain",
  "REA": "Realisto",
  "RCC": "Reality Clash",
  "XRK": "RecordsKeeper",
  "RRT": "Recovery Right Tokens",
  "RRC": "Recycling Regeneration Chain",
  "PHX": "Red Pulse Phoenix",
  "REDC": "RedCab",
  "RCX": "RedCrowCoin",
  "RED": "Redcoin",
  "RDD": "Reddcoin",
  "REDN": "Reden",
  "REE": "ReeCoin",
  "REF": "RefToken",
  "RFR": "Refereum",
  "REC": "Regalcoin",
  "RDS": "Reger Diamond",
  "RLX": "Relex",
  "REL": "Reliance",
  "REMCO": "Remco",
  "RPM": "Render Payment",
  "RNDR": "Render Token",
  "RNS": "RenosCoin",
  "BERRY": "Rentberry",
  "REPO": "Repo Coin",
  "RPB": "Republia",
  "REN": "Republic Token",
  "REPUX": "Repux",
  "REQ": "Request Network",
  "RMS": "Resumeo Shares",
  "RGT": "Retail.Global",
  "RBIT": "ReturnBit",
  "RNC": "ReturnCoin",
  "R": "Revain",
  "REV": "Revenu",
  "RVR": "Revolution VR",
  "XRE": "RevolverCoin",
  "RWD": "Reward Vision",
  "RMOB": "RewardMob",
  "RHEA": "Rhea",
  "XRL": "Rialto.AI",
  "RBR": "Ribbit Rewards",
  "RICE": "RiceCoin",
  "RIDE": "Ride My Car",
  "RIC": "Riecoin",
  "RMESH": "RightMesh",
  "RBT": "Rimbit",
  "RING": "RingCoin",
  "RIPO": "RipOffCoin",
  "RIPAX": "RipaEx",
  "RCN": "Ripio",
  "RIPT": "RiptideCoin",
  "RBX": "RiptoBuX",
  "RISE": "Rise",
  "RVT": "Rivetz",
  "RAC**": "RoBET",
  "ROBET": "RoBet",
  "RBDT": "RoBust Defense Token",
  "PUT*": "Robin8 Profile Utility Token",
  "RAC*": "RoboAdvisorCoin",
  "ROX": "Robotina",
  "RKT": "Rock Token",
  "ROK": "Rockchain",
  "ROCK*": "RocketCoin",
  "RPC": "RonPaulCoin",
  "RSC": "Ronaldinho Soccer Coin",
  "ROOT": "RootCoin",
  "ROOTS": "RootProject",
  "RT2": "RotoCoin",
  "ROUND": "RoundCoin",
  "ROE": "Rover Coin",
  "RKC": "Royal Kingdom Coin",
  "RYC": "RoyalCoin",
  "ROYAL": "RoyalCoin",
  "RYCN": "RoyalCoin 2.0",
  "RBIES": "Rubies",
  "RUBY": "Rubius",
  "RUBIT": "Rublebit",
  "RBY": "RubyCoin",
  "RUFF": "Ruff",
  "RUPX": "Rupaya",
  "RUP": "Rupee",
  "RC": "Russiacoin",
  "RMC": "Russian Mining Coin",
  "RUST": "RustCoin",
  "RUSTBITS": "Rustbits",
  "RYO": "Ryo",
  "S8C": "S88 Coin",
  "SABR": "SABR Coin",
  "SGA": "SAGA",
  "SAR*": "SARCoin",
  "SLY": "SELFLLERY",
  "SGAT": "SGAT",
  "SGP": "SGPay",
  "XSH": "SHIELD",
  "SIDT": "SID Token",
  "SKYFT": "SKYFchain",
  "SMNX": "SMNX",
  "SSX": "SOMESING",
  "SNM": "SONM",
  "SXDT": "SPECTRE Dividend Token",
  "SXUT": "SPECTRE Utility Token",
  "SPICE": "SPiCE Venture Capital",
  "SRCOIN": "SRCoin",
  "SSV": "SSVCoin",
  "STAC": "STAC",
  "STACS": "STACS Token",
  "STRS": "STARS",
  "EURS": "STASIS EURS",
  "STEX": "STEX",
  "STK": "STK Token",
  "STS": "STRESScoin",
  "STRY": "STRYKZ",
  "SUQA": "SUQA",
  "SaTT": "SaTT",
  "HAVEN": "Safe Haven",
  "XSTC": "Safe Trade Coin",
  "SAFE": "SafeCoin",
  "SAFEX": "SafeExchangeCoin",
  "SFR": "SaffronCoin",
  "SAF": "Safinus",
  "SAGA": "SagaCoin",
  "SFU": "Saifu",
  "SKB*": "Sakura Bloom",
  "SKR": "Sakuracoin",
  "SAL": "SalPay",
  "SALT": "Salt Lending",
  "SLS": "SaluS",
  "SMSR": "Samsara Coin",
  "SND": "Sandcoin",
  "SAN": "Santiment",
  "SPN*": "Sapien Network",
  "XAI": "SapienceCoin",
  "XRF": "Sarf",
  "XRN": "Saronite",
  "SAT": "Satisfaction Token",
  "STV": "Sativa Coin",
  "MAD*": "SatoshiMadness",
  "SAT2": "Saturn2Coin",
  "STO": "Save The Ocean",
  "SANDG": "Save and Gain",
  "SWC": "Scanetchain Token",
  "ST": "Scienceroot",
  "SNcoin": "ScientificCoin",
  "SCOOBY": "Scooby coin",
  "SCORE": "Scorecoin",
  "SCOR": "Scorista",
  "SCR*": "Scorum",
  "SCOT": "Scotcoin",
  "SCRIBE": "Scribe Network",
  "SCRL": "Scroll",
  "DDD": "Scry.info",
  "SCRPT": "ScryptCoin",
  "SCT": "ScryptToken",
  "SRT": "Scrypto",
  "SEAL": "Seal Network",
  "SECI": "Seci",
  "SCRT": "SecretCoin",
  "SRC": "SecureCoin",
  "SEC": "SecureCryptoPayments",
  "SRXIO": "Securix",
  "SET": "Securosys",
  "SEEDS": "SeedShares",
  "SEELE": "Seele",
  "B2X": "SegWit2x",
  "SEL": "SelenCoin",
  "STOR": "Self Storage Coin",
  "KEY": "SelfKey",
  "SSC": "SelfSell",
  "SGO": "Selfie GO",
  "SEM": "Semux",
  "SDRN": "Senderon",
  "SNS": "Sense",
  "SENSE": "Sense Token",
  "SEN": "Sentaro",
  "EMOT": "Sentigraph.io",
  "SENT": "Sentinel",
  "SENC": "Sentinel Chain",
  "UPP": "Sentinel Protocol",
  "SNTVT": "Sentivate",
  "SEQ": "Sequence",
  "SERA": "Seraph",
  "SRNT": "Serenity",
  "SRV": "ServAdvisor",
  "SETH": "Sether",
  "SP": "Sex Pistols",
  "SXC": "SexCoin",
  "SHA": "Shacoin",
  "SHADE": "ShadeCoin",
  "SDC": "ShadowCash",
  "SHARD": "ShardCoin",
  "SS": "Sharder",
  "SSS": "ShareChain",
  "eSwitch": "ShareMeAll",
  "SHR": "ShareRing",
  "SAK": "SharkCoin",
  "SHKG": "SharkGate",
  "SHP*": "Sharpe Capital",
  "JEW": "Shekel",
  "SHLD": "ShieldCoin",
  "SHIFT": "Shift",
  "SH": "Shilling",
  "SHE": "Shine Chain",
  "SHIP": "ShipChain",
  "SHPT": "Shipit",
  "SHORTY": "ShortyCoin",
  "SHOW": "ShowCoin",
  "HAND": "ShowHand",
  "SHPING": "Shping Coin",
  "SHREK": "ShrekCoin",
  "SCH": "Sia Cash Coin",
  "SC": "Siacoin",
  "SIB": "SibCoin",
  "SGL": "Sigil",
  "SIG": "Signal",
  "SGN": "Signals Network",
  "SIGT": "Signatum",
  "SNTR": "Silent Notary",
  "SILKT": "SilkChain",
  "SILK": "SilkCoin",
  "OST": "Simple Token",
  "SPLB": "SimpleBank",
  "SIGU": "Singular",
  "SNGLS": "SingularDTV",
  "AGI": "SingularityNET",
  "SRN": "SirinLabs",
  "SKC": "Skeincoin",
  "SKI": "Skillchain",
  "SKIN": "Skincoin",
  "SKRP": "Skraps",
  "SKR*": "Skrilla Token",
  "SKM": "Skrumble Network",
  "SKB": "SkullBuzz",
  "SKYM": "SkyMap",
  "SKY": "Skycoin",
  "SLX": "Slate",
  "SLM": "SlimCoin",
  "SLING": "Sling Coin",
  "RBTC": "Smart Bitcoin",
  "SIFT": "Smart Investment Fund Token",
  "POD": "Smart League",
  "TASH": "Smart Trip Platform",
  "VALOR": "Smart Valor",
  "SMART*": "SmartBillions",
  "SMART": "SmartCash",
  "SMC": "SmartCoin",
  "SLST": "SmartLands",
  "SMT*": "SmartMesh",
  "SMLY": "SmileyCoin",
  "SMILO": "Smilo",
  "SMOKE": "Smoke",
  "SMF": "SmurfCoin",
  "SNPC": "SnapCoin",
  "SNIP": "SnipCoin",
  "SNOV": "Snovio",
  "XSG": "Snowgem",
  "ONG": "SoMee.Social",
  "SOAR": "Soarcoin",
  "SLT": "Social Lending Network",
  "SMAC": "Social Media Coin",
  "SMT": "Social Media Market",
  "SEND": "Social Send",
  "SOCC": "SocialCoin",
  "SG": "SocialGood",
  "SREUR": "SocialRemit",
  "XBOT": "SocialXbotCoin",
  "SCL": "Sociall",
  "SOIL": "SoilCoin",
  "SOJ": "Sojourn Coin",
  "SOL": "Sola",
  "SDAO": "Solar DAO",
  "SLR": "SolarCoin",
  "CELL": "SolarFarm",
  "SRX": "Solarex",
  "SFC": "Solarflarecoin",
  "XLR": "Solaris",
  "SOLE": "SoleCoin",
  "SOLID": "Solidified",
  "SCT*": "Soma",
  "SONG": "Song Coin",
  "SSD": "Sonic Screw Driver Coin",
  "SOON": "SoonCoin",
  "SPHTX": "SophiaTX",
  "SNK": "Sosnovkino",
  "SOUL": "SoulCoin",
  "SPX": "Sp8de",
  "SCASH": "SpaceCash",
  "SPC*": "SpaceChain",
  "SPACE": "SpaceCoin",
  "SPA": "SpainCoin",
  "SPANK": "SpankChain",
  "SPK": "SparksPay",
  "SPEC": "SpecCoin",
  "SPX*": "Specie",
  "XSPEC": "Spectre",
  "SPEND": "Spend",
  "SPHR": "Sphere Coin",
  "XID": "Sphre AIR",
  "SPIKE": "Spiking",
  "SPC": "SpinCoin",
  "SPD*": "Spindle",
  "SPKZ": "Spokkz",
  "SPORT": "SportsCoin",
  "SFT": "SportsFix",
  "SPF": "SportyCo",
  "SPOT": "Spotcoin",
  "SPT": "Spots",
  "SPOTS": "Spots",
  "SPR": "Spreadcoin",
  "SPRTZ": "SpritzCoin",
  "SPRTS": "Sprouts",
  "SQP": "SqPay",
  "SQL": "Squall Coin",
  "SQR": "Squeezer",
  "XSI": "Stability Shares",
  "SBC": "StableCoin",
  "USDS": "StableUSD",
  "DSLA": "Stacktical",
  "STCN": "Stakecoin",
  "XSN": "Stakenet",
  "STA*": "Stakers",
  "STHR": "Stakerush",
  "LABX": "Stakinglab",
  "STALIN": "StalinCoin",
  "STC": "StarChain",
  "STR*": "StarCoin",
  "STAR*": "StarCoin",
  "SRC*": "StarCredits",
  "KST": "StarKST",
  "STT": "Staramba",
  "STAR": "Starbase",
  "START": "StartCoin",
  "STA": "Starta",
  "STP": "StashPay",
  "SQOIN": "StasyQ",
  "SNT": "Status Network Token",
  "STAX": "Staxcoin",
  "XST": "StealthCoin",
  "PNK": "SteamPunk",
  "STEEM": "Steem",
  "SBD*": "Steem Backed Dollars",
  "XLM": "Stellar",
  "XTL": "Stellite",
  "SCIA": "Stem Cell",
  "STN": "Steneum Coin",
  "STEPS": "Steps",
  "SLG": "SterlingCoin",
  "SPD": "Stipend",
  "STIPS": "Stips",
  "STOCKBET": "StockBet",
  "SCC": "StockChain Coin",
  "STQ": "Storiqa Token",
  "STORJ": "Storj",
  "SJCX": "StorjCoin",
  "STORM": "Storm",
  "STX": "Stox",
  "STAK": "Straks",
  "SISA": "Strategic Investments in Significant Areas",
  "STRAT": "Stratis",
  "SSH": "StreamSpace",
  "STM": "Streamity",
  "DATA": "Streamr DATAcoin",
  "SHND": "StrongHands",
  "SUT": "Suapp",
  "SUB*": "Subscriptio",
  "SUB": "Substratum Network",
  "SUCR": "Sucre",
  "SGC": "Sudan Gold Coin",
  "SGR": "Sugar Exchange",
  "SUMO": "Sumokoin",
  "SNC": "SunContract",
  "SSTC": "SunShotCoin",
  "SUP": "Supcoin",
  "SBTC": "Super Bitcoin",
  "SUPER": "SuperCoin",
  "UNITY": "SuperNET",
  "SEED": "Superbloom",
  "M1": "SupplyShock",
  "SPM": "Supreme",
  "RMT": "SureRemit",
  "SUR": "Suretly",
  "SWA": "Swace",
  "SWACH": "Swachhcoin",
  "BUCKS": "SwagBucks",
  "SWT": "Swarm City Token",
  "SWM": "Swarm Fund",
  "SWARM": "SwarmCoin",
  "SWEET": "SweetStake",
  "SWFTC": "SwftCoin",
  "SWING": "SwingCoin",
  "SCN": "Swiscoin",
  "CHSB": "SwissBorg",
  "SRC**": "SwissRealCoin",
  "SIC": "Swisscoin",
  "SWTH": "Switcheo",
  "SDP": "SydPakCoin",
  "SYLO": "Sylo",
  "SYNC": "SyncCoin",
  "MFG": "SyncFab",
  "SYC": "SynchroCoin",
  "SYNCO": "Synco",
  "SYNX": "Syndicate",
  "AMP": "Synereo",
  "SNRG": "Synergy",
  "SNX": "Synthetix",
  "SYS": "SysCoin",
  "TBT": "T-BOT",
  "TCX": "T-Coin",
  "TZO": "TANZO",
  "BAR": "TBIS token",
  "TDFB": "TDFB",
  "TFD": "TE-FOOD",
  "TKY": "THEKEY Token",
  "TTN": "TITA Project",
  "TXM": "TMONEY",
  "TOA": "TOA Coin",
  "TPC": "TPCash",
  "TRX": "TRON",
  "XTROPTIONS": "TROPTIONS",
  "TTV": "TV-TWO",
  "TWISTR": "TWIST",
  "TTU": "TaTaTu",
  "TCHN": "Tachain",
  "TAG": "TagCoin",
  "TAJ": "TajCoin",
  "TAK": "TakCoin",
  "TKLN": "Taklimakan",
  "TALAO": "Talao",
  "TLNT": "Talent Token",
  "TCOIN": "Talenthon",
  "TAL": "Talentico",
  "TAM": "TamaGucci",
  "XTO": "Tao",
  "TTT": "Tap Project",
  "TAP": "TappingCoin",
  "TGT": "TargetCoin",
  "TAT": "Tatiana Coin",
  "TSE": "TattooCoin",
  "TEC": "TeCoin",
  "TCHB": "Teachers Blockchain",
  "TEAM": "TeamUP",
  "TECH": "TechCoin",
  "THS": "TechShares",
  "TEK": "TekCoin",
  "TEL": "Telcoin",
  "GRAM": "Telegram Open Network",
  "TELL": "Tellurion",
  "PAY": "TenX",
  "TENNET": "Tennet",
  "TENZ": "Tenzorum",
  "LED": "Terawatt",
  "TERN": "Ternio",
  "TRN": "Ternion",
  "TVA": "Terra Virtua",
  "TRC": "TerraCoin",
  "TECO": "TerraEcoCoin",
  "TGN": "TerraGreen",
  "TER": "TerraNovaCoin",
  "TESLA": "TeslaCoilCoin",
  "TES": "TeslaCoin",
  "USDT": "Tether",
  "TRA": "Tetra",
  "XTZ": "Tezos",
  "THNX": "ThankYou",
  "0xDIARY": "The 0xDiary Token",
  "ABYSS": "The Abyss",
  "EFX": "The EFFECT Network",
  "TFC": "The Freedom Coin",
  "GOVT": "The Government Network",
  "THC": "The Hempcoin",
  "SUNEX": "The Sun Exchange",
  "XVE": "The Vegan Initiative",
  "CHIEF": "TheChiefCoin",
  "GCC*": "TheGCCcoin",
  "VIG": "TheVig",
  "TCR": "Thecreed",
  "MAY": "Theresa May Coin",
  "THETA": "Theta",
  "TAGR": "Think And Get Rich Coin",
  "THRT": "ThriveToken",
  "TSC": "ThunderStake",
  "TIA": "Tianhe",
  "TBRS": "Tiberius",
  "TDX": "Tidex Token",
  "TNT": "Tierion",
  "TIE": "Ties Network",
  "TCH": "TigerCash",
  "TGC": "TigerCoin",
  "TIG": "Tigereum",
  "XTC": "TileCoin",
  "BILL": "TillBilly",
  "TIME": "Time",
  "TNB": "Time New Bank",
  "TME": "Timereum",
  "TMC": "TimesCoin",
  "TIMI": "Timicoin",
  "TIO*": "Tio Tour Guides",
  "TIP": "Tip Blockchain",
  "TTC": "TitCoin",
  "TITAN": "Titan",
  "TBAR": "Titanium BAR",
  "TIT": "TittieCoin",
  "TMT*": "ToTheMoon",
  "TODAY": "TodayCoin",
  "TKD": "Tokedo",
  "TAAS": "Token as a Service",
  "TKN": "TokenCard",
  "TCT": "TokenClub",
  "TDS": "TokenDesk",
  "TPAY*": "TokenPay",
  "ACE": "TokenStars",
  "TEAMT": "TokenStars TEAM Token",
  "AIRE": "Tokenaire",
  "TBX": "Tokenbox",
  "TEN": "Tokenomy",
  "TGTC": "Tokensgate",
  "TKS": "Tokes",
  "TKA": "Tokia",
  "TOK": "TokugawaCoin",
  "TOKC": "Tokyo Coin",
  "TOM": "Tomahawkcoin",
  "TBL": "Tombola",
  "TOMO": "TomoChain",
  "TOPC": "Topchain",
  "TOR": "TorCoin",
  "TOT": "TotCoin",
  "TRET": "Tourist Review",
  "BBC": "TraDove B2BCoin",
  "MTN": "TrackNetToken",
  "TRCT": "Tracto",
  "TXP": "Trade Pharma Network",
  "TIOX": "Trade Token X",
  "TIO": "Trade.io",
  "EXTP": "TradePlace",
  "TDZ": "Tradelize",
  "TRAID": "Traid",
  "TRAK": "TrakInvest",
  "TX": "Transfer",
  "TBCX": "TrashBurn",
  "AVALA": "Travala",
  "TRV": "Travel Coin",
  "TT": "TravelChain",
  "TLT": "Travelertoken",
  "TRF": "Travelflex",
  "TRAVEL": "Travelvee",
  "TMT**": "Traxia Membership Token",
  "TOT*": "Trecento Blockchain Capital",
  "TREX": "TreeBlock",
  "TZC": "TrezarCoin",
  "FORCE": "TriForce Tokens",
  "TRIA": "Triaconta",
  "TRI": "Triangles Coin",
  "TRIBE": "TribeToken",
  "TRICK": "TrickyCoin",
  "TRDT": "Trident",
  "GPS": "Triffic",
  "ID": "TrigID",
  "TRIG": "Trigger",
  "TIIM": "TriipMiles",
  "TNC": "Trinity Network Credit",
  "TRIO": "Tripio",
  "TRIP": "Trippki",
  "TRVC": "Trivecoin",
  "TRVR": "Trivver",
  "TRW": "Triwer",
  "TPG": "Troll Payment",
  "TKN*": "TrollTokens",
  "TROLL": "Trollcoin",
  "TRK": "TruckCoin",
  "TRCK": "Truckcoin",
  "TRUE": "True Chain",
  "TFL": "True Flip Lottery",
  "TUSD": "True USD",
  "TDP": "TrueDeck",
  "TGAME": "TrueGame",
  "TIC": "TrueInvestmentCoin",
  "TRUMP": "TrumpCoin",
  "TRST": "TrustCoin",
  "TRUST": "TrustPlus",
  "TTB": "TrustaBit",
  "FLEX": "TrustedCars FLEX",
  "WHO": "Truwho",
  "TYM": "Tryvium",
  "TLP": "TulipCoin",
  "TUR": "Turron",
  "TRTL": "TurtleCoin",
  "TUT": "Tutellus",
  "TRT": "TuurnT",
  "TWLV": "Twelve Coin",
  "TWC": "Twilight",
  "TWIST": "TwisterCoin",
  "UUU": "U Network",
  "UCASH": "U.CASH",
  "UCN": "UC Coin",
  "UCOINT": "UCOIN",
  "UCT": "UCOT",
  "UFO": "UFO Coin",
  "HVE": "UHIVE",
  "UMK": "UMKA",
  "UNX": "UNEOX",
  "XUP": "UPcoin",
  "UR": "UR",
  "URX": "URANIUMX",
  "USAT": "USAT",
  "USCOIN": "USCoin",
  "USDC": "USD Coin",
  "USDCT": "USDCT",
  "USOAMIC": "USOAMIC",
  "UBC": "Ubcoin",
  "UBEX": "Ubex",
  "UBQ": "Ubiq",
  "UBIQ": "Ubiqoin",
  "U": "Ucoin",
  "USC": "Ultimate Secure Cash",
  "UTC": "UltraCoin",
  "XUN": "UltraNote",
  "ULTC": "Umbrella",
  "UMC": "Umbrella Coin",
  "UNC": "UnCoin",
  "UNAT": "Unattanium",
  "NBOX": "Unboxed",
  "UNB": "UnbreakableCoin",
  "UNF": "Unfed Coin",
  "UBT": "UniBright",
  "CANDY": "UnicornGo Candy",
  "USX": "Unified Society USDEX",
  "UNIFY": "Unify",
  "UKG": "UnikoinGold",
  "UNIQ": "Uniqredit",
  "USDE": "UnitaryStatus Dollar",
  "UAEC": "United Arab Emirates Coin",
  "UEC": "United Emirates Coin",
  "UTT": "United Traders Token",
  "UBTC": "UnitedBitcoin",
  "GOALS": "UnitedFans",
  "UIS": "Unitus",
  "UTNP": "Universa",
  "UNIT": "Universal Currency",
  "UMO": "Universal Molecule",
  "URT": "Universal Recognition Token",
  "URP": "Universal Reward Protocol",
  "UNRC": "UniversalRoyalCoin",
  "UNI": "Universe",
  "UNO": "Unobtanium",
  "UP": "UpToken",
  "UFR": "Upfiring",
  "UQC": "Uquid Coin",
  "URALS": "Urals Coin",
  "URB": "Urbit Data",
  "URO": "UroCoin",
  "USE": "Usechain Token",
  "UETL": "Useless Eth Token Lite",
  "UET": "Useless Ethereum Token",
  "UTH": "Uther",
  "UTL": "Utile Network",
  "UTIL": "Utility Coin",
  "OOT": "Utrum",
  "UTK": "Utrust",
  "UWC": "Uwezocoin",
  "VIDT": "V-ID",
  "VANIG": "VANIG",
  "VANM": "VANM",
  "VAR": "VARcrypt",
  "VEGA": "VEGA",
  "VNTY": "VENOTY",
  "VRX Token": "VIARIUM",
  "VIBE": "VIBEHub",
  "VIP": "VIP Tokens",
  "VITE": "VITE",
  "VIVO": "VIVO Coin",
  "VLUX": "VLUX",
  "VTOS": "VTOS",
  "VTUUR": "VTUUR",
  "VTRD": "VTradeExchange",
  "VVI": "VV Coin",
  "VLD": "Valid",
  "VALID": "Validator Token",
  "VAL": "Valorbit",
  "VLR": "Valorem",
  "VANY": "Vanywhere",
  "VPRC": "VapersCoin",
  "VAPOR": "Vaporcoin",
  "VAD": "Varanida",
  "VLTC": "VaultCoin",
  "XVC": "Vcash",
  "VTHO": "VeChainThor",
  "VC": "Vecap",
  "VET": "Vechain",
  "VEC2": "VectorCoin 2.0",
  "VLX": "Velox",
  "VLT": "Veltor",
  "VENA": "Vena Network",
  "VNS": "Venus",
  "VENUS": "VenusEnergy",
  "VRA": "Verasity",
  "VNT": "Veredictum",
  "XVG": "Verge",
  "VRC": "VeriCoin",
  "VME": "VeriME",
  "VRF": "Verifier",
  "SPY": "Verifier",
  "CRED": "Verify",
  "VERI": "Veritaseum",
  "VRTY": "Verity",
  "VRM": "Verium",
  "VRN": "Vernam",
  "VRS": "Veros",
  "VERSA": "Versa Token",
  "VTC": "Vertcoin",
  "VTX": "Vertex",
  "VTEX": "Vertex",
  "VTL": "Vertical",
  "VEST": "VestChain",
  "VST": "Vestarin",
  "VEX": "Vexanium",
  "VZT": "Vezt",
  "VIA": "ViaCoin",
  "VIAZ": "Viaz",
  "VIB": "Viberate",
  "VIT": "Vice Industry Token",
  "VTM": "Victorieum",
  "VTY": "Victoriouscoin",
  "VIC": "Victorium",
  "VID": "VideoCoin",
  "VDO": "VidioCoin",
  "VIDI": "Vidion",
  "VIDY": "Vidy",
  "VIEW": "Viewly",
  "VEOT": "Viewo",
  "VIN": "VinChain",
  "VIOR": "ViorCoin",
  "IDORU": "Vip2Fan",
  "VIRAL": "Viral Coin",
  "VUC": "Virta Unique Coin",
  "VTA": "VirtaCoin",
  "XVP": "VirtacoinPlus",
  "VRT": "Virtual Reality Technology",
  "VRH": "Virtual Rehab",
  "VMC": "VirtualMining Coin",
  "VISIO": "Visio",
  "VNX": "VisionX",
  "VITAE": "Vitae",
  "VIU": "Viuly",
  "OGO": "VogoV",
  "VOISE": "Voise",
  "VOL": "VolAir",
  "VLTX": "Volentix",
  "VLP": "Volpo",
  "VTN": "Voltroon",
  "VOOT": "VootCoin",
  "VOT": "Votecoin",
  "VOYA": "Voyacoin",
  "VSX": "Vsync",
  "VTR": "Vtorrent",
  "VULC": "Vulcano",
  "W12": "W12 Protocol",
  "W3C": "W3Coin",
  "WAB": "WABnetwork",
  "WIN": "WCoin",
  "WETH": "WETH",
  "WRL": "WHIRL",
  "WMC": "WMCoin",
  "WOM": "WOM",
  "WOWX": "WOWX",
  "WRT": "WRTcoin",
  "WTXH": "WTX HUB",
  "WU": "WULET",
  "WABI": "WaBi",
  "WGR": "Wagerr",
  "WTC": "Waltonchain",
  "WAN": "Wanchain",
  "WAND": "WandX",
  "WRC*": "WarCoin",
  "WARP": "WarpCoin",
  "WASH": "WashingtonCoin",
  "WUG": "WatchUGot",
  "WMB": "WatermelonBlock",
  "WAVES": "Waves",
  "WCT": "Waves Community Token",
  "WGO": "WavesGO",
  "WNET": "Wavesnode.net",
  "WAY": "WayCoin",
  "WSX": "WeAreSatoshi",
  "WBY": "WeBuy",
  "WPR": "WePower",
  "WT": "WeToken",
  "WEALTH": "WealthCoin",
  "WVR": "Weave",
  "WEB*": "Webchain",
  "WEB": "Webcoin",
  "WDX": "WeiDex",
  "WELL": "Well",
  "WLME": "Wellmee",
  "WTL": "Welltrado",
  "WMK": "Wemark",
  "WEX": "Wexcoin",
  "WHL": "WhaleCoin",
  "AWT": "WhatsOnPic",
  "WHEN": "WhenHub",
  "WC": "WhiteCoin",
  "XWC": "WhiteCoin",
  "WIC": "Wi Coin",
  "WIIX": "Wiix",
  "WBB": "Wild Beast Coin",
  "WILD": "Wild Crypto",
  "WINS": "WinStars",
  "WHN": "Windhan Energy",
  "LIF": "Winding Tree",
  "WINE": "WineCoin",
  "WINGS": "Wings DAO",
  "WINK": "Wink",
  "WISC": "WisdomCoin",
  "WSC": "WiserCoin",
  "WSH": "Wish Finance",
  "WISH*": "WishFinance",
  "WIT": "Witcoin",
  "WLK": "Wolk",
  "WOMEN": "WomenCoin",
  "LOG": "Wood Coin",
  "WBBC": "World Bit Bank",
  "WCG": "World Crypto Gold",
  "WGC": "World Gold Coin",
  "XWT": "World Trade Funds",
  "WOBTC": "WorldBTC",
  "WDC": "WorldCoin",
  "WOP": "WorldPay",
  "WRC": "Worldcore",
  "WPT": "Worldopoly",
  "WAX": "Worldwide Asset eXchange",
  "WBTC": "Wrapped Bitcoin",
  "WYR": "Wyrify",
  "WYS": "Wysker",
  "XRED": "X Real Estate Development",
  "XCASH": "X-CASH",
  "XC": "X11 Coin",
  "X2": "X2Coin",
  "X8X": "X8Currency",
  "CHI": "XAYA",
  "XCZ": "XCOYNZ",
  "XCO": "XCoin",
  "XDE2": "XDE II",
  "XDNA": "XDNA",
  "XELS": "XELS Coin",
  "XTN": "XEND token",
  "XG": "XG Sports",
  "XMX": "XMax",
  "XOV": "XOVBank",
  "XRP": "XRP",
  "XBY": "XTRABYTES",
  "XUEZ": "XUEZ",
  "XXX": "XXXCoin",
  "XYO": "XY Oracle",
  "XNX": "XanaxCoin",
  "XAU": "XauCoin",
  "XAUR": "Xaurum",
  "XCSH": "Xcash",
  "XCEL": "XcelTrip",
  "XCG": "Xchange",
  "XNC": "XenCoin",
  "XEN": "XenixCoin",
  "XNN": "Xenon",
  "XNB": "Xeonbit",
  "MI": "XiaoMiCoin",
  "XDCE": "XinFin Coin",
  "XIOS": "Xios",
  "XT3": "Xt3ch",
  "XRBT": "Xtribe",
  "YAY": "YAYcoin",
  "YAC": "YAcCoin",
  "YACHTCO": "Yachtco",
  "YMC": "YamahaCoin",
  "YMZ": "Yamzu",
  "YBC": "YbCoin",
  "YDY": "Ydentity",
  "YEE": "Yee",
  "YBT": "YellowBetter",
  "YES": "YesCoin",
  "YOC": "YoCoin",
  "YOVI": "YobitVirtualCoin",
  "YON": "YondoCoin",
  "YSH": "Yoshi",
  "U42": "You42",
  "YOYOW": "Yoyow",
  "YUM": "Yumerium",
  "Z2": "Z2 Coin",
  "ZAB": "ZABERcoin",
  "ZAZA": "ZAZA",
  "ZT": "ZB Global",
  "ZCC": "ZCC Coin",
  "ZEC": "ZCash",
  "ZECD": "ZCashDarkCoin",
  "ZCG": "ZCashGOLD",
  "ZCL": "ZClassic",
  "XZC": "ZCoin",
  "ZEN": "ZEN",
  "ZEPH": "ZEPHYR",
  "ZINC": "ZINC",
  "ZIX": "ZIX Token",
  "ZLQ": "ZLiteQubit",
  "ZMN": "ZMINE",
  "ZNAQ": "ZNAQ",
  "ZPR": "ZPER",
  "ZSE": "ZSEcoin",
  "ZEX": "Zaddex",
  "ZAP": "Zap",
  "ZAT": "ZatGo",
  "ZYD": "ZayedCoin",
  "ZXT": "Zcrypt",
  "NZL": "Zealium",
  "ZCO": "Zebi Coin",
  "ZED": "ZedCoins",
  "ZPT": "Zeepin",
  "ZEEW": "Zeew",
  "ZEIT": "ZeitCoin",
  "ZEL": "Zelcash",
  "ZP": "Zen Protocol",
  "ZND": "Zenad",
  "ZENI": "Zennies",
  "ZNA": "Zenome",
  "ZER": "Zero",
  "ZCC1": "ZeroCarbon",
  "ZSC*": "ZeroState",
  "ZEST": "ZestCoin",
  "ZET2": "Zeta2Coin",
  "ZET": "ZetaCoin",
  "ZSC": "Zeusshield",
  "ZUC": "Zeux",
  "ZCN*": "Zichain",
  "ZBC": "Zilbercoin",
  "ZLA": "Zilla",
  "ZIL": "Zilliqa",
  "ZIP": "Zipper",
  "ZIPT": "Zippie",
  "ZOI": "Zoin",
  "ZNE": "ZoneCoin",
  "ZOOM": "ZoomCoin",
  "ZRC": "ZrCoin",
  "ZUP": "Zupply Token",
  "ZUR": "Zurcoin",
  "ZUUM": "Zuum",
  "AQU": "aQuest",
  "AXPR": "aXpire",
  "ELF": "aelf",
  "AXC": "autoXchange",
  "BPN": "beepnow",
  "OX": "betbox",
  "BITCNY": "bitCNY",
  "BITGOLD": "bitGold",
  "BITSILVER": "bitSilver",
  "BITUSD": "bitUSD",
  "CSQ": "cosquare",
  "DCS": "deCLOUDs",
  "DNT": "district0x",
  "ECHT": "e-Chat",
  "EBIT": "eBit",
  "EBTC": "eBitcoin",
  "EBST": "eBoost",
  "ELTC2": "eLTC",
  "LYQD": "eLYQD",
  "DEM": "eMark",
  "EMU": "eMusic",
  "ePRX": "eProxy",
  "EREAL": "eREAL",
  "EMPR": "empowr",
  "BLACK": "eosBLACK",
  "EOSDAC": "eosDAC",
  "XEP": "ephelants360",
  "FDX": "fidentiaX",
  "GCN": "gCn Coin",
  "FFUEL": "getFIFO",
  "HBE": "healthbank",
  "ICHN": "i-chain",
  "IBANK": "iBankCoin",
  "DEAL": "iDealCash",
  "ICE": "iDice",
  "IETH": "iEthereum",
  "RLC": "iEx.ec",
  "ILT": "iOlite",
  "ITU": "iTrue",
  "IW": "iWallet",
  "IXT": "iXledger",
  "IMU": "imusify",
  "ITM": "intimate.io",
  "MCN": "mCoin",
  "MVU": "meVu",
  "MIBO": "miBoodle",
  "MOOLYA": "moolyacoin",
  "NOS": "nOS",
  "redBUX": "redBUX",
  "SUSD": "sUSD",
  "SVD": "savedroid",
  "SBA": "simplyBrand",
  "UFT": "ufoodo",
  "UGC": "ugChain",
  "VSL": "vSlice",
  "VTAG": "veriTAG Token",
  "WBTC*": "wBTC",
  "OPET": "ï¿½petFoundation",
  "AED": "United Arab Emirates Dirham",
  "AFN": "Afghan Afghani",
  "ALL": "Albanian Lek",
  "AMD": "Armenian Dram",
  "ANG": "Netherlands Antillean Guilder",
  "AOA": "Angolan Kwanza",
  "ARS": "Argentine Peso",
  "AUD": "Australian Dollar",
  "AWG": "Aruban Florin",
  "AZN": "Azerbaijani Manat",
  "BAM": "Bosnia-Herzegovina Convertible Mark",
  "BBD": "Barbadian Dollar",
  "BDT": "Bangladeshi Taka",
  "BGN": "Bulgarian Lev",
  "BHD": "Bahraini Dinar",
  "BIF": "Burundian Franc",
  "BMD": "Bermudan Dollar",
  "BND": "Brunei Dollar",
  "BOB": "Bolivian Boliviano",
  "BRL": "Brazilian Real",
  "BSD": "Bahamian Dollar",
  "BTC": "Bitcoin",
  "BTN": "Bhutanese Ngultrum",
  "BTS": "BitShares",
  "BWP": "Botswanan Pula",
  "BYN": "Belarusian Ruble",
  "BZD": "Belize Dollar",
  "CAD": "Canadian Dollar",
  "CDF": "Congolese Franc",
  "CHF": "Swiss Franc",
  "CLF": "Chilean Unit of Account (UF)",
  "CLP": "Chilean Peso",
  "CNH": "Chinese Yuan (Offshore)",
  "CNY": "Chinese Yuan",
  "COP": "Colombian Peso",
  "CRC": "Costa Rican Colï¿½n",
  "CUC": "Cuban Convertible Peso",
  "CUP": "Cuban Peso",
  "CVE": "Cape Verdean Escudo",
  "CZK": "Czech Republic Koruna",
  "DASH": "Dash",
  "DJF": "Djiboutian Franc",
  "DKK": "Danish Krone",
  "DOP": "Dominican Peso",
  "DZD": "Algerian Dinar",
  "EAC": "EarthCoin",
  "EGP": "Egyptian Pound",
  "EMC": "Emercoin",
  "ERN": "Eritrean Nakfa",
  "ETB": "Ethiopian Birr",
  "ETH": "Ethereum",
  "EUR": "Euro",
  "FCT": "Factom",
  "FJD": "Fijian Dollar",
  "FKP": "Falkland Islands Pound",
  "FTC": "Feathercoin",
  "GBP": "British Pound Sterling",
  "GEL": "Georgian Lari",
  "GGP": "Guernsey Pound",
  "GHS": "Ghanaian Cedi",
  "GIP": "Gibraltar Pound",
  "GMD": "Gambian Dalasi",
  "GNF": "Guinean Franc",
  "GTQ": "Guatemalan Quetzal",
  "GYD": "Guyanaese Dollar",
  "HKD": "Hong Kong Dollar",
  "HNL": "Honduran Lempira",
  "HRK": "Croatian Kuna",
  "HTG": "Haitian Gourde",
  "HUF": "Hungarian Forint",
  "IDR": "Indonesian Rupiah",
  "ILS": "Israeli New Sheqel",
  "IMP": "Manx pound",
  "INR": "Indian Rupee",
  "IQD": "Iraqi Dinar",
  "IRR": "Iranian Rial",
  "ISK": "Icelandic Krï¿½na",
  "JEP": "Jersey Pound",
  "JMD": "Jamaican Dollar",
  "JOD": "Jordanian Dinar",
  "JPY": "Japanese Yen",
  "KES": "Kenyan Shilling",
  "KGS": "Kyrgystani Som",
  "KHR": "Cambodian Riel",
  "KMF": "Comorian Franc",
  "KPW": "North Korean Won",
  "KRW": "South Korean Won",
  "KWD": "Kuwaiti Dinar",
  "KYD": "Cayman Islands Dollar",
  "KZT": "Kazakhstani Tenge",
  "LAK": "Laotian Kip",
  "LBP": "Lebanese Pound",
  "LD": "Linden Dollar",
  "LKR": "Sri Lankan Rupee",
  "LRD": "Liberian Dollar",
  "LSL": "Lesotho Loti",
  "LTC": "LiteCoin",
  "LYD": "Libyan Dinar",
  "MAD": "Moroccan Dirham",
  "MDL": "Moldovan Leu",
  "MGA": "Malagasy Ariary",
  "MKD": "Macedonian Denar",
  "MMK": "Myanma Kyat",
  "MNT": "Mongolian Tugrik",
  "MOP": "Macanese Pataca",
  "MRU": "Mauritanian Ouguiya",
  "MUR": "Mauritian Rupee",
  "MVR": "Maldivian Rufiyaa",
  "MWK": "Malawian Kwacha",
  "MXN": "Mexican Peso",
  "MYR": "Malaysian Ringgit",
  "MZN": "Mozambican Metical",
  "NAD": "Namibian Dollar",
  "NGN": "Nigerian Naira",
  "NIO": "Nicaraguan Cï¿½rdoba",
  "NMC": "Namecoin",
  "NOK": "Norwegian Krone",
  "NPR": "Nepalese Rupee",
  "NVC": "NovaCoin",
  "NXT": "Nxt",
  "NZD": "New Zealand Dollar",
  "OMR": "Omani Rial",
  "PAB": "Panamanian Balboa",
  "PEN": "Peruvian Nuevo Sol",
  "PGK": "Papua New Guinean Kina",
  "PHP": "Philippine Peso",
  "PKR": "Pakistani Rupee",
  "PLN": "Polish Zloty",
  "PPC": "Peercoin",
  "PYG": "Paraguayan Guarani",
  "QAR": "Qatari Rial",
  "RON": "Romanian Leu",
  "RSD": "Serbian Dinar",
  "RUB": "Russian Ruble",
  "RWF": "Rwandan Franc",
  "SAR": "Saudi Riyal",
  "SBD": "Solomon Islands Dollar",
  "SCR": "Seychellois Rupee",
  "SDG": "Sudanese Pound",
  "SEK": "Swedish Krona",
  "SGD": "Singapore Dollar",
  "SHP": "Saint Helena Pound",
  "SLL": "Sierra Leonean Leone",
  "SOS": "Somali Shilling",
  "SRD": "Surinamese Dollar",
  "SSP": "South Sudanese Pound",
  "STD": "Sï¿½o Tomï¿½ and Prï¿½ncipe Dobra (pre-2018)",
  "STN": "Sï¿½o Tomï¿½ and Prï¿½ncipe Dobra",
  "STR": "Stellar",
  "SVC": "Salvadoran Colï¿½n",
  "SYP": "Syrian Pound",
  "SZL": "Swazi Lilangeni",
  "THB": "Thai Baht",
  "TJS": "Tajikistani Somoni",
  "TMT": "Turkmenistani Manat",
  "TND": "Tunisian Dinar",
  "TOP": "Tongan Pa'anga",
  "TRY": "Turkish Lira",
  "TTD": "Trinidad and Tobago Dollar",
  "TWD": "New Taiwan Dollar",
  "TZS": "Tanzanian Shilling",
  "UAH": "Ukrainian Hryvnia",
  "UGX": "Ugandan Shilling",
  "USD": "United States Dollar",
  "UYU": "Uruguayan Peso",
  "UZS": "Uzbekistan Som",
  "VEF": "Venezuelan Bolï¿½var Fuerte (Old)",
  "VEF_BLKMKT": "Venezuelan Bolï¿½var (Black Market)",
  "VEF_DICOM": "Venezuelan Bolï¿½var (DICOM)",
  "VEF_DIPRO": "Venezuelan Bolï¿½var (DIPRO)",
  "VES": "Venezuelan Bolï¿½var Soberano",
  "VND": "Vietnamese Dong",
  "VTC": "VertCoin",
  "VUV": "Vanuatu Vatu",
  "WST": "Samoan Tala",
  "XAF": "CFA Franc BEAC",
  "XAG": "Silver Ounce",
  "XAU": "Gold Ounce",
  "XCD": "East Caribbean Dollar",
  "XDR": "Special Drawing Rights",
  "XMR": "Monero",
  "XOF": "CFA Franc BCEAO",
  "XPD": "Palladium Ounce",
  "XPF": "CFP Franc",
  "XPM": "Primecoin",
  "XPT": "Platinum Ounce",
  "XRP": "Ripple",
  "YER": "Yemeni Rial",
  "ZAR": "South African Rand",
  "ZMW": "Zambian Kwacha",
  "ZWL": "Zimbabwean Dollar"
};
	static #productTrans = ["CREATEPRODUCT", "BUYPRODUCT", "PRODUCTSUB", "UPDATEPRODUCT", "REMOVEPRODUCT", "PROFITSHARING", "PROFITRECIEVE"];
	
	static #budgetTrans  = ["ADDITEM", "UPDATEITEM", "CANCELITEM", "SUGGESTITEM", "CREATEBUDGET", "UPDATEBUDGET", "SUGGESTBUDGET", "BUSINESS", "EXECUTEBUDGET"];
	
	static #agreeTrans = ["AGREESEND", "AGREEMENTUPDATE", "AGREEMENTREQUEST", "AGREEMENTSIGN", "BARGAIN"];

	static #Reipient    = false;
	
	//these are transactions that affects the exchange note on the Scriptbill block web
	static #exchangeTrans = ["INVEST"/*Affects the exchange note because it indicate that the exchange note is investing in a budget*/, "INTERESTPAY"/*This is a transaction type that indicates the exchange note is receiving interest from loans*/, "BUYBOND"/*This indicate that the exchange note has been invested into*/, "BUYPRODUCT"/*This indicate a tithe has been paid*/, "PRODUCTSUB"/*Tithe has been paid during a product subscription*/, "LOAN"/*Indicate that the exchange note has released credit on loan*/, "CREATEBUDGET"/*Indicate that an exchange market is born*/, "BONDPAY"/*Indicate that the exchange note is paying out interest on bonds.*/, "DEPOSIT"/*Some deposit transaction that is directed to the exchange note*/, "WITHDRAW"/*This include some withdrawal transaction directed to the exchange note*/, "STOCKPAY"/*This indicate the exchange note has recieved dividend from the product exchange market.*/];
	
	//these are transaction types that maybe directed to the exchange market note or 
	//other notes in the network.
	static #maybeExchangeTrans = ["STOCKPAY"/*Because it happens to other stock notes*/, "WITHDRAW"/*Many other credit notes are allowed to withdraw*/, "DEPOSIT"/*Some deposit transaction may not be directed to the exchange market*/, "CREATEBUDGET"/*May be used to create business, personal or family budgets*/, "INVEST"/*A Stock or Bond note may invest into their respective mother notes*/];
	
	//these are transaction types that are directed to the product note directly.
	static #productNoteTrans = ["INVEST"/*This transaction indicate that an exchange note has invested credits to the product note concerned*/, "CREATEBUDGET"/*This transaction type indicate that a new product note is created, however the budget type must be business*/, "BUYSTOCK"/*This transaction type indicate that a product note has been credited with funds from a credit note, however it must be the note that created the budget before it can be directed to the product note else it will be directed to the note that sold the stock*/, "BUYPRODUCT"/*This indicate that a credit note has credited the product note from the product the note is selling*/, "PRODUCTSUB"/*This also indicate credit from a credit note to a product note for a product the note is subscribing to.*/];
	
	//send transaction types in array.
	static #transSend = ['SEND'/*Normal Sending Money*/, 'INVEST'/*A Special Transaction Type That Describes an Investment, Different From Defined Stock or Bond Investment, used majorly by exchange market notes to invest in other exchange note. An INVEST transaction is a MINING transaction*/, 'STOCKPAY'/*Describes a Dividend Payment*/, 'BUYPRODUCT'/*Describes the Purchase of a Product*/, 'BUYSTOCK'/*Describes the Purchase of a Stock*/, 'BUYBOND'/*Describes the Purchase of a Bond*/, 'BONDPAY'/*Describes an Interest Payment*/, 'PROFITSHARING'/*Describes a Profit Sharing Transaction*/, 'PRODUCTSUB'/*Describes a Product Subscription Transaction*/, 'CANCELLED'/*Describes a Cancelled Transaction*/, 'INTERESTPAY'/*A transaction type to pay interest from a loan*/, "CONFIRM"/*A trnasaction block teling the network that a fiat credit deposit has been confirmed by the crediter and the depositor can recieve the credits involved in the transaction. a crediter may use CANCELLED transaction to stop his credit from going to the depositor. The depositor must honor this request with an AGREEMENTSIGN transaction to release the withdraw credit to be usable by the note holder.*/, "WITHDRAW"/*This transaction indicates to the network that a user with a fiat or Crypto credit Type for instance USD has indicated withdrawal. Indicating withdrawal for a Scriptbill credit type, because it'this.s possible will not work because no one will have the fiat credit type to supply.*/, 'ADVERT'/*This is a transaction type that creates awareness to a product in the network. The creator must invest some money into this transaction to be recieved by users who will engage on the transaction base on ad rules set by the creator, unlike other advert promotion which the users who engage in ads only reward the company and it's affiliates.*/, "EXECUTEBUDGET"/*This is a send transaction that indicate a budget item has been executed. The reason for customizing this send transaction for budgets is to help distinguish between a budget been executed and a normal send transaction from a credit note.*/];
	
	static version 	= "1.0.0";
	
	//recieve transaction types in array.
	static #transRecieve = ['RECIEVE'/*Normal Recieve Transaction From SEND*/, 'INVESTRECIEVE'/*Describes the reception of an Investment from INVEST*/, 'PROFITRECIEVE'/*Describes the reception of profit from PROFITSHARING*/, 'STOCKRECIEVE'/*Describes the reception of a Stock when purchased*/, 'BONDRECIEVE'/*Describes the reception of Bond when Purchased*/, "VIEWADVERT"/*Used to recieve payment from an advertiser when viewing an advert on a Scriptbill Database*/, "PUBLISHADVERT"/*This is recieved when publishing an advert from the Scriptbill Database on your site, Your site must be a Scriptbill integrated website for this to work, else there will be no way to detect viewership on the scriptbill database without that.*/];
	
	//other transaction types that do not update the value of the note.
	static #otherTrans   = ['UPDATE'/*A transaction type that describes the Update of a Particular Value in the Note without Updating the Value*/, 'CREATEPRODUCT'/*Just like Update Transaction, it helps the note include a Product to the database*/, 'CREATE'/*This transaction describes that a new note or wallet has been created*/, 'CREATEBUDGET'/*This transaction helps include a budget into the datatable*/, 'EXCHANGE'/*This transaction describes an exchange request in the database*/, 'SELLSTOCK'/*This is a transaction request by a stock note seller, telling the nettwork he has stocks to be sold.*/, 'QUOTESTOCK'/*This transaction request that helps the invest create an actual stock note.*/, 'QUOTE'/*This transType is used to quote a Contract details to a recipient Who should be the contractee.*/, 'SOLDSTOCK'/*This is a transaction request telling the network that a particular stock has been sold.*/, 'SELLBOND'/*Transtype desribing a request to sell bonds*/, 'SOLDBOND'/*a transaction request telling the network a particular bond have been sold.*/, 'QUOTEBOND'/*a transaction request to quote a bond note, just like a create transType*/, "DEPOSIT"/*A transaction type Scriptbill Use in detecting that a Deposit of a fiat credit has been carried out. When the transaction block is made, the network assumes that the depositor has made a successful deposit. The credit supplier will get an alert that a deposit transaction has been made and should confirm it. If confirmed, a CONFIRMED transaction is created. If the credit holder the deposit has not been made, he can delay the transaction until there is a confirmation. If the depositor feels he has made the deposit and there is no confirmation transaction, then the DEPOSIT transaction remains a budget in the creditors note, he / she will not be able to use the value of the CREDIT held until he has resolved the issue with the depositor. Sometimes a third party may be invited to resolve the issue.*/, "BARGAIN"/*This is a transaction type that allows the sender of a transaction to adjust the agreement based on the request sent by the reciever in an AGREEMENTREQUEST transaction. The reception of the agreement will be indicated in the AGREEMENTREQUEST transaction. If the sender do not accept the AGREEMENTREQUEST transaction, he issues a CANCELLED transaction to cancel the transaction and initiate a refund.*/, "APPEAL"/*This transaction type helps users appeal a transaction that has been cancelled by the initiator of the transaction. f appealled before the mex_exec time in the agreement elopses*/, "LOAN"/*This transaction type Indicates that a User is trying to mine a new Credit into the System using loan. Once the credit is mined, the account Pays a Daily Interest of 0.1 to 1% daily with the Principal. This Loan does not have an Expiry Period When the User finish paying the principal, the daily Interest stops.*/, , 'AGREEMENTREQUEST'/*This is a transaction type sent by the reciever of a transaction, requesting that the sender cancels the execution of a set agreement in a transaction*/, 'AGREEMENTSIGN'/*This transaction type is an update transaction that describes that an agreement is being signed by the sender, telling the network that the sender is satisfied with a transaction*/, 'SPLIT'/*This transaction occurs only when the note has to split to other note in other to share resources, like the profit keys, agreement keys or budget keys that may be making the current note larger than 3MB* Also used as a way of creating other notes, like Qquoting stock or bond notes and creating a credit note*/, 'ADDITEM'/*adds an item to a Scriptbill Budget. This transaction is post send transaction, which tells the network that the intended user is ready to send an amount of money in a certain date. Since it is a preset transaction, the network can easily convert it to send transaction without the intention of the sender because the user has made all the neccesary things available.*/, 'UPDATEITEM'/*This transaction helps the user make changes to the ADDITEM transaction anytime.*/, 'CANCELITEM'/*A transaction type that removes an item from a budget*/, "AGREESEND" /*This is the transaction type that auto executes an agreement from a block, the block chain involved in this transaction is indicated by the referenceID handler of the new transaction block and the reference key is used to store the agreementID of the block*/];
	
	//neccessary for programmers to determine whether to alert the account details in an exchange
	//transaction or not.
	static alertDetails = true;
	//to help insert a product into the Scriptbill database that can be accessed and even used by any 
	//server in the world. we design the static async product config variable that will guide the product 
	//creator on the right kind of information needed to insert a product successfully in the Scriptbill 
	//database.
	static #servers 	= null;
	static sendServers  = [];
	static productConfig = {
		'value'			: 0,//the original value of the product.
		'units'			: 0,//the units of products available in the System
		'totalUnits'	: 0,//total units of product included to the scriptbill systems
		'name'			: '', // the name of the product.
		'description'	: '',//description of product, HTML allowed
		'images'		: '',//urls to images that describe the product
		'videos'		: '', //urls to videos that describe the product
		'creditType'	: 'SBCRD', //the type of credit which the product is being valued.
		'sharingRate'	: 0.2,//the profit sharing rate on the product
		'blockExpiry'	: '1 months', //tells time the transaction block of the buyer will expire.
		'budgetID'		: '',//the ID of the budget the product belongs to. Budget IDs in the Scriptbill Network is an ID of a Company in the Network that manages the STOCK note credit the budget produces. business and governmental budget are budget that produces exchangeable credits in the network.
		
	};
	
	//this is the ranks that will be inherited by Scriptbill users based on their
	//rank value. Badges on the other hand are created by communities
	static #scriptbillRanks = {
				"IFVSSKJBHKSBUD" 	: { "min" : 0, "max" : 10, "fellowship" : "CMBF Beginner"/*Fellowship Rank*/, "military" : "CMBF Recruit"/*Military Rank*/, "business" : "CMBF Apprentice"/*Business Rank*/, "businessManager" : "CMBF Trainee"/*Business Manager Rank*/, "political" : "CMBF Council Member"/*Political Rank*/, "investment" : "CMBF Asset Seeker"/*Investment Rank*/,"credit_level": 100/*Number of Scriptbill Credit the user can get per transaction when balance is low*/, "code": "IFVSSKJBHKSBUD"/*This is the code that tells the network about the user rank*/, "slot": 1/*This is the number of users that can fit in to ranks in this level*/, "level": 1},
				"BJHVKDKNVKDXHCIJ" 	: {"min" : 10, "max" : 100, "fellowship":"CMBF Member", "military":"CMBF Recruit Two","business":"CMBF Apprentice Two", "businessManager":"CMBF Executive Trainee", "political":"CMBF Council Member Two", "investment":"CMBF Asset Taker", "credit_level": 1000, "code": "BJHVKDKNVKDXHCIJ", "slot": 0.9, "level": 2},			
				"SJUSGRFIDUGVDISCSI"	: { "min": 100, "max": 1000, "fellowship":"CMBF Trainee Worker", "military":"CMBF Private", "business":"CMBF Establisher", "businessManager":"CMBF Officer", "political":"CMBF Councilor", "investment":"CMBF Asset Bringer","credit_level": 10000, "code": "SJUSGRFIDUGVDISCSI" , "slot": 0.8/*Telling the rate of persons that can particpate against the total population in the world*/, "level": 3},
				"HFOSBTIUSHGLDJNXK"	: { "min": 1000, "max": 5000, "fellowship":"CMBF Worker", "military":"CMBF Private Two", "business":"CMBF Proprietor", "businessManager":"CMBF Assistant Business Officer", "political":"CMBF Senior Councilor", "investment":"CMBF Asset Owner", "credit_level": 50000, "code": "HFOSBTIUSHGLDJNXK", "slot": 0.7, "level": 4},
				"LDUIDLNFBPVUADBJKNA"	: { "min":5000, "max": 10000, "fellowship":"CMBF Senior Worker", "military":"CMBF Private Second Class", "business":"CMBF Senior Proprietor", "businessManager":"CMBF Assistant Senior Business Officer", "political":"CMBF Local Councilor", "investment":"CMBF Asset Raiser", "credit_level": 100000, "code": "DUIDLNFBPVUADBJKNA", "slot": 0.6, "level": 5 },
				"OVUBSAFBVDSILFNSOH" : { "min":10000, "max":20000, "fellowship":"CMBF Assistant Deacon", "military":"CMBF Private First Class", "business":"CMBF Executive Proprietor", "businessManager":"CMBF Business Officer", "political":"CMBF Area Councilor", "investment":"CMBF Asset Multiplier", "credit_level": 200000, "code": "OVUBSAFBVDSILFNSOH", "slot": 0.5, "level": 6 },
				"DIBVOSIBASVOVS"	: { "min":20000, "max": 50000, "fellowship":"CMBF Deacon", "military":"CMBF Lance Corporal", "business":"CMBF Senior Proprietor", "businessManager":"CMBF Deputy Business Officer",  "political":"CMBF Inspecting Councilor", "investment":"CMBF Asset Grader", "credit_level": 500000, "code": "DIBVOSIBASVOVS", "slot": 0.45, "level": 7},
				"DFOBVODBVJODZBN"	: {"min":50000, "max":100000, "fellowship":"CMBF Senior Deacon", "military":"CMBF Corporal", "business":"CMBF Senior Executive Proprietor", "businessManager":"CMBF Senior Deputy Business Officer", "political":"CMBF Deputy Local Chairman", "investment":"CMBF Asset Manager Gold", "credit_level": 1000000, "code":"DFOBVODBVJODZBN", "slot": 0.4, "level": 8},
				"OBSFBVIAPVVPAVSB"	: {"min":100000, "max": 250000, "fellowship":"CMBF High Deacon", "military":"CMBF High Corporal", "business":"CMBF Sleeping Business Partner", "businessManager":"CMBF Business Officer", "political":"CMBF Local Chairman Adviser", "investment":"CMBF Asset Manager Platinum", "credit_level": 2500000, "code":"OBSFBVIAPVVPAVSB", "slot": 0.35, "level": 9},
				"OBVISBAUBVIFBUI"	: {"min": 250000, "max": 500000, "fellowship":"CMBF Assistant Priest", "military":"CMBF Sergent", "business":"CMBF Assisting Business Partner", "businessManager":"CMBF Deputy Senior Business Officer", "political":"CMBF Local Chairman Cabin Member", "investment":"CMBF Asset Manager Diamond", "credit_level": 5000000, "code":"OBVISBAUBVIFBUI", "slot": 0.3, "level": 10},
				"BDSBVSDIPBFUIDBVUB"	: {"min":500000, "max":1000000, "fellowship":"CMBF Priest", "military":"CMBF Senior Sergent", "business":"CMBF Acting Business Partner", "businessManager":"CMBF Senior Business Officer", "political":"CMBF Local Chairman", "investment":"CMBF Asset Manager Star", "credit_level":10000000, "code":"BDSBVSDIPBFUIDBVUB", "slot": 0.25, "level": 11},
				"GSUAJBVDFSBUISBUIBSDUIB"	: {"min":1000000, "max":2500000, "fellowship":"CMBF High Priest", "military":"CMBF Staff Sergent", "business":"CMBF Business Partner", "businessManager":"CMBF Assistant Business Manager", "political":"CMBF Local Inspector", "investment":"CMBF Asset Manager Galaxy", "credit_level":25000000, "code":"GSUAJBVDFSBUISBUIBSDUIB", "slot": 0.2, "level": 12},
				"BVAHKBVSDIUFVUIGAUBUIDA"	: {"min":2500000, "max":5000000, "fellowship":"CMBF Senior High Priest", "military":"CMBF Warrant Officer", "business":"CMBF Senior Business Partner", "businessManager":"CMBF Acting Business Manager", "political":"CMBF Honourable", "investment":"CMBF High Asset Manager Gold", "credit_level":50000000, "code":"BVAHKBVSDIUFVUIGAUBUIDA", "slot": 0.15, "level": 13},
				"IBDIBDVIBSDZIBFIUFBBDXKJV"	: {"min":5000000, "max":10000000, "fellowship":"CMBF Chief Priest", "military":"CMBF Senior Warrant Officer", "business":"CMBF Business Gold Partner", "businessManager":"CMBF Business Manager", "political":"CMBF Golden Honourable", "investment":"CMBF High Asset Manager Platinum", "credit_level":100000000, "code":"IBDIBDVIBSDZIBFIUFBBDXKJV", "slot": 0.1, "level": 14},
				"HASBVHIOADIYVBDIHABIDB"	: {"min":10000000, "max":25000000, "fellowship":"CMBF High Chief Priest", "military":"CMBF Deputy Chief Warrant Officer", "business":"CMBF Business Platinum Partner", "businessManager":"CMBF Assistant Local Business Manager", "political":"CMBF Platinum Honourable", "investment":"CMBF High Asset Manager Diamond", "credit_level":250000000, "code":"HASBVHIOADIYVBDIHABIDB", "slot": 0.05, "level": 15},
				"OADBVIUDBFVUBSDUFBDA"	: {"min":25000000, "max":50000000, "fellowship":"CMBF Assistant Bishop", "military":"CMBF Chief Warrant Officer 1", "business":"CMBF Business Star Partner", "businessManager":"CMBF Local Business Manager", "political":"CMBF Star Honourable", "investment":"CMBF High Asset Manager Star", "credit_level":500000000, "code":"OADBVIUDBFVUBSDUFBDA", "slot": 0.025, "level": 16},				
				"JAFBVJPBDIOVPBADBABUABV"	: {"min":50000000, "max":100000000, "fellowship":"CMBF Area Bishop", "military":"CMBF Chief Warrant Officer 2", "business":"CMBF Business Product Inventor", "businessManager":"CMBF Assistant Area Business Manager", "political":"CMBF House Clerk", "investment":"CMBF Senior Asset Manager", "credit_level":1000000000, "code":"JAFBVJPBDIOVPBADBABUABV", "slot": 0.0125, "level": 17},
				"JSBDVIABVIDUHVADUPHUAH"	: {"min":100000000, "max":125000000, "fellowship":"CMBF Assistant State Bishop", "military":"CMBF Chief Warrant Officer 3", "business":"CMBF Business Golden Product Inventor", "businessManager":"CMBF Area Business Manager", "political":"CMBF Deputy Chief Whip", "investment":"CMBF Senior Asset Manager Gold", "credit_level":1250000000, "code":"JSBDVIABVIDUHVADUPHUAH", "slot": 0.00625, "level": 18},//Deputy Lieutenant
				"HIOADSOVHOIAHIOHOVHOHHVOAIH"	: {"min":125000000, "max":150000000, "fellowship":"CMBF State Bishop", "military":"CMBF Chief Warrant Officer 4", "business":"CMBF Business Platinum Product Inventor", "businessManager":"CMBF Assistant State Business Manager", "political":"CMBF Chief Whip", "investment":"CMBF Senior Asset Manager Platinum", "credit_level":1500000000, "code":"HIOADSOVHOIAHIOHOVHOHHVOAIH", "slot": 0.003125, "level": 19},//
				"NKSLFNMKLNDSBFKLNDKNLKDNLKAD"	: {"min":150000000, "max":200000000, "fellowship":"CMBF Assistant Regional Bishop", "military":"CMBF Chief Warrant Officer 5", "business":"CMBF Business Diamond Product Inventor", "businessManager": "CMBF State Business Manager", "political":"CMBF Deputy Majority Leader", "investment":"CMBF Senior Asset Manager Star", "credit_level":200000000, "code":"NKSLFNMKLNDSBFKLNDKNLKDNLKAD", "slot": 0.0015625, "level": 20},//
				"AOJBHVUOHSUOBVSJBVUJABUIOABU"	: {"min":200000000, "max":225000000, "fellowship":"CMBF Regional Bishop","military":"CMBF Deputy Lieutenant", "business":"CMBF Business Star Product Inventor", "businessManager":"CMBF Assistant Regional Business Manager", "political":"CMBF Majority Leader", "investment":"CMBF Asset Director", "credit_level":2250000000, "code":"AOJBHVUOHSUOBVSJBVUJABUIOABU", "slot": 0.00078125, "level": 21},//Regional Lieutenant
				"Level 19"	: {"min":225000000, "max":250000000, "fellowship":"CMBF Assistant National Bishop", "military":"CMBF Second Lieutenant", "business":"CMBF Business Product Manager", "businessManager":"CMBF Regional Business Manager", "political":"CMBF Deputy Speaker", "investment":"CMBF Asset Director Gold", "credit_level":2500000000, "code":"OHSBUBSVUIBSDIUBVSUIB", "slot": 0.000390625, "level": 22},//
				"SDBUIFBVSIBISBVHBVIUBSDI"	: {"min":250000000, "max":300000000, "fellowship":"CMBF National Bishop", "military":"CMBF Lieutenant", "business":"CMBF Business Gold Product Manager", "businessManager":"CMBF Assistant National Business Manager", "political":"CMBF House Speaker", "investment":"CMBF Asset Director Platinum", "credit_level":3000000000, "code":"SDBUIFBVSIBISBVHBVIUBSDI", "slot": 0.0001953125, "level": 23},
				"IAVBIBAIABUBDIUBVIBUIDZ"	: {"min":300000000, "max":350000000, "fellowship":"CMBF ArchBishop", "military":"CMBF State Lieutenant", "business":"CMBF Business Platinum Product Manager", "businessManager":"CMBF National Business Manager", "political":"CMBF Deputy State Governor", "investment":"CMBF Asset Director Diamond", "credit_level":3500000000, "code":"IAVBIBAIABUBDIUBVIBUIDZ", "slot": 0.00009765625, "level": 24 },//Captain
				"DFBIHBVSIBIUSDBIUVBIS"	: {"min":350000000, "max":400000000, "fellowship":"CMBF Senior ArchBishop", "military":"CMBF National Lieutenant", "business":"CMBF Business Star Product Manager", "businessManager":"CMBF Assistant Continental Business Manager", "political":"CMBF State Governor", "investment":"CMBF Asset Director Star", "credit_level":4000000000, "code":"DFBIHBVSIBIUSDBIUVBIS", "slot": 0.000048828125, "level": 25},//Senior Captain
				"HBHDVIDBZHVBDILBUIDB"	: {"min":400000000, "max":500000000, "fellowship":"CMBF Continental ArchBishop", "military":"CMBF Captain", "business":"CMBF Business Product Director", "businessManager":"CMBF Continental Business Manager", "political":"CMBF State Inspector", "investment":"CMBF Asset Commander", "credit_level":5000000000, "code":"HBHDVIDBZHVBDILBUIDB", "slot": 0.0000244140625, "level": 26},
				"DJBVFIBDIUBVUIDBUIDUI"	: {"min":500000000, "max":600000000, "fellowship":"CMBF Senior Continental ArchBishop", "military":"CMBF Senior Captain", "business":"CMBF Business Gold Product Director", "businessManager":"CMBF Assistant General Business Manager", "political":"CMBF Deputy Minister of State", "investment":"CMBF Asset Commander", "credit_level":6000000000, "code":"DJBVFIBDIUBVUIDBUIDUI", "slot": 0.00001220703125, "level": 27 },
				"SJBVISBSIVBIPDBVBIDBUBDVZJKL"	: {"min": 600000000, "max":750000000, "fellowship":"CMBF Chief ArchBishop", "military":"CMBF Chief Captain", "business":"CMBF Business Platinum Product Director", "businessManager":"CMBF Assistant General Business Manager", "political":"CMBF Minister of State", "investment":"CMBF Asset Commander Gold", "credit_level":7500000000, "code":"SJBVISBSIVBIPDBVBIDBUBDVZJKL", "slot": 8.138020833333333e-6, "level": 28},
				"HIVDHVBDHDIBVIADUIBU"	: {"min":750000000, "max":900000000, "fellowship":"CMBF Senior ArchBishop", "military":"CMBF Captain Major", "business":"CMBF Business Diamond Product Director", "businessManager":"CMBF Deputy General Business Manager", "political":"CMBF Assistant Regional Minister", "investment":"CMBF Asset Commander Platinum", "credit_level":9000000000, "code":"HIVDHVBDHDIBVIADUIBU", "slot": 6.781684027777778e-6, "level": 29},
				"HBVIHADVFIBVSJKLBKBAS"	: {"min":900000000, "max": 1100000000, "fellowship":"CMBF Assistant National Cardinal", "military":"CMBF Major", "business":"CMBF Business Star Product Director", "businessManager":"CMBF General Business Manager", "political":"CMBF Regional Minister", "investment":"CMBF Asset Commander Star", "credit_level":11000000000, "code":"HBVIHADVFIBVSJKLBKBAS", "slot": 5.651403356481481e-6, "level": 30},
				"BDHBSVIDBVIUSFGIBVAYH"	: {"min": 1100000000, "max":1300000000, "fellowship":"CMBF National Cardinal", "military":"CMBF Chief Major", "business":"CMBF Business Product Chairman", "businessManager":"CMBF Assistant State Business Director", "political":"CMBF Assistant National Minister", "investment":"CMBF Asset Analyst", "credit_level":13000000000, "code":"BDHBSVIDBVIUSFGIBVAYH", "slot": 5.651403356481481e-6, "level": 31},
				"DHBFVSSDHBJHVDBJKSDJHKBV"	: {"min":1300000000, "max": 1500000000, "fellowship":"CMBF Assistant Continental Cardinal", "military":"CMBF Lieutenant Colonel", "business":"CMBF Business Gold Product Chairman", "businessManager":"CMBF State Business Director", "political":"CMBF National Minister", "investment":"CMBF Gold Asset Analyst", "credit_level":15000000000, "code":"DHBFVSSDHBJHVDBJKSDJHKBV", "slot": 5.651403356481481e-6, "level": 32 },
				"KSDBHFBVGYIOGVYISBGBDYIF"	: {"min":1500000000, "max":1750000000, "fellowship":"CMBF Continental Cardinal", "military":"CMBF Colonel", "business":"CMBF Business Platinum Product Chairman", "businessManager":"CMBF Assistant Regional Business Director", "political":"CMBF National House Member", "investment":"CMBF Platinum Asset Analyst", "credit_level":17500000000, "code":"KSDBHFBVGYIOGVYISBGBDYIF", "slot": 4.467512534767969e-6, "level": 33},
				"OJBDFAUBVIDUBUISBUISD"	: {"min":1750000000, "max":2000000000, "fellowship":"CMBF Pope Carbinet Member", "military":"CMBF Colonel Major", "business":"CMBF Business Diamond Product Chairman", "businessManager":"CMBF Regional Business Director", "political":"CMBF National House Leader", "investment":"CMBF Diamond Asset Analyst", "credit_level":20000000000, "code":"OJBDFAUBVIDUBUISBUISD", "slot": 3.722927112306641e-6, "level": 34},
				"JOBAFDUBVSDUIBSDIPGBUFUIA"	: {"min":2000000000, "max":2300000000, "fellowship":"CMBF Pope Carbinet Leader", "military":"CMBF Brigadier General","business":"CMBF Business Star Product Chairman", "businessManager":"CMBF Assistant National Business Director", "political":"CMBF National House Minority Whip", "investment":"CMBF Star Asset Analyst", "credit_level":23000000000, "code":"JOBAFDUBVSDUIBSDIPGBUFUIA", "slot": 2.978341689845313e-6, "level": 35},
				"OFBNIBFVIFBISBJKLSNVJB"	: {"min":2300000000, "max":2600000000, "fellowship":"CMBF Pope Carbinet Minority Whip Leader", "military":"CMBF Brigadier General Star 2", "business":"CMBF Business Vice Executive State Product Chairman", "businessManager":"CMBF Deputy National Business Director", "political":"CMBF National House Majority Whip", "investment":"CMBF Asset Trader", "credit_level":26000000000, "code":"OFBNIBFVIFBISBJKLSNVJB", "slot": 2.291032069111779e-6, "level": 36 },
				"IHBSDIVBSUIOBUISDBUISDFI"	: {"min":2600000000, "max":3000000000,"fellowship":"CMBF Pope Carbinet Majority Whip Leader", "military":"CMBF Brigadier General Star 3", "business":"CMBF Business Executive State Product Chairman", "businessManager":"CMBF National Business Director", "political":"CMBF Assistant National House Overseer", "investment":"CMBF Gold Asset Trader", "credit_level":30000000000, "code":"IHBSDIVBSUIOBUISDBUISDFI", "slot": 1.697060791934651e-6, "level": 37},
				"HKLBVDAHBVUSUIHBKDJNDKFN"	: { "min":3000000000, "max":3400000000,"fellowship":"CMBF Pope Assistant Carbinet Overseer", "military":"CMBF Brigadier General Star 4", "business":"CMBF Business Vice Executive Regional Product Chairman", "businessManager":"CMBF Vice Continental Business Director", "political":"CMBF National House Overseer", "investment":"CMBF Platinum Asset Trader", "credit_level":34000000000, "code":"HKLBVDAHBVUSUIHBKDJNDKFN", "slot": 1.212186279953322e-6, "level": 38},
				"OJBNSUIBVDUIBVDIIUD"	: {"min":3400000000, "max":3800000000,"fellowship":"CMBF Pope Carbinet Overseer", "military":"CMBF Brigadier General Star 5", "business":"CMBF Business Executive Regional Product Chairman", "businessManager":"CMBF Continental Business Director", "political":"CMBF National House Assistant Counsellor", "investment":"CMBF Diamond Asset Trader", "credit_level":38000000000, "code":"OJBNSUIBVDUIBVDIIUD", "slot": 8.081241866355482e-7, "level": 39},
				"JSFBHBSDVOBDBSDLJD"	: {"min":3800000000, "max":4200000000,"fellowship":"CMBF Pope Carbinet Assistant Counsellor", "military":"CMBF Major General", "business":"CMBF Business Vice Executive National Product Chairman", "businessManager":"CMBF Vice Principal Business Director", "political":"CMBF National House Counsellor", "investment":"CMBF Star Asset Trader", "credit_level":42000000000, "code":"JSFBHBSDVOBDBSDLJD", "slot": 5.050776166472176e-7, "level": 40},
				"JNDJNSDFKVJNJDONVUOSDBUISD"	: {"min":4200000000, "max":4700000000,"fellowship":"CMBF Pope Carbinet Counsellor", "military":"CMBF Major General Star 2", "business":"CMBF Business Executive National Product Chairman", "businessManager":"CMBF Principal Business Director", "political":"CMBF National Minority House Leader", "investment":"CMBF Asset Market Leader", "credit_level":47000000000, "code":"JNDJNSDFKVJNJDONVUOSDBUISD", "slot": 2.971044803807163e-7, "level": 41},
				"BHIBFFVUIBUISBVIFLKJDZSHJ"	: {"min":4700000000, "max":5200000000,"fellowship":"CMBF Pope Carbinet Minority Leader", "military":"CMBF Major General Star 3", "business":"CMBF Business Vice Executive Continental Product Chairman", "businessManager":"CMBF Principal Gold Business Director", "political":"CMBF National Majority House Leader", "investment":"CMBF Gold Asset Market Leader", "credit_level":52000000000, "code":"BHIBFFVUIBUISBVIFLKJDZSHJ", "slot": 1.650580446559535e-7, "level": 42},
				"KLBSDHBVFISBJKLSFZIDL"	: {"min":5200000000, "max":5700000000,"fellowship":"CMBF Pope Carbinet Majority Leader", "military":"CMBF Major General Star 4", "business":"CMBF Business Executive Continental Product Chairman", "businessManager":"CMBF Principal Platinum Business Director", "political":"CMBF National Council House Chair", "investment":"CMBF Platinum Asset Market Leader", "credit_level":57000000000, "code":"KLBSDHBVFISBJKLSFZIDL", "slot": 8.687265508208077e-8, "level": 43},
				"JBSDVIBUIBDUIVBUBDSU"	: {"min":5700000000, "max":6300000000,"fellowship":"CMBF Pope Carbinet Council Chair", "military":"CMBF Major General Star 5", "business":"CMBF Business Principal", "businessManager":"CMBF Principal Diamond Business Director", "political":"CMBF National House Secretary", "investment":"CMBF Star Asset Market Leader", "credit_level":63000000000, "code":"JBSDVIBUIBDUIVBUBDSU", "slot": 4.343632754104039e-8, "level": 44},
				"HIBSVHUBSDUYBSDVUSZJKZS"	: {"min":6300000000, "max":6900000000,"fellowship":"CMBF Pope Carbinet Council Secretary", "military":"CMBF Lieutenant General", "business":"CMBF Business Don", "businessManager":"CMBF Principal Star Business Director", "political":"CMBF National House Vice President", "investment":"CMBF Asset Holder", "credit_level":69000000000, "code":"HIBSVHUBSDUYBSDVUSZJKZS", "slot": 4.343632754104039e-8, "level": 45},
				"IHDBYHSDBZYUHDSFJIAFUYVBGV"	: {"min":6900000000, "max":7500000000,"fellowship":"CMBF Pope Carbinet Vice Chairman", "military":"CMBF Lieutenant General Star 1", "business":"CMBF Business Don King", "businessManager":"CMBF Business Vice Chairman", "political":"CMBF National House President", "investment":"CMBF Gold Asset Holder", "credit_level":75000000000, "code":"IHDBYHSDBZYUHDSFJIAFUYVBGV", "slot": 2.17181637705202e-8, "level": 46},
				"JBJIBDISBSDVHIBDZXJKS"	: {"min":7500000000, "max":8200000000,"fellowship":"CMBF Pope Carbinet Chairman", "military":"CMBF Lieutenant General Star 2", "business":"CMBF Business Don King 5", "businessManager":"CMBF Business Vice Chairman Advicer", "political":"CMBF National Adviser", "investment":"CMBF Platinum Asset Holder", "credit_level":82000000000, "code":"JBJIBDISBSDVHIBDZXJKS", "slot": 1.447877584701346e-8, "level": 47},
				"HSDBHBDFVYIBSHBNVSINBSDIL"	: {"min":8200000000, "max":8900000000,"fellowship":"CMBF Pope Adviser", "military":"CMBF Lieutenant General Star 3", "business":"CMBF Business Don King 4", "businessManager":"CMBF Special Business Vice Chairman Advicer", "political":"CMBF Special National Adviser", "investment":"CMBF Diamond Asset Holder", "credit_level":89000000000, "code":"HSDBHBDFVYIBSHBNVSINBSDIL", "slot": 1.034198274786676e-8, "level": 49},
				"SBIBFGUIBNXSDIBNVIBDFSIBNSI"	: {"min":8900000000, "max":9600000000,"fellowship":"CMBF Pope Special Adviser", "military":"CMBF Lieutenant General Star 4", "business":"CMBF Business Don King 3", "businessManager":"CMBF Business Vice Chairman", "political":"CMBF National Chief of Staff", "investment":"CMBF Star Asset Holder", "credit_level":96000000000, "code":"SBIBFGUIBNXSDIBNVIBDFSIBNSI", "slot": 8.618318956555631e-9, "level": 50},
				"HIBSDIBFVUISDBUISDBIUB"	: {"min":9600000000, "max":10300000000,"fellowship":"CMBF Pope Special Adviser", "military":"CMBF Lieutenant General Star 5", "business":"CMBF Business Don King 2", "businessManager":"CMBF Business Chairman Adviser", "political":"CMBF National Senate Vice President", "investment":"CMBF Investor", "credit_level":103000000000, "code":"HIBSDIBFVUISDBUISDBIUB", "slot": 8.618318956555631e-9, "level": 51},
				"HBADYIVBADYBCIBDAIBUID"	: {"min":10300000000, "max":11100000000,"fellowship":"CMBF Assistant Pope", "military":"CMBF General", "business":"CMBF Business Don King 1", "businessManager":"CMBF Special Business Chairman Adviser", "political":"CMBF National Senate President", "investment":"CMBF Special Investor", "credit_level":111000000000, "code":"HBADYIVBADYBCIBDAIBUID", "slot": 8.601116723109412e-9, "level":52 },
				"BJDIYBVISBUIDFBIUDBUI"	: {"min":11100000000, "max":12000000000,"fellowship":"CMBF Deputy Pope", "military":"CMBF General Star 2", "business":"CMBF Don Knight", "businessManager":"CMBF Business Chairman Adviser", "political":"CMBF National Vice President", "investment":"CMBF Principal Investor", "credit_level":120000000000, "code":"BJDIYBVISBUIDFBIUDBUI", "slot": 8.432467375597463e-9, "level": 53},
				"SIHFBFVIDBXLBKVLJD"	: {"min":12000000000, "max":20000000000,"fellowship":"CMBF Pope Knight", "military":"CMBF General Star 3", "business":"CMBF High Knight", "businessManager":"CMBF Business Chairman", "political":"CMBF National President", "investment":"CMBF Investor General", "credit_level":200000000000, "code":"SIHFBFVIDBXLBKVLJD", "slot": 4.216233687798731e-10, "level": 54},
				"IBSFUIVBDFUIBGVIUSDUISDUBVUB"	: {"min":20000000000, "max":Infinity,"fellowship":"CMBF Pope", "military":"CMBF Commander General", "business":"CMBF Don King 1", "businessManager":"CMBF Business Chairman", "political":"CMBF National President", "investment":"CMBF Investor General", "credit_level":Infinity, "code":"IBSFUIVBDFUIBGVIUSDUISDUBVUB", "slot": 1.686493475119493e-10, "level": 55}				
	};
	
	//bitcoin addresses to accept payment from Scriptbill Demanders
	static #ScriptbankAccounts = [		
			'bc1qxxscuyxs2szjrnwrpqfzehf4rmxmz9wn99jyqd',
			'bc1qex4ez3klrrgkv9kqm7eyvxgx4p4kgvpd64h2pa',
			'bc1ql2k9qq8rdaflu27nh95kv8a9dt8qj0uxrjunhc',
			'bc1qq03nhnqekxkdhp4ksqfjy8gqhwjq69jfm9pg2l',
			'bc1qauqa5vqw5fjeyjvftph9r943vtpvk9cvzw652m',		
			'1GJYa6ZTq7Xog5whGCefjeNNgV4G7ycuyN',
			'14qQva9goeY5yZ5Ra3MLeN9JKLJc1Jp5RT',
			'1Hoz1fRVQM3UDbWnCnr7hKKy88Y8DySTVf',
			'15CdngZxKZNmN8w4YxF7vdcrsxA1DaPNRK',
			'1PF8JFqz8knPstX3Rsjr2nWZexStHBxaZc',
			'1FjzmN4oTatpFgavzWr7M4oah8poAgvMcr',		
			'1LqxtuLtMyW3fKTRqiFMfe3xfVCxRwtwWh',
			'189HMvedKSff4REqULR88jjoUykca1GvAZ',
			'1LnfVABHM5JEq235NQLu8mvW9ipNsSL4GT',
			'1K23z4TbwLLUAbQbXgYCUz7E5rae4BXiGN',
			'19iGbNoSYZetCUtr92EAek8xAwQGubuLaz',		
			'1DvMpf6XCbyHh5vhVhgNM3kJMj7fuZjtbh',
			'1CVyZG4he3RypAAfhLaHWCo74Zx6X5YYH2',
			'18yq6GxhheZ1DJ9nbLFxrAX55d2mQR32iC',
			'13a1RFu3DkUFQxop5Z6PaSqw2YV77KdYne',
			'1FPFyMjGLbr4XGDXQ2K25DcKxsNmuCworT',		
			'1B8uTmjxcGamfgETZDzwFQPGsMnCiFNBWc',
			'1ArVLmQuYYYdghAJafPXutED94stJ6Hjz5',
			'1DNhkUoAP45enuB7qUYtpXe1FCYP2ankki',
			'1wLfkvyDhgJCX4bRxbisako4X6GTBGFTk',
			'1BxThqkxGa68AuabSAFz1fEt6kywnWfyGd',		
			'1CGsCbWzQqZgWXkkoo2CyzGmm5jnFtTH8f',
			'1Nc2ssQ2mepWvpJ4bwpJsu8zTcy1uBQ8Km',
			'1CDRzQZmEaBRFZJEpdB1cxPTg91DzhMcD5',
			'12C9YkNJCfkHU3cZuCqSFEEC2K6iyCTSsC',
			'1LnzArSXWxL3L3RvUbuyUkK2cc3M9CGTrs'
		 ];	
	
	static defaultSub = {
		"subSpread"	: "1 weeks",
		"nextSub"	: "",
		"subUnit"	: 1, //total subscription to be made.
		"productID"	: "",//product making subscription to.
		"value"		: 0,//the value of the subscription.
		"lastSub"	: 0,//the amount to be paid when running the last subscription.
		"subsID"	: ""//the subscription id, used to store the subscription on 
		//the note and as a means of identifying the subscription on the Scriptbill data systems
	};
	
	//the default content of a Scriptbill note. This does not means that Scriptbill is limited to Scriptbill
	//content alone. Scriptbill could stand as database to decentralized application who take financial
	//security serious.
	static defaultScriptbill = {
		walletID 	: '',//Scriptbill is the unique walvar id of the user, Scriptbill data is used to cryptographically link all the account of a particular user to a wallet. So that it can be recognized everywhere it is found.
		noteID		: '0000',//Scriptbill a unique nonce of the note, it increase everytime there is a transaction using Scriptbill note
		contacts 	: [],//walvar ids connected to the note as a contact.
		noteAddress	: '', //Scriptbill is the public key of the note, it is used to encrypt data that should be read by Scriptbill note alone.
		noteSecret	: '', //Scriptbill is the private key of the note, used by the note owner to recieve funds sent to Scriptbill note address. If you think your note Secret is compromized, you can recreate it and change your note address. To aviod it not affecting business, you can use the connectedNote parameter to link your new note to the compromized note and maintain the security on your note.
		noteKey		: '', //Scriptbill is the increment value of the nonce above, Scriptbill means the noteKey divided by the current note ID should give us the total transaction done by Scriptbill note.
		noteValue 	: 0.000000000000, //Scriptbill is the value of the note. 
		noteType	: 'SBCRD',//Scriptbill is the unique code of the note you are using, anything that changes Scriptbill note type would change the transactional value of the note to the new note type.
		version 	: this.version,
		creditType	: 'scriptbill',//indicates the type of credit being used by the note. "Fiat" type shows that the note is depending on a fiat credit or any physical goods to sustain it'this.s value, "Award" type shows that the issuer is the determinant of the value - good for game credit types, while scriptbill depends on the value in the exchange market.
		transValue	: 0.000000000000, //Scriptbill is the last transaction value of the note. 
		transTime 	: this.currentTime(), //Scriptbill is the last time stamp of the transaction on the note.
		transType	: 'CREATE',//Scriptbill is the type of transaction conducted by the note.
		rankPref	: 'fellowship',//the prefered Scriptbill ranking structure, the user can change this later
		transHash	: '',//Scriptbill is half of the hash of the last transaction block Scriptbill note created. To create a new transaction block, then Scriptbill note must verify Scriptbill hash.
		transKey	: '', //Scriptbill is the private key of the last bock produced by Scriptbill note.
		profitKeys	: [],//Scriptbill is the private key of the product block held by the note for profit sharing.
		noteServer	: this.#default_scriptbill_server, //the server where the note is hosted. The note will be found of sending request to Scriptbill server to connect to the network.
		noteHash	: '',//Scriptbill is the last hash value of the note
		noteSign	: '', //Scriptbill is the signature built using the noteHash and the secret of the note.
		noteSubs	: [], //Scriptbill is an array of the total subsription on Scriptbill note
		noteBudgets	: [], //Scriptbill is an array of the total budget on Scriptbill note.
		noteProducts : [], //an array of private keys of products produced by the note.
		agreements 	: [], //Scriptbill is an array of private keys of agreements held by Scriptbill note.
		blockKey	: '',//Scriptbill is the private key to the note'this.s current block. Used to verify that the note actually signed the block it created.
		blockHash	:'',//Scriptbill is the hash of the total hash of the transaction block concerned. This is required to verify if the note created the transaction block it is processing wiith.
		BMKey		: '', //Scriptbill is the note address of the business manager that controls Scriptbill note network.
		walletRank	: '',//the Scriptbill ranking of the current wallet. This is calculated by getting all transactions connected to the wallet. To get transactions connected to the wallet, you encrypt the current block wallet hash with the walvar id as key. If the result equals the nextWalletHASH then the block belongs to the current wallet, and the rank can be added to the note as walletRank.
		budgetID 	: '',//stores the current budget ID created by the note
		accountData : {},//stores the data of the account of the note. Design to store personal information about the holder of the note.
		loanValue 	: 0,//designed to store information about the loan held by the wallet
		rankValue 	: 0,//this is the total value of the whole note in the wallet minus the loan value.
		
	};
	//used with the defaultBlock to configure transactional request to the transaction block generator function
	//Scriptbill property is designed to be static async because transactions can be designed outside of Scriptbill class.
	static details;
	static #scriptbankKey = "hVUCY9tTSoovBlaQSMKMx3VEnfbFOli2GGISABFthic=";
	//the default scriptbill block content.	
	static defaultBlock = {
		blockID 		:	'', //Scriptbill is the unique identifier of the block, always generated by using the noteSecret in combination with the noteID.
		formerBlockID 	: 	'', //Scriptbill is the unique idetifier of the block before Scriptbill block, the default value is zero if it is created for a new note who do not have a fomer block.
		nextBlockID		: '', //Scriptbill is the unique identifier of the next block of the current note, calculated by using the noteSecret and the projected next noteID.
		noteHash		: '', //Scriptbill is the remaining half version of the hash of the note that owns Scriptbill note. If the hash on the note do not match Scriptbill hash the note is invalid.
		transHash		: '', //Scriptbill is the remaining half of the hash to the transaction block of the note, it is expected that the current note would have the hash of Scriptbill block handy.
		realHash		: '', //Scriptbill is the hash of the note supplied by the note, it must match the total hash when put together with the note hash of the last block.
		totalHASH		: '', //Scriptbill is the hash of the total hash of the note's block history.
		//noteTotal		: '',//the total hash of the note's transaction history. The real hash supplied by the note must equal
		blockHash		: '', //Scriptbill is the transaction block hash supplied by the note. Scriptbill must also match the total hash when combined together with the transhash of the last block.
		noteSign 		: '',//signature from the note using this block.		
		noteServer		: this.#default_scriptbill_server, //the current server from which the note is being managed
		noteValue		: 0.000000000000, //Scriptbill is the value of the note that produced Scriptbill note.
		noteType 		: "SBCRD", //the note type of the note creating this transaction
		transValue 		: 0.000000000000, //Scriptbill is value of the transaction made by the note.
		rankPref 		: "fellowship",//this is the preffered rank of the note that created this block. This should be known by the network for verification purpose so that a ranker does not go about claiming he is in another rank when in this particular rank
		transType		: 'CREATEBUDGET', //This is the transaction type the note in the network conducted.
		creditType		: 'scriptbill', //this indicates the credit type of the note that owns this block. Values can be "fiat", "award", or "scriptbill" as default
		transTime		: '', //time stamp that describes when the transaction on Scriptbill note occurred.
		recipient		: '', //an agreement encrypted using the recipients public key and should only be decrypted by the owner of the key.
		referenceID		: '',//this is the id that indicate the block chain an auto executed transaction is running for.
		referenceKey	:'',//this is the agreement or budget ID of the auto executed transaction.
		splitID			:'',//this is the ID of a SPLIT transaction that specifies to the network the block chain a particular block chain had split into. Other transaction types handling the splitID includes QUOTESTOCK, QUOTEBOND, CREDIT transactions.
		walletHASH		: '', //an hash value used to locate the wallet on the database.
		formerWalletHASH : '', //stored to test the value of the walletHASH when the note's wallet key is changed by the wallet for security reason.
		walletSign		: '', //Scriptbill is a signature that tells and confirms that the note that created THIS block owns the walletHASH.
		blockKey		: '', //Scriptbill is the public key of the block of whose private key is held by the note that create Scriptbill block chain.
		blockSign		: '', //Scriptbill is the signature of the wallet using the block private key, stored on the block's note as a signing reference.
		blockRef		: '', //Scriptbill is the reference key of the block, to the sender it is a public key whose private key will be stored in the agreement on the transaction. The recipient must still add the public key of Scriptbill reference to the block, so that verifiers can locate the senders block using Scriptbill key.
		signRef			: '', //Scriptbill is a dynamically generated text for a sender and a signature for a reciever of a transaction. Verifiers will use the blockRef and the text to verify Scriptbill transaction. The security of Scriptbill is that no two block must have the same blockRef except the sender and RECIEVEr blocks.
		agreements		: {}, //Scriptbill is all the agreement on Scriptbill note, can be executed by any node on the network. As the agreements are getting
		lastAgreeHash 	: '', //the last hash of the agreement of the block supplied by the note, this must match the first 10 digits of the last agree hash of the next block.
		agreeHash 		: '',//first 6 digit and the last 6 digits of the calculated hash of the total agreements on this block, this must match the first and last agreement hash that will be supplied by the note.
		noteID			: '',//Scriptbill is the current Note ID of the note when the transaction block is created. This note ID must match the note ID stored on the note when incremented with the noteKey.
		expiry			: 0,//Scriptbill gives us a picture of when the block should be deleted from the database to save space. It'this.s given to the current node to obey Scriptbill, because they can delete any block as long as the block'this.s note has a new transaction block in pace. Sometimes blocks can be used to search out profit Sharing recipients.
		interestRate 	: 0.2,//this is the interest rate that will be deducted from the note transaction whenever he is on credit and his receiving a credit.
		interestType    : 'PT',//this tells the code on how to handle the interest calculation. you can see this.interestType for possible values of what this can get. Most of the time these values change when the note graduates from one rank to another.
		budgetRefs		: [],//this is an array of keys to the budget created by the notes
		budgetID		: "", //the id to the budget that owns the transaction. Used to verify stock transaction that is connected to a commercial or property budget.
		productID 		: "", //ID of the product that owns a transaction, used to verify the value and agreement set by the product creator during a product purchase transaction.
		agreement 		: this.budgetConfig, //an object of values to describe a budget or product or an agreement inherited by the note during a transaction. this is also the hash of the agreement sent by the sender. This mush match the Hash
		//og the agreenet recieved by the recipient.
		exchangeNote 	: {
			walletID 		: "6VwjaCntu1HDO/CVoWSuZ6PVyx3Pc/",//the unique walvar id of the user that created the exchange market.
			exchangeID		: "ejRnSllWcGxqYUZqdGdudHl0T1RYOS9MdEdRdkpH",//this is the unique ID to exchange Credits to this credit type. 
			exchangeKey		: "TUlJRW9nSUJBQUtDQVFCOVBadXUxSTBCSHRBSWJISEFPQmw0NX",//this is the unique private key to the exchange of this credit. Request made to the exchange market using this exchange
			exchangeValue	: 1.000000000000, //total credit supplied to the exchange market or the number of bonds held.
			demandValue		: 0.000000000000,//total credit demanded from the exchange market or in circulation.
			transValue 		: 0.000000000000, //the last transaction value of the exchange market
		
			noteValue	: 0.000000000000, //the value of the exchange account.
			noteType 	: "SBCRD",//the credit type of the exchange account.
			transTime 	: "",//the time the last transaction was done on this account.
			transType 	: "CREATE",//the last type of transaction that was performed by the note.
			noteID 		: "0000",
			noteKey		: "qqek83j3x9d7hyt65fstv8u38xe6shn05szn6fm3xn",//this can contain the account number 
				//for a non Scriptbill Credit type.
			budgetID 	: "",//contains the budget ID of the governmental budget created by the credit.
			transKey 	: [{type: "bitcoin"}],//an opportunity to store other important details of the 
				//account, if it is a bank here we set the type of the above noteKey as bitcoin, if paypal save
				//the type as paypal. Variable to use include {'type', 'bankCountry', 'paymentUrl', 'accountTokens', 'bankName', 'accountName', 'sortCode'}
				//account number that was set in the noteKey handler. If it'this.s account like bitcoin, only the 
				//bitcoin address should be added in the noteKey the transKey handler will be empty. A paypal 
				// account will only need the email address or payment url. Any details that is added here should
				//be stored in JSON for easy parsing. Non Json details will be ignored. The exchange ID and 
				//exchange key will act as the note address and note secret respectively.
			noteServer 	: this.#default_scriptbill_server,//the server of the exchange account. All credit on this network must have this 
				//account.
			noteHash 	: "",
			transHash	: "",
			blockHash 	: "",
		},//since the exchange note is somewhat dynamic and sometimes determined by the nodes in the network
		//transaction hashes will only be done without the exchange note attached to the transaction block
		//if the note have to update, the last transaction block on the will be affected until the whole 
		//network updates their too.
		exBlockID		: '',//the current id of the exchange note.
		exNextBlockID	: '', //the next id of the next credit transaction block
		exFormerBlockID : '', //ID of the former credit note block for this exchange market.
		productBlockID  : '',//the current id of the product block. Useful in calculating the profit sharing formulars.
		productNextBlockID : '',//the Id of the possible next block that will belong to this product.
		productFormerBlockID : '',//the last id of the block belonging to this product, useful in knowing the most recent customer to the current product.
		
	};
	//the default content n an agreement.
	static defaultAgree = {
		agreeID			: '', //this is the unique identifier of the agreement.
		agreeSign		: '', //this is the unique signature of the agreement, to be signed by the initiator of the agreement
		agreeKey		: '', //this is the public key to the agreement, used to verify the agreement signature and to verify the beneficiary account.
		senderSign		: '', //this is the unique signature of the sender,
		senderID		: '', //this is the block ID of the sender, used as a signature text for the signature.
		senderKey		: '', //key used by sender to sign this agreement
		recieverID		: '', //this is the identifier of the block of the reciever, this is useful when other nodes want to accept the new agreement as valid.
		recieverKey		: '', //key used by reciever to sign this agreement
		maxExecTime		: '', //this is the maximum time allowed for the agreement to last on the block chain. If this time elapses, the agreement would be executed by force,  forcing the note of the creator to reduce even to a negative value.
		agreeType		: 'normal',//this describes the type of agreement we are handling. values are "normal", which denotes that the agreement should be handled normally, that is if terms are not met agreement should be reverted to the sender. The "sendTo" type ensures that the funds are sent to a particular or an array of note addresses, specifying the values to be sent per address when the execution time reach or when the agreement terms are not met. "Loan" type specifies that the money was borrowed to the recipient and must be returned at the specified time. The "loan" type works with interest rates. "contract" agreement type works like budget for the recipient, because it tells how the recipient should use the money, base on an initial quote sent by the recipient in a QUOTE transaction
		ExecTime		: 0, //this is the execution time for the agreement, this will only successfully run the agreement if and only if the note that holds the agreement has enough funds to sponsor the agreement, else agreement would not run but would wait until their is a RECIEVE transaction that would update the note'this.s value.
		value			: 0.0000000000000, //this is the total value of the agreement, the transaction value of a transaction is mostly used here. For security reasons, this value cannot be larger than the value of the transaction.
		isPeriodic		: false, //a boolean value that tells whether this should run periodically, if it will run periodically, the periodic value will be calculated
		times			: 0, //works with the isPeriodic, if set to true, the value of this variable will be used against the value variable to determine how much the account will spend
		payTime			: 0, //this is the time for the next payment, works when isPeriodic is set to true, else the execTime determines the payment
		payPeriod		: '1 weeks', //this is the spread of payment that controls how scripts should set the payTime. If 1 week, when the payment has been executed, the pay period is used to calculate the next payTime.
		delayInterest	: 0, //this determine the amount of interest that would be charged if the execTime is exceeded before the contract ends.
		interestType	: 'SIMPLE', //This is the type of interest that would be charged; accepts SIMPLE & COMPOUND.
		interestSpread	: '1 days', //this determine the spread at which the interest will be calculated.
		interestRate    : this.interestRate,
		timeStamp		: this.currentTime(), //this is the signature of the timestamp of the agreement. This is designed to avoid duplicate agreement issues.
		realNonce		: '',//hashed of the current note ID.
		recieverSign 	: '',//this is the signature on the agreement which is signed by the sender with the senders key to verify that the agreement has been met by the reciever. The sender will have to create an AGREEMENTSIGN transaction, referencing the blockID to the AGREEMENTREQUEST transaction sent by the reciever to obey this.
		quoteID			: '',//this is the block ID to the reference block that has the quote to the agreement in a contract based agreement.
		sendAddress		: '',//this is the address or group of addresses to send the agreement value to, this correspond to a sendTo agreement type. if it is a group, then values to be sent to each address should be specified. If the execution time for each address is different, then this should be specified, else the general execution time will be followed for all address. 
		
	};
	
	//because most product on the scriptbill network will be bought using subscription, we design the static async subscription configuration property to guife subscribers on how to integrate it.
	static subConfig   = {
		'subsID'		: '',//this product block ID of the subscription.
		'value'			: 0,//the value of the subscription
		'productID'		: '',//the product id subscribed to
		'subSpread'		: '1 weeks',//the value of the spread of the subscription
		'nextSub'		: 0,//the timestamp when the next subscription will be held.
		'subUnit'		: Infinity,//the total number of time the subscription must run.
	};
	
	static creditConfig = {
		'value'		: 0,
		'noteType'	: 'SBCRD',//the note type of the recipient credit
		'recipient'	: '',//the account or Scriptbill note that would recieve the money
		'expiry'	: '',//time when Scriptbill credit will play on the user'this.s note. If the expiry is exceeded the credit start playing recursively on the user note.
		
	};
	//static #sendAgreement  = this.#runAgreements();
	//helps recieve and process transactional block data from the note's server.
	//this function is designed to run as long as a day to ensure that without reinstanc
	//tiating Scriptbills transactional block data are being communicated and processed
	//by the client.
	static #recieve		 			= this.recieveData();
	static #currentBlock 			= this.runGetCurrentBlock();
	static #shareData 				= this.shareData();
		
	//this logic helps the storeBlock function to decide whether to or not set the 
	//incoming transaction block as the current note block.
	static #setNoteBlocks 	= false;
	
	//this help to store password set from outside the function using the 
	//set_pass property
	static #set_pass 		= false;
	
	
	
	//other important variable.
	static formerBlock;
	static nextBlock;
	static rankValue;
	static noBlock;
	static workedID;
	static endBlockID;
	static startBlockID;
	static walletHASH;
	static budgetID;
	

	
	

	constructor(walletID = '', noteAddress = '', password = '', note = ''){
		//console.log("constructor running!!!" + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] 	= "constructor";
		//before scriptbill initializes, let'this.s check if Scriptbill can communicate with the current server
		this.init(walletID, noteAddress, password, note);		
	}
	
	static async init(walletID = '', noteAddress = '', password = '', note = ''){
		this.#noVerify			= false;
		//alert( password );
		if( window.location.protocol != 'https:' &&  ! window.location.href.includes("localhost") && ! window.location.href.includes("127.0.0.1") && window.location.protocol != "chrome-extension:" && this.alertDetails  ) {
			await this.createAlert('Sorry! Scriptbill Won\'t run in a non https environment! You Can Contact The Site Admin For Assistance');
			return;
		}
		
		
		if( ! this.l )
			this.l = localStorage;
		
		if( ! this.s )
			this.s 	= sessionStorage;
		
		
		//console.log( "Password Entered: " + password, "user_input: " + this.s.user_input );
		
		if( this.binary )
			note = this.binary;
		
		if( ! note && this.s.uploadedNote )
			note 		= this.s.uploadedNote;
		
		else if( this.s.uploaded ){
			//get uploaded note from storage.
			note 	= await this.resolvePersistentData( this.s.uploaded, 'binaries', false );		
			if( note ){
				this.binary = note;
			}
		}
		try {
			this.l.uploadedNote = note;
		} catch (e){
			//console.log( e );
			this.binary = note;
		}
		
		//console.log( "password before password: " + password );
		
		this.#password = await this.#getPassword( password );		
				
		
		//console.log("uploaded note: " + note);
		//await this.createAlert("Check Password! ");
		
		//await this.setUpDatabase();
		
		if( walletID ){
			//required to idetify a user for ranking purposes in the Scriptbill network. The reason is that it is assumed users will have many notes to deal with
			//knowing the user wallet will help the user recieve the atrribution given to a particular note in the network.
			//if the user has many wallets, atrribution given to each note will be distirbuted per wallet, the user may not have any good promotion through out the network,
			//may hold may post that require different responsibilities at the same time.
			this.walletID = walletID;
		}
		
		if( noteAddress ){
			this.noteAddress = noteAddress;
		}
		try {
			if( note && ( ! this.s.currentNote || ! this.isJsonable( this.s.currentNote ) ) ){
				//console.log( "running login note 2" );
				this.#note = false;
				//a note is always saved in binary format if the note is downloaded from the user'this.s table.
				this.binary = note;
				//testing the binary note to be sure that the note is actually a binary string.
				if( this.binary.match(/[2-9]/g) != null || this.binary.match(/[a-z]/gi) != null ) return this.binary;
				
				let noteEncrypt = await this.debinarilize();
				//console.log("inside note and was not returned, debinarilized note: " + noteEncrypt);
				//await this.createAlert( "check debinarilize");
				
				if( this.#password ){	
					var string 	=  this.#password;
					//console.log( "private key set: " + this.privateKey );
					note = this.decrypt( noteEncrypt, this.hashed( string ) );
					
					//console.log( "decrypted note: " + note, typeof note );
					//await this.createAlert("Check decrypted note ");
					
					if( this.isJsonable( note ) ) {
						this.#note = JSON.parse(note);
						
						//await this.createAlert('isJsonable');
						let nextBlockID 	= "";
						if( this.#note.block ){
							this.response = JSON.parse( JSON.stringify( this.#note.block ) );
							if( typeof this.response == "string" && this.isJsonable( this.response ) )
								this.response 	= JSON.parse( this.#note.block );
							
							nextBlockID 	= this.response.nextBlockID;
							
							delete this.#note.block;
							this.#setNoteBlocks 	= true;							
							await this.storeBlock( this.response, this.#note );
							this.#setNoteBlocks 	= false;
							
						}
						
						if( this.#note.blocks && typeof this.#note.blocks == 'string' && this.isJsonable( this.#note.blocks ) )
							this.#note.blocks 		= JSON.parse( this.#note.blocks );
						
						if( this.#note.blocks && this.#note.blocks.length && typeof this.#note.blocks == 'object' ){
							let blocks 		= JSON.parse( JSON.stringify( this.#note.blocks ));//3W9oE6Kcdy4RHvYV+KHq9g==
							blocks 			= blocks.filter( (block)=>{
								return block.blockID != nextBlockID;
							});
							for( let r = 0; r < blocks.length && r <= 12; r++ ){
								this.response 		= JSON.parse( JSON.stringify( blocks[r] ));
								
								if( this.response && this.response.blockID ){
									this.#setNoteBlocks 	= true;
									await this.storeBlock( this.response, this.#note );
								}
							}
							this.#setNoteBlocks 	= false;
							delete this.#note.blocks;
						}
						let checkNoteVersion	= async ()=>{
							//console.log( this.#note.blockID );
							if( this.#note.blockID ){
								//checking if the note is an outdated note.
								let transBlock 		= await this.getTransBlock(1, {blockID: this.#note.blockID});
								
								if( transBlock && transBlock[0] && transBlock[0].nextBlockID ){
									
									transBlock 		= await this.getTransBlock(1, {blockID: transBlock[0].nextBlockID});
									
									if( transBlock && transBlock[0] && transBlock[0].nextBlockID ){

										let realNote 	= await this.getDataPersistently( transBlock[0].blockID.replaceAll(/[^A-Za-z0-9]/g, "_" ) + "_note", this.#note.noteAddress, false );
										
										if( ! realNote || ! this.isJsonable( realNote )){
											this.errorMessage("You Are logging in an outdated version of the note, please login again with the most recent version.");
											return false;
										}
										
										this.s.currentNote = realNote;
										this.#note = await this.#getCurrentNote();
										
										if( this.#note && this.#note.noteAddress )
											return await checkNoteVersion();
										
										else
											return false;
										
									} else {
										return true;
									}
								} else if( ! transBlock || ! transBlock[0] || ! transBlock[0].blockID ){
									this.errorMessage("You Are logging in an invalid version of the note because we could get it's transaction block, please login again with a valid version");
									return false;
								}
							} else {
								this.errorMessage("Logging in an invalid note, note initialization ceasing...");
								return false;
							}
						}
						
						let version = await checkNoteVersion();
						
						if( ! version ) return false;
						

						/* if( this.response && this.response.transType == "SPLIT" ){
							this.details 			= 	JSON.parse( JSON.stringify( this.response ) );
							this.details.transType 	= "MERGE";
							this.details.recipient 	= this.#password;
							this.details.agreement 	= this.response.recipient;
							let personal = JSON.parse( this.isJsonable( this.l.personal ) ? this.l.personal: '{}' );
			
							if( personal.walletID )
								this.walletID 	= personal.walletID;
							else
								this.walletID 	= await this.generateKey();
							
							this.mergeNote 			= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
							if( this.key && this.key.match(/[0-9]/) && parseInt( this.key ) != NaN )
								this.#passwordKey 	= this.key;
							
							else
								this.#passwordKey 		= await this.createPrompt("Create your unique transaction key connected to this note. It must be at least four digits", "1234");
							
							await this.generateScriptbillTransactionBlock();
						} */
							
						if( this.#note.accountData ) {
							var string 	= this.#note.walletID;
							let trivKey 	= this.hashed( string );
							let accountData  = await this.getAccountData();
							
							
							accountData[this.#note.noteAddress] = this.#note.accountData;
							
							if( this.#note.rank )
								accountData.rank 		= this.#note.rank;
							
							//should be verified with the account data block id. 
							if( accountData.value ){
								if( accountData.accID ){
									this.blockID = accountData.accID;
									let transBlock = await this.getTransBlock();
									transBlock 		= transBlock[0];
									if( transBlock && transBlock.rankValue && transBlock.rankValue != accountData.value ){
										accountData.value = transBlock.rankValue;
									}
								}
								this.rankValue 			= accountData.value;
							} else {
								accountData.value 		= this.#note.rankValue;
							}
							
							if( accountData.loanValue ){
								if( accountData.loanID ){
									this.blockID = accountData.loanID;
									let transBlock = await this.getTransBlock();
									transBlock 		= transBlock[0];
									if( transBlock && transBlock.rankValue && transBlock.rankValue != accountData.value ){
										accountData.loanValue = transBlock.loanValue;
									}
								}
								this.loanValue 			= accountData.loanValue
							} else {
								accountData.loanValue 	= this.#note.loanValue;
							}
							
							this.setAccountData( accountData );
							
							delete this.#note.rank;
						}
						
						//await this.createAlert( 'saving note ' + this.walletID );
						if( ! this.#password )
							this.#password 	= await this.#getPassword();						
						
						this.noteAddress = this.#note.noteAddress;
						this.s[ CryptoJS.MD5( this.#note.noteSecret ).toString( CryptoJS.enc.Base64 ) ] = this.#password;
											
						//creating a whole lot of the password variable.
						let x;
						for( x = 0; x < 10; x++ ){
							this.s[ await this.generateKey(25) ] = await this.generateKey(25);
						}
						this.walletID 	= this.#note.walletID;						
						return await this.saveNote( this.#note );
						
						//assign the appropraite ranking for the user for logging in his note.
						//await this.scriptbillAssignRanks();
						//return await this.setCurrentNote();
					}else {
						if( ! this.l.string ) {
							this.l.string 	= await this.generateKey( 50 );
						}
						let string 		= CryptoJS.MD5( this.l.string ).toString( CryptoJS.enc.Base64 );
						
						if( ! this.l[ string ] ){
							this.l[ string ] = CryptoJS.MD5( "ONE" ).toString( CryptoJS.enc.Base64 );
						}
						else {
							let testString = this.l[ string ];
							let string1 	= CryptoJS.MD5( "ONE" ).toString( CryptoJS.enc.Base64 );
							
							//just logged in one times
							if( testString == string1 && this.alertDetails ){
								await this.createAlert("Wrong Password Input Detected For The Uploaded Note! You Have 3 More Times To Login on This Server, else Logging In Your Note Will Be Forfieted!!!");
								this.l[ string ] 	= CryptoJS.MD5( string1 ).toString( CryptoJS.enc.Base64 );
							}
							else {
								let string2 = CryptoJS.MD5( string1 ).toString( CryptoJS.enc.Base64 );
								//checking whether the note has been pre reported.
								let url		= new URL( this.#default_scriptbill_server );
								url.searchParams.set("notePattern", noteEncrypt.slice(0, 50));
								
								try {
									fetch( url ).then( response =>{
										return response.text();
									}).then( async result =>{
										if( this.isJsonable( result ) ){
											result 	= JSON.parse( result );
											
											if( result.reported == "TRUE" ){
												this.errorMessage("Can't Login this Note on this Server!");
												delete this.l.uploadedNote;
												return;
											} else {
												//logged in two times.
												if( testString == string2 && this.alertDetails ){
													await this.createAlert("Wrong Password Input Detected For The Uploaded Note! You Have 2 More Times To Login on This Server, else Logging In Your Note Will Be Forfieted!!!");
													this.l[ string ] 	= CryptoJS.MD5( string2 ).toString( CryptoJS.enc.Base64 );
												}
												else {
													let string3 = CryptoJS.MD5( string2 ).toString( CryptoJS.enc.Base64 );
												
													//logged in three times.
													if( testString == string3 && this.alertDetails ){
														await this.createAlert("Wrong Password Input Detected For The Uploaded Note! You Have 1 More Times To Login on This Server, else Logging In Your Note Will Be Forfieted!!!");
														this.l[ string ] 	= CryptoJS.MD5( string3 ).toString( CryptoJS.enc.Base64 );
													}
													else {
														let string4 = CryptoJS.MD5( string3 ).toString( CryptoJS.enc.Base64 );
												
														//logged in the last times.
														if( testString == string4 && this.alertDetails ){
															await this.createAlert("Wrong Password Input Detected For The Uploaded Note! Your Note Has Been Forfieted!!!. You Can't Log In Anymore To This Server!!!");
															delete this.l.uploadedNote;
															//reporting to the Scriptbank server.
															url 		= new URL( this.#default_scriptbill_server );
															url.searchParams.set("notePattern", noteEncrypt.slice(0, 50));
															url.searchParams.set("loginTime", this.currentTime());
															url.searchParams.set( "loginServer", window.location.origin );
															fetch( url );
															return false;
														}
													}
												}
											}
										} else {
											this.errorMessage("Scriptbank Servers Are Not Responding, Please Try Logging In Your Note Later.");
											return false;
										}
									});
								} catch(e){
									console.error(e);
									this.errorMessage("couldn't check note data " + e);
								}
								
								return false;
							}
						}
					}
						
						
				} else {
					this.errorMessage("No Password Input Was Detected!!!");
					//await this.createAlert("No Password Input Was Detected!!!");
					return false;
				}
							
			}
			else if( ! note && ! this.s.currentNote ){
				this.errorMessage("No Note Data was found while initializing Scriptbills");
				return false;
			}else if( this.isJsonable( this.s.currentNote ) ){			
				
				if( this.#password || password ) {
					if( ! this.#password && await this.l)
						this.#password = password;
					
					this.#note = await this.#getCurrentNote();
					this.walletID = this.#note.walletID;
					this.noteAddress = this.#note.noteAddress;
					let encryptP, hashedP;
					
					//await this.shareData();				
					await this.saveNote( this.#note );
					return this.s.currentNote;
				}
			} /* if( ! this.walletID && this.alertDetails ){
				this.walletID = await this.createPrompt("Please enter your Scriptbill Walvar id, required to use Scriptbill on Scriptbill website, leave empty to create a new Scriptbill Wallet", "SCRIPTBILLWALLET");
			} */
		} catch(e){
			//console.log( "not login note" );
			console.error(e);
			this.errorMessage(e.toString());
			return note;
		}
	}
	
	static async #getPassword( userInput = "", note = false ){
//		//console.log("getPassword running!!! " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length] );
		this.funcUp[ this.funcUp.length] = "#getPassword";
		try {
			if( ! this.binary && this.s.uploaded ){
				this.binary = await this.resolvePersistentData( this.s.uploaded, 'binaries', false );
			}
									
			if( ( this.l.uploadedNote || this.binary ) && ! this.#passwordKey && ( ! this.s.currentNote || ! this.isJsonable( this.s.currentNote ) ) ){
				
				//console.log( userInput == "" , ! this.s.user_input , this.alertDetails, this.s.user_input,  userInput);
				if( userInput == "" && ! this.s.user_input && this.alertDetails )
					userInput 	= await this.createPrompt("No Current Note Found Logged In, But an Uploaded Note was Found!, Please enter your Password For This Note.", "");
				
				if( userInput != "" || this.s.user_input  ) {
					
					if( ! userInput )
						userInput 		= this.s.user_input;
					
					this.l.user_pass   	= userInput;
					this.#password 		= await this.#generatePassword( userInput );
					//this.l.user_pass 		= this.#password;
					
					//if done with it we remove the input.
					if( this.s.user_input )
						delete this.s.user_input;
					
				} 
				
				//next we debinarilize the note.
				if( ! this.binary )
					this.binary 		= this.l.uploadedNote;
				
				let debinarilize 	= await this.debinarilize();
				
				//setting the password as private key to decrypt the note.
				var string 	= this.#password;
				
				//now let'this.s decrypt the note.
				note 		= this.decrypt( debinarilize, this.hashed( string ) );
				
				//the note must be jsonable for to be sure it was correctly decrypted.
				if( this.isJsonable( note ) ){
					this.#note 		= JSON.parse( note );
					
							
					//return the password gotten,
					return this.#password;
				} else {
					//return false; no password gotten and no note to generate the password for..
					return false;
				}			
			}  else if( this.s.currentNote && this.isJsonable( this.s.currentNote ) ){
				//console.log( "current note is true. Stored password: " + this.l.user_pass );
				note 		= JSON.parse( this.s.currentNote );
				
				if( this.l.user_pass || this.s.user_pass ){
					this.#password 		= this.#generatePassword( this.l.user_pass || this.s.user_pass );
					
					if( this.#password ){
						return this.#password;
					} else {
						this.errorMessage( "No Password was found logged in" );
						return false;
					}
				} else {
					this.errorMessage("no password was found logged in for note " + note.noteAddress + " We will be logging the note out to re login again.");
					delete this.s.currentNote;
					return false;
				}
			} else if( ( note || this.l.uploadedNote ) && ( ! this.s.currentNote || ! this.isJsonable( this.s.currentNote ) ) ){
					userInput 		= this.s.user_input;
					
					if( ! userInput && this.alertDetails )				
						userInput 		= await this.createPrompt("We couldn't find a password connected to this note. Please enter the password for this note", "");
					
					if( userInput != "" ){
						this.l.user_pass 	= userInput;
						this.#password 		= await this.#generatePassword( userInput );
						
						//this.l.user_pass 	= this.#password;
						return this.#password;
					} else {
						this.errorMessage("We couldn't retrieve the logged password key for this note " + note.noteAddress );
						return false;
					}
			} else {
				this.errorMessage("No Uploaded Note or Real Scriptbill Note Data was Found while trying to get password");
				return false;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	
	
	static async #generatePassword( userInput ){
		////console.log( "#generatePassword running " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length] );
		this.funcUp[ this.funcUp.length] = "#generatePassword";
		try {
			this.#password 		= CryptoJS.SHA256( CryptoJS.MD5( CryptoJS.SHA1( userInput ).toString( CryptoJS.enc.Base64 ) ).toString( CryptoJS.enc.Base64 ) + userInput ).toString( CryptoJS.enc.Base64 );	
					
			//console.log("Password generated " + this.#password );
			
			/* this.l.user_pass 				= this.#password;
			this.s.user_pass 				= this.#password; */				
			
			return this.#password;
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}//Mjd1SHhLVWJXbW5tMml2ckdwNm1JdU9XajlRbzFa
	
	static async #getCurrentNote(){		
		////console.log("getCurrentNote running " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length]);
		this.funcUp[ this.funcUp.length] = "getCurrentNote";
		let funcUp = this.funcUp[ this.funcUp.length];
		this.funcUp[ this.funcUp.length] = "getCurrentNote";
		try {		
			if( ! this.#password ){
				this.#password = await this.#getPassword();
			}
			
			let currentNote = false, note_data, decrypted, key;
			
			if( ( ! this.s.currentNote || ! this.isJsonable( this.s.currentNote ) ) ) {
				//console.log("chrome.storage", "current note");
				if( chrome && chrome.storage ){
					currentNote 	= await chrome.storage.session.get("currentNote");
					
					if( currentNote.currentNote && this.isJsonable( currentNote.currentNote ) ){
						//console.log( "returning", this.#password );
						currentNote 		= JSON.parse( currentNote.currentNote );
					} else {
						return false;
					}
				}
				 
			} else {
				currentNote 	= JSON.parse( this.s.currentNote );
			}
			
			if( ! this.#password ){
				return false;
			}
			
			//alert("checks 2");
			
			let persistentNote = await this.resolvePersistentData( "currentNote", "userNotes", false );
			
			if( this.isJsonable( persistentNote ) )
				persistentNote = JSON.parse( persistentNote );
			
			
			if( currentNote.transTime < persistentNote.transTime && currentNote.noteAddress == persistentNote.noteAddress )
				currentNote 		= JSON.parse( JSON.stringify( persistentNote ));
			
			var string 		= 	this.#password;			
			let pass 			= this.hashed( string );									
			this.blockID 		= currentNote.blockID;
			let stored 			= await window.navigator.storage.getDirectory("scriptStorage", {create: true}).catch( error =>{this.errorMessage( error.toString() );  return false;}), file, text;
			
			if( funcUp == "exchangeCredits" || ! this.currentNote ){
				
				this.#currentNote 		= await this.getCurrentExchangeNote( currentNote.noteType );			
				
				if( ! this.#currentNote ){
					//alert("checks 2");
					let block 			= await this.getTransBlock(1, {blockID: currentNote.blockID});
					
					if( ! block.length ){
						this.errorMessage("this note does note seem to be valid: " + currentNote.noteAddress + " Can't get current Note ");
						return false;
					}
					try {
						this.#currentNote 		= JSON.parse( JSON.stringify( block[0].exchangeNote ));
					} catch(e){
						console.error(e);
						this.errorMessage("Can't current note from current note's block: " + currentNote.noteAddress );
						return false;
					}
				}
			}
			else {
				this.#currentNote = JSON.parse( JSON.stringify( this.currentNote ));
				delete this.currentNote;
			}
			
			//this shows that the keys weren't encrypted...a bad practice though because it exposes the privatekeys in the note.
			if( typeof currentNote.profitKeys == 'object' && typeof currentNote.noteBudgets == 'object' && typeof currentNote.noteProducts == 'object' && typeof currentNote.noteSubs == 'object' && typeof currentNote.agreements == 'object' ) {
				this.#note = JSON.parse( JSON.stringify( currentNote ));
				let realNote 	= JSON.parse( JSON.stringify( note ));
		
				delete realNote.noteSign;
				delete realNote.noteHash;
				delete realNote.transHash;
				
				var string 		= JSON.stringify( realNote );
				this.#noteHASH 	= this.hashed( string );
				return currentNote;
			}
			
			for( key in currentNote ){
				note_data = currentNote[ key ];
				
				if( key == 'noteSecret' ){
					currentNote.noteSecret = this.decrypt( note_data, pass );
					//await file.remove();
				}
				else if( key == 'budgetID' ){
					if( ! this.saveOnNote ){
						file 					= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 					= await file.getFile();
						text					= await file.text();
						
						decrypted 				= this.decrypt( text, pass );
						currentNote.budgetID 	=  decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.budgetID 	=  decrypted;
					}
					
					//await file.remove();
				}
				else if( key == 'blockKey' ) {
					currentNote.blockKey = this.decrypt( note_data, pass );
				}
				else if( key == 'profitKeys' ) {
					if( ! this.saveOnNote ){
						file 					= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 					= await file.getFile();
						text					= await file.text();
						
						decrypted 				= this.decrypt( text, pass );
						currentNote.profitKeys 	= this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.profitKeys 	=  this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					}
					
					//await file.remove();
				}
				else if( key == 'noteProducts' ){
					if( ! this.saveOnNote ){
						file 						= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 						= await file.getFile();
						text						= await file.text();
						
						decrypted 					= this.decrypt( text, pass );
						currentNote.noteProducts 	= this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.noteProducts 	=  this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					}
					
					//await file.remove();					
				}
				else if( key == 'noteBudgets' ){
					if( ! this.saveOnNote ){
						file 						= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 						= await file.getFile();
						text						= await file.text();
						
						decrypted 					= this.decrypt( text, pass );
						currentNote.noteBudgets 	= this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.noteBudgets 	=  this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					}
					
					//await file.remove();
				}
				else if( key == 'agreements' ){
					if( ! this.saveOnNote ){
						file 						= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 						= await file.getFile();
						text						= await file.text();
						
						decrypted 					= this.decrypt( text, pass );
						currentNote.agreements 	= this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.agreements 	=  this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					}
					
					//await file.remove();
				}
				else if( key == 'noteSubs' ){
					if( ! this.saveOnNote ){
						file 						= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 						= await file.getFile();
						text						= await file.text();
						
						decrypted 					= this.decrypt( text, pass );
						currentNote.noteSubs 		= this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.noteSubs 	=  this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					}
					
					//await file.remove();
				}
				else if( key == 'unfulfilled' ){
					if( ! this.saveOnNote ){
						file 						= await stored.getFileHandle( note_data.toString().replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
						if( ! file ) continue;
						
						file 						= await file.getFile();
						text						= await file.text();
						
						decrypted 					= this.decrypt( text, pass );
						currentNote.unfulfilled 	= this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					} else {
						decrypted 				= this.decrypt( note_data, pass );
						currentNote.unfulfilled 	=  this.isJsonable( decrypted ) ? JSON.parse( decrypted ) : decrypted;
					}
					
					//await file.remove();
				}
			}
			//console.log( "CURRENT NOTE GOTTEN: " + JSON.stringify( currentNote ), "TYPEOF: " + typeof currentNote );
			this.#note = JSON.parse( JSON.stringify( currentNote ));
			delete currentNote.noteHash;
			delete currentNote.transHash;
			delete currentNote.noteSign;
			var string = JSON.stringify( currentNote );
			this.#noteHASH	= this.hashed( string );
			return this.#note;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async #generateMotherKeys( noteType = false ){		
		
		let type, retype, currency, block, motherKeys;
		
		try{
			if( this.motherKeysURL ){
				motherKeys = await fetch(this.motherKeysURL).then( resp =>{
					return resp.text();
				}).then( keys =>{
					if( this.isJsonable( keys ) )
						keys = JSON.parse( keys );
					else 
						keys = false;
					
					return keys;
				});
			} else {
				motherKeys = await fetch('/motherKeys.json').then( resp =>{
					return resp.text();
				}).then( keys =>{
					if( this.isJsonable( keys ) )
						keys = JSON.parse( keys );
					else 
						keys = false;			
					
					return keys;
				});
			}
				
			if( motherKeys && motherKeys.noteAddresses ){
				this.#motherKeys 	= JSON.parse( JSON.stringify( motherKeys ) );
				return this.#motherKeys;
			} else {
				motherKeys = await fetch(this.#default_scriptbill_server + '/motherKeys.json').then( resp =>{
					return resp.text();
				}).then( keys =>{
					if( this.isJsonable( keys ) )
						keys = JSON.parse( keys );
					else 
						keys = false;
					return keys;
				});
				if( motherKeys )
					this.#motherKeys 	= JSON.parse( JSON.stringify( motherKeys ) );
				
				return this.#motherKeys;
			}			
		} catch(e) {
			
			motherKeys = await fetch(this.#default_scriptbill_server + 'motherKeys.json').then( resp =>{
					return resp.text();
				}).then( keys =>{
					//console.log( keys );
					if( this.isJsonable( keys ) )
						keys = JSON.parse( keys );
					else 
						keys = false;
					
					return keys;
				});
				
			if( motherKeys && motherKeys.noteAddresses ){
				this.#motherKeys 		= JSON.parse( JSON.stringify( motherKeys ) );
				return this.#motherKeys;
			} else {
				this.errorMessage("Mother Keys Not Found....Generating Default Keys For Scriptbank Exchange Notes.");
				if( ! this.#motherKeys ){
					this.#motherKeys = {};
				
					this.#motherKeys.noteAddresses = {};
					this.#motherKeys.budgetIDS		= {};
				} else {
					if( Object.keys( this.#motherKeys ).length >= Object.keys( this.#fiatCurrencies ) ){
						if( noteType && this.#motherKeys[ noteType ] ){
							return this.#motherKeys[ noteType ];
						}
						return this.#motherKeys;
					}				
				}
				
				let note = JSON.parse( JSON.stringify( this.#note ));
						
				for( type in this.#fiatCurrencies ){
					
					setTimeout( async (type)=>{
						retype 			= type + "CRD";
						this.noteTypeS 	= retype;
						block       	= await this.getTransBlock(1);
						currency 		= this.#fiatCurrencies[ type ];
						this.#motherKeys[ retype ] = await this.generateKey(0, true);
						
						/* var string = "SCRIPTBANKCREDITNOTE" + currency;
						var string = this.hashed( string ); */
						if( ! this.#motherKeys.budgetIDS )
							this.#motherKeys.budgetIDS = {};
						
						this.#motherKeys.budgetIDS[retype] 		= await this.generateKey(0, true);
						
						//assuring the settin of noteAddresses
						if( ! this.#motherKeys.noteAddresses )
							this.#motherKeys.noteAddresses  = {};
						
						if( block && block[0] && block[0].exchangeNote && block[0].blockID && block[0].exchangeNote.exchangeKey ){
							this.#motherKeys.noteAddresses[ retype ] = block[0].exchangeNote.exchangeKey;
							this.#isExchangeMarketMining = true;
							formerBlock = JSON.parse( JSON.stringify( block ));
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( this.#motherKeys[ retype ], id );
							formerBlock.exchangeNote.motherKey = await this.getPublicKey(id);
							await this.setPrivateKey( this.#motherKeys.budgetIDS[ retype ], id );
							formerBlock.exchangeNote.budgetID = await this.getPublicKey(id, true);
							this.#note = JSON.parse( JSON.stringify( block[0].exchangeNote ));
							this.#note.noteAddress = block[0].exchangeNote.exchangeID;
							this.#note.noteSecret = block[0].exchangeNote.exchangeKey;
							this.#note.noteType 	= retype;
							this.details 		= JSON.parse( JSON.stringify( this.defaultBlock ));
							this.details.transType = "UPDATE";
							this.details.transValue = 0;
							await this.generateScriptbillTransactionBlock();							
						}						
						else				
							this.#motherKeys.noteAddresses[ retype ] = await this.generateKey(0, true);
						
						
						
						/* var string 	= "SCRIPTBANKCREDITBUDGET" + currency.toUpperCase();
						var string 	= this.hashed( string ); */
						
					}, 2000, type );
					
				}
				setTimeout( ()=>{
					this.download( JSON.stringify( this.#motherKeys ), 'motherKeys.json' );
				},(( Object.keys( this.#fiatCurrencies).length * 2000 ) + 5000 ) );
					
				
			}
		}
		
		if( noteType && this.#motherKeys[ noteType  ] )
			return this.#motherKeys[ noteType ];
		
		return this.#motherKeys;
	}
	
	static async checkStorage(){
		let session 		= await window.navigator.storage.getDirectory("sessionStorage", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		if( session ){
			let s = this.s;
			this.s = {};
			for( let value in s ){
				this.s[value] = s[value];
			}
			//loop the sessionstorage handle to get data from.
			for await (let [name, handle] of session.entries()) {
				if( handle.kind == "file"){
					this.s[name]	= await handle.getFile().then( file =>{
						return file.text();
					});					
				}
			}
		}
		
		let local 		= await window.navigator.storage.getDirectory("localStorage", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		
		if( local ){
			let l = this.l;
			this.l = {};
			for( let value in l ){
				this.l[value] = l[value];
			}
			//loop the sessionstorage handle to get data from.
			for await (let [name, handle] of local.entries()) {
				if( handle.kind == "file"){
					this.s[name]	= await handle.getFile().then( file =>{
						return file.text();
					});					
				}
			}
		}
		
		let inter = setInterval( async ()=>{
			let len = Object.keys( this.s ).length > Object.keys( this.l ).length;
			let value, write, uploads, file;
			
			if( len )
				len = Object.keys( this.l ).length;
			else
				len = Object.keys( this.s ).length;
			for( let x = 0; x < len; x++ ){
				value = Object.keys( this.l )[x];
				var regex 	= /^[a-zA-Z0-9!@#\$%\^\&*\)\(+=._-]+$/g;
				if( value ) {
					file 	= value;
					value 	= value.replaceAll(regex, "").replaceAll('=', '').replaceAll('/','');
					//console.log( value );
					uploads = await local.getFileHandle(value+".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					//console.log( uploads );
					write	= await uploads.createWritable();
					await write.write( this.l[file] );
					await write.close();					
				}
				
				value = Object.keys( this.s )[x];
				
				if( ! value ) continue;
				
				file 	= value;
				value 	= value.replaceAll(regex, "").replaceAll('=', '').replaceAll('/','');
				//console.log( value );
				uploads = await session.getFileHandle(value +".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
				if( this.s[file] ){
					write	= await uploads.createWritable();
					await write.write( this.s[file] );
					await write.close();
				}				
			}
			
		}, 5000);
		
	}
	
	static getSendTransactionTypes(){
		return this.#transSend;
	}
	static getRecieveTransactionTypes(){
		return this.#transRecieve;
	}
	static getOtherTransactionTypes(){
		return this.#otherTrans;
	}
	
	static async cancelTransaction( blockID, isSign = false ){
		this.blockID 	= blockID;
		let block 		= await this.getTransBlock();
		
		if( ! block[0].blockID )
			return false;
		
		block 			= block[0]; 	
		
		if( ( ! block || ! block.blockRef )&& ( ! this.#transSend.includes( block.transType ) || ! this.#transRecieve.includes( block.transType ) || block.transType != "SPLIT" || block.transType != "MERGE" ) )
			return false;
		
		this.blockRef 		= block.blockRef;
		let refBlock 		= await this.getTransBlock(10, {blockRef: block.blockRef});
		
		if( refBlock.length ){
			let agreements = false;
			for( let x = 0; x < refBlock.length; x++ ){
				if( refBlock[x] && refBlock[x].blockID && block.blockID != refBlock[x].blockID ){
					agreements = JSON.parse( JSON.stringify( refBlock[x].agreements ));
					
					for( let agreeID in agreements ){
						if( agreements[agreeID].senderID == block.blockID ){
							this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
							this.details.recipient = refBlock[x].blockKey;
							
							if( isSign && block.transType == "AGREEMENTREQUEST" ){
								this.details.transType = "AGREEMENTSIGN";
								this.response = JSON.parse( JSON.stringify( block ));
							}
							else if( isSign )
								this.details.transType = "AGREEMENTREQUEST";
							
							else
								this.details.transType = "CANCELLED";
							
							this.detail.transValue = 0;
							this.details.agreement = JSON.parse( JSON.stringify( agreements[agreeID] ));
							this.response 			= JSON.parse( JSON.stringify( refBlock[x] ));
							block = await this.generateScriptbillTransactionBlock( this.details, this.#note );
							break;
						}
					}
				}
			}
		}

		return block;
	}
	/*
		This function helps advertisers create adverts into the Scriptbill Database system
		different application will handle advert blocks differently
	*/
	
	static adsConfig = {
		advertID : "",//this carries the id of the advert to be created
		productID : "",//this carries the product that the advert is promoting
		viewers		: 1, //number of viewers you are planning to send this advert to.
		viewersShare : 0.2,//this is the rate of the transvalue going to viewers.
		publishers 	: 1, //number of publishers you want to show this advert to.
		publishShare 	: 0.5,//rate of advert funds going to publishers.
		scope 		: "WORLD", //this is the name of the area the advert will be shown to, people not living in this area won't participate in the view or view share of the advert.
		banner 		: "",//this is the url of the banner that this advert represent.
		video 		: "",//this is the url of the video that will show this ads.
		interest 	: [],//an array of interest that you are targetting with your advert
	};
	static async createAdvert(value){
		if( ! this.#note && this.s.currentNote )
			this.#note 		= await this.#getCurrentNote();
		
		if( ! this.#note ){
			this.errorMessage("A note data is needed to run adverts");
			return false;
		}
		
		if( ! value || isNaN( parseFloat( value ) ) ) {
			this.errorMessage("Value to be sent to advertisers must be set");
			return false;
		}
		
		if( ! this.#note.noteValue || this.#note.noteValue < value ){
			this.errorMessage("Note Value too low to run adverts");
			return false;
		}
		
		//checking the adsConfig that must be set by the user from the front end before 
		//running this advert.
		if( ! this.adsConfig.productID ){
			this.errorMessage("No Product to promote in your advert request");
			return false;
		}
		
		let product 		= await this.getTransBlock(1, {productID: this.adsConfig.productID });
		
		if( ! product.length ){
			this.errorMessage("Product supplied does not exist in the Scriptbill Database System");
			return false;
		}
		
		//creating the advert.
		this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ));
		this.details.transValue 	= value;
		this.details.transType 		= "ADVERT";
		this.details.agreement 		= JSON.parse( JSON.stringify( this.adsConfig ));
		
		//the advert id is just a way of identifying the advert on the Scriptbill database system, so an identification of advert id in the request makes the transaction an automatic update transaction.
		if( ! this.details.agreement.advertID || this.details.agreement.advertID.length != 24 )		
			this.details.agreement.advertID = await this.generateKey(24);
		
		let block 					= await this.generateScriptbillTransactionBlock( this.details, this.#note );
		
		if( block && block.transType == "ADVERT" ){
			this.successMessage("Advert succcessfully created with ID: " + block.blockID);
			return block;
		} else {
			this.errorMessage("We encountered error creating your advert");
			return false;
		}
	}
	
	static async createAgreement(agreeID = "", newBlock = false, preSign = true ){
		
		try {
			/* if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote )) {
				this.#note 			= await this.#getCurrentNote();
			} */
			
			let agreement = JSON.parse( JSON.stringify( this.defaultAgree ) );
			let agreeKey 	= await this.generateKey(10, true );
			var id 			= await this.generateKey(10);
			await this.setPrivateKey( agreeKey, id );
			
			
			agreement.agreeID 	= await this.generateKey( 15, true, true );
			agreement.agreeTime = this.currentTime();
			
			agreement.agreeKey 	= await this.getPublicKey(id);
			agreement.agreeSign	= await this.Sign(agreement.agreeID, agreement.agreeTime);
			await this.setPrivateKey( agreement.agreeID, id );
			agreement.agreeSignKey 	= agreement.agreeID;
			agreement.agreeID		= await this.getPublicKey(id, true);
			
			/* if( this.#note && this.#note.agreements && typeof this.#note.agreements == "object" && typeof this.#note.agreements.length == "number" ){
				this.#note.agreements.push( agreeKey )
			} */
			agreement.privateKey 			= agreeKey + "----" + agreement.agreeSignKey;
			delete agreement.agreeSignKey;

			if( newBlock && newBlock.blockID )
				agreement.senderID 		= newBlock.blockID;
			
			else if( this.newBlock && this.newBlock.blockID )
				agreement.senderID 		= this.newBlock.blockID;
			
			if( agreement.senderID && preSign ){
				agreement.senderKey 	= await this.generateKey(15, true, true );
				agreement.senderSign    = await this.Sign(agreement.sendKey, agreement.senderID );
				var id 				= await this.generateKey(10);				
				await this.setPrivateKey( agreement.senderKey, id );
				agreement.senderSignKey = agreement.senderKey;
				agreement.senderKey 	= await this.getPublicKey( id, true );
			}
			agreement.timeStamp 	= this.currentTime();
			this.#createdAgreement 	= JSON.parse( JSON.stringify( agreement ));
			//every other value should be set directly to the defaultAgree handler 
			//before or after running this function.
			return agreement;
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return agreement;
		}
	}
	
	static async verifyAgreement(agreement){
		if( typeof agreement != "object" || ! agreement.agreeID ) return agreement;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote )) {
			this.#note 			= await this.#getCurrentNote();
		}
		
		return agreement;
	}
	
	static async #manageClientSpace(){
		const request = indexedDB.open('scriptbillDatabase', 1 );
		request.onerror = (event) => {
			this.errorMessage(`Database error: ${event.target.errorCode}`);
		};

		request.onsuccess = (event) => {
			// add implementation here
			let db = event.target.result;
			
			//creating the transaction object.
			let transaction = db.transaction(["Transactions", "Exchange", "Budgets", "Agreements", "Products"], "readwrite");
			
			//first we look at our localStorage to see if there will be any block Data
			//to store.
			//this is expected to store all the transaction times of blocks stored on
			//this client
			let transTimes 	= this.l.TRANSTIMES;
			
			//testing to see if the transTime exists or has already been deleted by This
			//function
			if( transTimes && this.isJsonable( transTimes ) ){
				//await this.createAlert("request running");
				transTimes 		= JSON.parse( transTimes );
				
				//we'll need to loop through all the object and deleting as we Go
				//our getTransBlock function will also look at our this.ll Variable
				//to find data apart from looking at the note's server for data.
				let time, blockIDs, block, budget, agreement, exNote, product;
				for( time in transTimes ){
					//always stored as an array
					blockIDs 	= transTimes[ time ];
					
					blockIDs.forEach( blockID =>{
						//checking if the block is available in the storage.
						if( blockID && this.l[blockID] && this.isJsonable(this.l[blockID]) ){
							block 	= JSON.parse( this.l[blockID] );
							this.storage[blockID] = this.l[blockID];
							if( ( block.transType == "CREATEBUDGET" || block.transType == "UPDATEBUDGET" ) && block.agreement && typeof( block.agreement ) == 'object' ){
								budget 		= JSON.parse( JSON.stringify( block.agreement ) );
								block.agreement = budget.budgetID;
								
								//checking the budget agreement.
								if( budget.agreement && typeof( budget.agreement ) == 'object' ){
									agreement 	= JSON.parse( JSON.stringify( budget.agreement ) );
									budget.agreement  = agreement.agreeID;
									
									//save the budget agreement since found.
									transaction.objectStore("Agreements").put( agreement );
								}
								
								//save the budget found
								transaction.objectStore("Budgets").put( budget );
							}
							//dealing with products
							else if( ( block.transType == "CREATEPRODUCT" || block.transType == "UPDATEPRODUCT" || block.transType == "BUYPRODUCT" || block.transType == "PRODUCTSUB" ) && block.agreement && typeof( block.agreement ) == 'object' && block.productID ) {
								product 		= JSON.parse( JSON.stringify( block.agreement ) );
								
								if( product.productConfig ){
									agreement 	= JSON.parse( JSON.stringify( product ) );
									product 	= JSON.parse( JSON.stringify( product.productConfig ) );
									delete agreement.productConfig;
									product.productID 	= block.productID;
									product.agreeID 	= agreement.agreeID;
									agreement.productID = product.productID;

									//save the product
									transaction.objectStore("Products").put( product );
									
									//save the agreement
									transaction.objectStore("Agreements").put( agreement );
									block.agreement  = agreement.agreeID;
								}
								
							}
							//saving the agreement on the block 
						    else if( block.agreement && typeof block.agreement == "object" ) {
								agreement 	= JSON.parse( JSON.stringify( block.agreement ) );
								
								//saving the agreement if the agreement ID is set.
								if( agreement.agreeID ){
									transaction.objectStore("Agreements").put( agreement );
									block.agreement = agreement.agreeID;
								}							
							}
							
							//dealing with the exchange Notes
							if( block.exchangeNote && typeof( block.exchangeNote ) == 'object'){
								exNote 		= JSON.parse( JSON.stringify( block.exchangeNote ) );
								
								if( exNote && exNote.exchangeID ){
									block.exchangeNote 	= exNote.exchangeID;
									
									//console.log( "exNote: " + JSON.stringify( exNote ) );
									
									//saving the exchange information.
									transaction.objectStore("Exchange").put( exNote );
								}								
							}
							
							//saving the block after all the other objects on the BLOCK
							//are stored.
							transaction.objectStore("Transactions").put(block);
							
							//delete the block from the local storage.
							//delete this.l[blockID];
							
							let lStr = JSON.stringify( this.l );
							
							if( lStr.length >= 4000000 )
								delete this.l[blockID];
						}
					});				
				}
			}
			
			//next is to get all available block from indexedDB and set it to the 
			//storage variable at run time to be accessed by the getTransBlock function.
			//this function is also capable of getting data from the client's note 
			//server.
			let transStore 	= transaction.objectStore("Transactions");
			let transRequest = transStore.openCursor();						
			
			transRequest.onsuccess = function(){
				
				let cursor 		= transRequest.result, block, exNote, agreement, product, budget;
				
				if( cursor ){
					
					block 		= cursor.value;
					
					if( block.exchangeNote && typeof block.exchangeNote == "string"){
						exNote 		= transaction.objectStore("Exchange").get( block.exchangeNote );
						
						if( exNote && exNote.exchangeID && exNote.exchangeID == block.exchangeNote ){
							block.exchangeNote = JSON.parse( JSON.stringify( exNote ) );
						}
					}
					
					//checking if the block is a budget block.
					if( block.transType && ( block.transType == "CREATEBUDGET" || block.transType == "UPDATEBUDGET" ) && block.agreement && typeof block.agreement == "string" ) {
						budget 		= transaction.objectStore("Budgets").get( block.agreement );
						
						if( budget && budget.budgetID && budget.agreement && typeof budget.agreement == "string" ){
							agreement 	= transaction.objectStore("Agreement").get( budget.agreement );
							
							if( agreement && agreement.agreeID ){
								
								//add the budget agreement to the budget.
								budget.agreement 	= JSON.parse( JSON.stringify( agreement ) );
							}
							
							//add the budget to the block
							block.agreement 	= JSON.parse( JSON.stringify( budget ) );
						}						
					}
					else if( ( block.transType == "CREATEPRODUCT" || block.transType == "UPDATEPRODUCT" || block.transType == "BUYPRODUCT" || block.transType == "PRODUCTSUB" ) && block.agreement && typeof( block.agreement ) == 'string' && block.productID ) {
						//getting the agreement on the block.
						agreement 	= transaction.objectStore("Agreements").get( block.agreement );
						
						if( agreement && agreement.agreeID && agreement.productID ){
							product = transaction.objectStore("Products").get( agreement.productID );
							
							if( product && product.productID ){
								
								//delete the productID from the agreement.
								delete agreement.productID;
								
								//add the product to the productConfig handler of the agreement.
								agreement.productConfig = JSON.parse( JSON.stringify( product ) );
								
								//add the agreement to the block.
								block.agreement 		= JSON.parse( JSON.stringify( agreement ) );
							}
						}
					}
					//checking for any other block with agreement on it.
					else if( block.agreement && typeof block.agreement == "string" ){
						agreement = transaction.objectStore("Agreements").get( block.agreement );
						
						if( agreement && agreement.agreeID ){
							//add the agreement to the block.
							block.agreement 	= JSON.parse( JSON.stringify( agreement ) );
						}
					}
					
					if( ! this.storage )
						this.storage = {};
					
					//adding the block to the storage handler of this class.

					this.storage[ block.blockID ] = JSON.parse( JSON.stringify( block ) );
					cursor.continue();
				} 				
			};
		};
		 // create the Contacts object store and indexes
		 request.onupgradeneeded = (event) => {
			 let db = event.target.result;

			 // create the Contacts object store 
			 // with auto-increment id
			 let trans = db.createObjectStore('Transactions', {
				 autoIncrement: true, 
				 keyPath: 'blockID'
			 });

			 // create an index on the email property
			trans.createIndex('blockID', 'blockID', {
				 unique: true
			 });
			 // create an index on the email property
			trans.createIndex('productID', 'productID', {
				 unique: false
			 });// create an index on the email property
			trans.createIndex('budgetID', 'budgetID', {
				 unique: false
			 });// create an index on the email property
			trans.createIndex('exBlockID', 'exBlockID', {
				 unique: true
			 });// create an index on the email property
			trans.createIndex('productBlockID', 'productBlockID', {
				 unique: true
			 });
			 // create an index on the email property
			trans.createIndex('noteType', 'noteType', {
				 unique: false
			 });
			 // create an index on the email property
			trans.createIndex('transType', 'transType', {
				 unique: false
			 });
			 // create an index on the email property
			trans.createIndex('transValue', 'transValue', {
				 unique: false
			 });
			 // create an index on the email property
			trans.createIndex('noteValue', 'noteValue', {
				 unique: false
			 });
			 // create an index on the email property
			trans.createIndex('blockRef', 'blockRef', {
				 unique: false
			 });
			 // create an index on the email property
			trans.createIndex('signRef', 'signRef', {
				 unique: false
			 });
			 // create an index on the email property
			trans.createIndex('noteSign', 'noteSign', {
				 unique: true
			 });
			 // create an index on the email property
			trans.createIndex('walletSign', 'walletSign', {
				 unique: true
			 });
			 
			 let exchangeNote = db.createObjectStore('Exchange', {
				 autoIncrement: true,
				 keyPath: 'exchangeID'
			 });

			 // create an index on the email property
			exchangeNote.createIndex('exchangeID', 'exchangeID', {
				 unique: true
			 });
			 // create an index on the email property
			exchangeNote.createIndex('exchangeKey', 'exchangeKey', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('budgetID', 'budgetID', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('blockID', 'blockID', {
				 unique: true
			 });
			 // create an index on the email property
			exchangeNote.createIndex('noteType', 'noteType', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('transType', 'transType', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('transValue', 'transValue', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('noteValue', 'noteValue', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('demandValue', 'demandValue', {
				 unique: false
			 });
			 // create an index on the email property
			exchangeNote.createIndex('exchangeValue', 'exchangeValue', {
				 unique: false
			 });
			 
			 let budgets = db.createObjectStore('Budgets', {
				 autoIncrement: true,
				 keyPath: 'budgetID'
			 });

			 // create an index on the email property
			budgets.createIndex('budgetID', 'budgetID', {
				 unique: true
			 });
			 // create an index on the email property
			budgets.createIndex('name', 'name', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('value', 'value', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('agreeID', 'agreeID', {
				 unique: true
			 });
			 // create an index on the email property
			budgets.createIndex('budgetType', 'budgetType', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('budgetCredit', 'budgetCredit', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('stockID', 'stockID', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('budgetSign', 'budgetSign', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('budgetRef', 'budgetRef', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('budgetSpread', 'budgetSpread', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('orientation', 'orientation', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('workingPartner', 'workingPartner', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('workingPartnerShare', 'workingPartnerShare', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('sleepingPartner', 'sleepingPartner', {
				 unique: false
			 });
			 // create an index on the email property
			budgets.createIndex('sleepingPartnerShare', 'sleepingPartnerShare', {
				 unique: false
			 }); 
			 
			 let agreement = db.createObjectStore('Agreements', {
				 autoIncrement: true,
				 keyPath: 'agreeID'
			 });

			 // create an index on the email property
			agreement.createIndex('agreeID', 'agreeID', {
				 unique: true
			 });
			 // create an index on the email property
			agreement.createIndex('value', 'value', {
				 unique: false
			 });
			 // create an index on the email property
			agreement.createIndex('agreeType', 'agreeType', {
				 unique: false
			 });
			 // create an index on the email property
			agreement.createIndex('ExecTime', 'ExecTime', {
				 unique: false
			 });
			 // create an index on the email property
			agreement.createIndex('maxExecTime', 'maxExecTime', {
				 unique: false
			 });
			 // create an index on the email property
			agreement.createIndex('isPeriodic', 'isPeriodic', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('senderID', 'senderID', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('recieverID', 'recieverID', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('payPeriod', 'payPeriod', {
				 unique: false
			 });
			 // create an index on the email property
			agreement.createIndex('interestType', 'interestType', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('interestSpread', 'interestSpread', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('interestRate', 'interestRate', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('quoteID', 'quoteID', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('payTime', 'payTime', {
				 unique: false
			 });
			 // create an index on the email property
			 agreement.createIndex('timeStamp', 'timeStamp', {
				 unique: false
			 });
			 
			 let product = db.createObjectStore('Products', {
				 autoIncrement: true,
				 keyPath: 'productID'
			 });

			 // create an index on the email property
			 product.createIndex('productID', 'productID', {
				 unique: true
			 });
			 // create an index on the email property
			 product.createIndex('value', 'value', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('productType', 'productType', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('totalUnits', 'totalUnits', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('units', 'units', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('name', 'name', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('description', 'description', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('budgetID', 'budgetID', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('productURL', 'productURL', {
				 unique: false
			 });
			 // create an index on the email property
			 product.createIndex('creationTime', 'creationTime', {
				 unique: false
			 });			
		 };
		 
		 request.onerror = function( event ){
			 
		 };
		 
	}
	
	static test(){
		//console.log("this: " + this);
		return "data";
	}
	
	
	static async getCurrentExchangeNote( noteType = false ){
		if( this.#note && ! this.noteTypeD && ! noteType ){
			noteType = this.#note.noteType;
		} else if( this.noteTypeD && ! noteType )
			noteType = this.noteTypeD;
		else if( ! noteType ){
			this.errorMessage('No NoteType Parameter Found While Fetching an ExchangeNote' );
			return false;
		}
		
		//alert("checks 2");
		
		let testType 		= noteType.slice( 0, noteType.lastIndexOf("CRD") );
		let url 			=  this.#note ? this.#note.noteServer : this.#default_scriptbill_server;
		url    				= new URL( url );
		url.searchParams.set("scriptbillPing", "true");
		
		let ping 			= await fetch( url.href ).then( resp =>{ return resp.text();}).catch( error =>{ console.error( error ); return false;});

		console.log("check ping: ", ping )
		
		if( ! ping || ! ping.isScriptbillServer ){
			
			url 			= new URL( this.#default_scriptbill_server );
		}
			
		
		url.searchParams.set("exchangeNote", noteType);
		url.searchParams.set("noteTypeBase", "TRUE");
		let note 			= await fetch( url.href ).then( resp =>{ return resp.text();}).catch( error =>{ console.error( error ); return false;}); 

		console.log("check note: ", note );
		
		if( ( ! note || ! note.exchangeID ) && this.#currentNote && this.#currentNote.noteType == noteType && this.#currentNote.exchangeID && this.#currentNote.budgetID ){
			note = JSON.parse( JSON.stringify( this.#currentNote ) );
		}
		else if( ( ! note || ! note.exchangeID ) && this.l && this.l[ noteType + "ExchangeNote" ] ){
			note 	= JSON.parse( this.l[ noteType + "ExchangeNote" ] );
		} else {
			 if( ( ! note || ! note.exchangeID ) && this.#fiatCurrencies[ testType ] ){
				this.#currentNote					= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ) );
				this.#currentNote.noteType 			= noteType;
				this.#currentNote.withdrawAccount 	= {accountType: "BTC", accountDetails: this.#ScriptbankAccounts[ Math.round( Math.random() * this.#ScriptbankAccounts.length ) ]};
				let motherKeys 		= await this.#generateMotherKeys();
				//console.log( motherKeys );
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( motherKeys[ noteType ], id );
				this.#currentNote.motherKey 		= await this.getPublicKey(id);
				this.#currentNote.creditType 		= "fiat";
				//console.log("Block is not true, reverting back to Scriptbank default fiat");
				//calculating the exchange IDs
				let privKey 			= motherKeys.noteAddresses[ noteType ];
				await this.setPrivateKey( privKey, id );
				let pubKey 				= await this.getPublicKey(id);
				this.#currentNote.exchangeID 	= pubKey;
				this.#currentNote.noteSecret  	= privKey;
				this.#currentNote.exchangeKey	= privKey;
				this.#currentNote.noteAddress 	= pubKey;
				var string = "SCRIPTBANKFIATEXCHANGEWALLET";
				this.#currentNote.walletID 		= this.hashed( string );
				privKey 		= motherKeys.budgetIDS[ note.noteType ];
				await this.setPrivateKey( privKey, id );
				this.#currentNote.budgetID 		= await this.getPublicKey(id);
				note 							= JSON.parse( JSON.stringify( this.#currentNote ));
			}
		}
		
		return note;
	}
	//this function is just a debugging function nd won't be used in production.
	static async getCurrentNote(){
		if( ! this.s.currentNote ) return false;
		
		return await this.#getCurrentNote();
	}
	
	static encrypt( data, key ){
		let func = this.funcUp[ this.funcUp.length - 1];
		//console.log( "encrypt2 running " + func );
		this.funcUp[ this.funcUp.length] = "encrypt2";
		
		if( ! CryptoJS ) return data;
		
		//console.log( "data: " + data, "key: " + key );
		
		if( ! key || ! data ) return data;
		
		key = btoa( key );
		
		try {		
			let encrypt 	= CryptoJS.AES;
			let encryptTwo 	= CryptoJS.Rabbit;
			
			return encryptTwo.encrypt( encrypt.encrypt( data, key ).toString(), key ).toString();
		} catch(e){
			console.error(e);
			return data;			
		}		
	}
	
	static decrypt( data, key ){
		
		//console.log("Func that ran this: ", this.funcUp[ this.funcUp.length - 1 ] );
		this.funcUp[ this.funcUp.length ] = "decrypt2";
		
		if( ! CryptoJS ) return data;
		
		if( ! key || ! data ) return data;
		
		//console.log('data: ' + data, 'key: ' + key );
		
		key = btoa( key );
		
		try {
		
			let decrypt 	= CryptoJS.AES;
			let decryptTwo 	= CryptoJS.Rabbit;
			return decrypt.decrypt( decryptTwo.decrypt( data, key ).toString( CryptoJS.enc.Utf8 ), key ).toString( CryptoJS.enc.Utf8 );
		} catch(e){
			console.error(e);
			return data;
		}
	}
	
	
	static async getAllStorageSyncData() {
		// Immediately return a promise and start asynchronous work
		 return new Promise((resolve, reject) => {
			// Asynchronously fetch all data from storage.sync.
			chrome.storage.sync.get(null, (items) => {
			  // Pass any observed errors down the promise chain.
			  if (chrome.runtime.lastError) {
				return reject(chrome.runtime.lastError);
			  }
			  // Pass the data retrieved from storage down the promise chain.
			  resolve(items);
			});
		});
	}
	
	static async getAllStorageSessionData() {
		// Immediately return a promise and start asynchronous work
		 return new Promise((resolve, reject) => {
			// Asynchronously fetch all data from storage.sync.
			chrome.storage.session.get(null, (items) => {
			  // Pass any observed errors down the promise chain.
			  if (chrome.runtime.lastError) {
				return reject(chrome.runtime.lastError);
			  }
			  // Pass the data retrieved from storage down the promise chain.
			  resolve(items);
			});
		});
	}
	
	
	
	static async setCurrentNote( note = false ){
		////console.log(" setCurrentNote running " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length] );
		this.funcUp[ this.funcUp.length] = "setCurrentNote";
		try {
			if( ( ! note || ! note.noteAddress ) && this.#note )
				note = JSON.parse( JSON.stringify( this.#note ));
			
			if( ! this.#password ){
				this.#password = await this.#getPassword( "", note );
			}
			
			if( (this.set_pass || this.#set_pass ) ){//required in order not to confuse the real note'this.s password from dynamic passwords.
				this.#password = await this.#generatePassword( this.set_pass ? this.set_pass : this.#set_pass );
				if( this.set_pass ){
					this.#set_pass = this.set_pass;
					delete this.set_pass;
				}			
			}
			//console.log( "Checking notes " + ( ! this.#note || ! this.#password ) );
			if( ! note || ! this.#password ) return false;
			
			//console.log("SET CURRENT NOTE PASSWORD: " + this.#password );
			
			var string 	=  this.#password;
			let currentNote = {};
			let pass 		= this.hashed( string );
			let stored 		= await window.navigator.storage.getDirectory("scriptStorage", {create: true}).catch( error =>{this.errorMessage( error.toString() );  return false;});
			
			//console.log( "pass: " + pass );
			//console.log( "note data: " + JSON.stringify( this.#note ) );
			//await this.createAlert("Before Note");
			
			let key, note_data, data;
			
			for( key in note ){		
							
				note_data = note[ key ];
				if( typeof note_data == "string" )
					data 					= this.encrypt( note_data, pass );
				
				else 
					data 					= this.encrypt( JSON.stringify( note_data ), pass );
				
				if( key == 'noteSecret' ){
					currentNote.noteSecret = data;
					//currentNote.noteSecret = this.encrypt( note_data, pass );
				} 
				else if( key == 'budgetID' && note_data && note_data.length == 772 && typeof note_data == "string" ){
					var id = await this.generateKey(10);
					await this.setPrivateKey( note_data, id );					
					if( ! this.saveOnNote ){
						currentNote.budgetID 	= await this.getPublicKey(id);
						let file 				= await stored.getFileHandle( currentNote.budgetID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
					} else {
						currentNote.budgetID = data;
					}
				}
				else if( key == 'blockKey' ) {
					currentNote.blockKey = data;
				}
				else if( key == 'profitKeys' ) {
					
					if( ! this.saveOnNote ){
						let profitKey 			= await this.generateKey(20);
						let file 				= await stored.getFileHandle( profitKey.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
						currentNote.profitKeys = profitKey;
					} else {
						currentNote.profitKeys = data;
					}
				}
				else if( key == 'noteProducts' ){
					if( ! this.saveOnNote ){
						let productKey 			= await this.generateKey(20);
						let file 				= await stored.getFileHandle( productKey.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
						currentNote.noteProducts = productKey;
					} else {
						currentNote.noteProducts = data;
					}
									
				}
				else if( key == 'noteBudgets' ){
					if( ! this.saveOnNote ){
						let budgetKey 			= await this.generateKey(20);
						let file 				= await stored.getFileHandle( budgetKey.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
						currentNote.noteBudgets = budgetKey;
					} else {
						currentNote.noteBudgets = data;
					}
					
				}
				else if( key == 'agreements' ){
					if( ! this.saveOnNote ){
						let agreementKey 			= await this.generateKey(20);
						let file 				= await stored.getFileHandle( agreementKey.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
						currentNote.agreements = agreementKey;
					} else {
						currentNote.agreements = data;
					}
					
				}
				else if( key == 'noteSubs' ){
					if( ! this.saveOnNote ){
						let subsKey 			= await this.generateKey(20);
						let file 				= await stored.getFileHandle( subsKey.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
						currentNote.noteSubs 	= subsKey;
					} else {
						currentNote.noteSubs = data;
					}
					
				}else if( key == 'unfulfilled' ){
					if( ! this.saveOnNote ){
						let subsKey 			= await this.generateKey(20);
						let file 				= await stored.getFileHandle( subsKey.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 				= await file.createWritable();
						await write.write( data );
						await write.close();
						currentNote.unfulfilled 	= subsKey;
					} else {
						currentNote.unfulfilled = data;
					}
					
				}
				else {
					currentNote[key] = note_data;
				}
			}
			try{
				await this.savePersistently(currentNote, "userNotes", "currentNote");
				this.s.currentNote = JSON.stringify( currentNote );
				
				if( chrome && chrome.storage ){
					chrome.storage.session.set({currentNote: JSON.stringify( currentNote )});
				}
				
				if( currentNote.blockID ){
					await this.savePersistently( currentNote, currentNote.noteAddress, currentNote.blockID.replaceAll(/[^A-Za-z0-9]/g, "_" ) + "_note" );
				}
			} catch(e){
				let user_pass = this.s.user_pass;
				this.s.clear();
				this.s.currentNote = JSON.stringify( currentNote );
				this.s.user_pass = user_pass;
				console.error(e);
			}
			
			if( chrome && chrome.runtime && Object.hasOwn("onMessage")){
				chrome.runtime.sendMessage({setCurrentNote: currentNote});
			}
			//console.log( "CURRENT NOTE SET: " + JSON.stringify( currentNote ), "TYPEOF: " + typeof currentNote );
			//await this.createAlert("Check current note ");
			return currentNote;
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	
	//Scriptbill function retrives the current note from database.
	static async #getNote( noteAddress = '' ){
		//console.log("#getNote running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "#getNote";
				
		if( ! this.#password )
			this.#password = await this.#getPassword();
			
		try {
		
			//if the note address is not set, we return the this.
			if( ( ! this.noteAddress && noteAddress == '' ) || ! this.#password  ) return;
			
			this.#note = false;
			
			//remember to test the length
			if( noteAddress != '' )
				this.noteAddress = noteAddress;
			
			let notes 			= await this.getDataPersistently('scriptNotes', 'notes');
			let person 			= await this.getDataPersistently('scriptNotes', 'persons');
			//looking for the local storage for the note.		
			if( ! notes || ! person ) {
				this.errorMessage( "No Local Database to fetch the requested Scriptbill Note From" );
				return false;		
			}
			
			if(this.isJsonable( person ))
				person 		= JSON.parse( person );
			
			else 
				person 		= {};
			
			//await this.createAlert("Password while getting note: " + this.#password );
			
			//the password to decrypt the note should be stored on the personal local database of the current user. 
			//if not stored on Scriptbill location, then the user should upload the note to Scriptbill server,
			
			//next we test to check if the requested note was saved on Scriptbill database
			if( ! person[ this.noteAddress ] ) {
				this.errorMessage( "The requested note was not found on the local database! Please check the note address entered: " + this.noteAddress + " or try a different note. You can also check on other server where the note was stored." );
				return false;
			}
			
			//next, we set the supplied password as private key to decrypt the note'this.s password.
			var string 		= this.#password;
			let pass			= this.hashed( string );
			
			//before decrypting test the integrity of the password and alert the user if the integrity is breached.
			var string = person[ this.noteAddress ].password + person[ this.noteAddress ].transTime;
			let hashed = this.hashed( string );
			
			if( person[ this.noteAddress ].hash != hashed )
				this.errorMessage( "Personal Database Integrity Compromised!!! This May Affect The Getting Of Your Scriptbill Note" );
			
			//attempting to decrypt the password.
			let password = this.decrypt( person[ this.noteAddress ].password, pass);
			
			if( person[ this.noteAddress ].password == password ){
				this.errorMessage( "Password was not successfully decrypted! Please enter a correct Scriptbill Password! Thanks " + typeof password );
				return false;
			}
				
			/* //setting the decrypted password as private Key to get the saved note,
			var string 		=  password; */

			if( notes && this.isJsonable( notes ))
				notes 		= JSON.parse( notes );
			
			else 
				notes 		= {};
			
			let note 			= this.decrypt( notes[ this.noteAddress ], password );
			
			if( this.isJsonable( note ) ) {			
				this.#note = JSON.parse( note );
				await this.setCurrentNote();
			}
			
			if( typeof this.#note == "object" && this.#note.noteAddress )
				await this.successMessage("Note "+ this.#note.noteAddress +" Successfully Gotten From Database!!!");
				
			//if the note is found, it will return the note object, else an undefined variable is returned.
			return this.#note;
		} catch(e){
			console.error(e);
			return false;
		}
	}
	

	static async #getNoteAlgo(){
		//console.log("#getNoteAlgo " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "#getNoteAlgo";
		let algoKeys = ["A", "D", "E", "H", "M", "P", "R", "R2", "R3", "RL", "S1", "S3", "S22", "S25", "S38", "S51", "T"];
		
		if( ! this.#note && this.#note.noteID ){
			this.errorMessage("no note on the request, can't calculate note algo without an ID");
			return false;
		}
		
		let algoKey = this.#note.noteID.toString().slice(0, 3);
		let indexes = [];
		let x, key, index, y, algo = '';
		
		for( x = 0; x < algoKey.length; x++ ) {
			key		= algoKey[x];
			index 	= this.#alpha_numeric.indexOf(key);
			y 		= index;
			
			for( y = index; y > algoKeys.length; y-- ){
				y = y - algoKeys.length;
			}
			
			index 	= y;
			algo 	+= algoKeys[index];
		}
		
		return algo;
		
	}	
	
	
	static async changeTransKey( currrentKey, newKey ){
		
		this.s 		= await this.s;
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote )) {
				this.#note 			= await this.#getCurrentNote();
			}
			else if( ! this.#note && this.noteAddress ){

				this.#note 			= await this.#getNote();
			}
			
			if( ! this.#note ) return false;
			
			currentKey 			=  currentKey.toString();
			let x, key, transKey = this.#note.transKey, tran1, tran2;
			
			for( x = 0; x < currentKey.length; x++ ){
				key 			= currentKey[x];
				tran1 			= transKey.slice( 0, key );
				tran2 			= transKey( key, transKey.length );
				transKey 		= tran2 + tran1;
			}
			
			var string 		= transKey;
			let noteSecret 		= this.decrypt( this.#note.noteSecret, this.hashed( string ) );
			
			if( typeof noteSecret == 'string' ){
				newKey 			= newKey.toString();
				for( x = 0; x < newKey.length; x++ ){
					key 			= newKey[x];
					tran1 			= transKey.slice( 0, key );
					tran2 			= transKey( key, transKey.length );
					transKey 		= tran2 + tran1;
				}
				
				var string 			= transKey;
				this.noteSecret 	= this.encrypt( noteSecret, this.hashed( string ) );
				this.details 		= JSON.parse( JSON.stringify( this.defaultBlock ));
				this.details.transValue 	= 0;
				this.details.transType 		= "UPDATE";
				await this.generateScriptbillTransactionBlock( this.details, this.#note );
				return true;
			}
			else {
				return false;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	static async recieveResponse(){
		////console.log("recieveResponse running " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length]);
		this.funcUp[ this.funcUp.length] = "recieveResponse";
		this.#noVerify	= false;

        const runShareData =  async (data) => {
			//console.log("message response", data);
			if( ! data || ! data.responseKey ) return false;
			
			this.#noVerify	= false;
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.blockKey, id );
			//console.log( data, typeof data );
			
			data 			= data.responseKey;

			if( typeof data == 'string' && data.includes('--'))
				data 		= data.split("--");

			if(typeof data == "object" && data.length ){
				data.map( async (det)=>{
					if( ! this.isJsonable( det ) ) {
						let dat = this.decrypt( det, await this.getPublicKey( id, true ) );
							
						if( dat && dat != det && this.isJsonable( dat ) ) {
							//parsing the data.
							dat = JSON.parse( dat );
														
							if( dat.responseID && this.#note && dat.responseID == this.#note.blockID ){
								//already recieved;
								if( this.s[dat.responseID] ) return;
									
								//recieved;
								this.s[dat.responseID] 	= dat.code;
									
								//alerting the user.
								if( this.alertDetails )
									await this.createAlert( dat.code + " Response ID: " + dat.responseID );
								
								if( dat.code.includes( "Block ID Not Matched" ) ||  dat.code.includes("No Former Block Found For This Block" ) ){
									let block 	= await this.getDataPersistently( dat.responseID );
									
									if( block && block.blockID ){
										this.shareData( false, block );
										block 		= await this.getDataPersistently( block.formerBlockID );
										
										if( block && block.blockID )
											this.shareData( false, block );
									}
								}
									
							}else if( dat.blockID ){
									
								//already stored block no need to process.
								if( this.l[ dat.blockID ] ) return;
									
								//new block and can be processed.
								this.response = JSON.parse( JSON.stringify( dat ) );
								this.checkReferers( this.response, this.#note );
								await this.storeBlock( this.response, this.#note );					
							} else if( dat.type && this.#note ){
								if( Object.keys( dat ).includes( this.#note.walletID ) ){
									if( this.sendChannel ){
										let desc 			= new RTCSessionDescription( JSON.parse( dat[this.#note.walletID].answer ) );
										this.localConnection.setRemoteDescription( desc );
										if( this.l.DNS ){
											let dns 		= JSON.parse( this.l.DNS );
											
											if( dns[ this.#note.walletID ] ){
												this.localConnection.setLocalDescription( dns[ this.#note.walletID ] );
											}
										}
									}
								}
							}
							else {
								//already stored;
								if( dat.responseID && this.s[dat.responseID] ) return;
								
								//storing...
								this.s[dat.responseID] = dat.code;
									
								//saving as error message.
								this.errorMessage( dat.code );							
							}
											
								
						}
					}
					else{
						let dat = JSON.parse( det );
															
						this.response = JSON.parse( JSON.stringify( dat ));
						this.checkReferers( this.response, this.#note );
						this.storeBlock( this.response, this.#note );
						//this.monitorScriptbillExchanges();
						this.profitSharing( this.response );
					}
				})
			}
		}
		//initalizing storage.
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
			
			if( ! this.#note )					
				return false;
			
			let server = this.#note.noteServer;
			//console.log("function recieveResponse", "server: " + server  );
			let obj 	= {};
			obj.response 	= "true";
			obj.server 		= server;
			obj.defaultServer = this.#default_scriptbill_server;
			obj.note 		= JSON.stringify( this.#note );
			let data 		= false;
			
			if( typeof chrome != "undefined" && chrome.runtime && Object.hasOwn("onMessage")){
				chrome.runtime.sendMessage(obj);
				chrome.runtime.onMessage.addListener(runShareData);
			} else {
				const myWorker = new Worker("share.js");
				myWorker.postMessage( obj );
                myWorker.onmessage = function(event){
                    runShareData(event.data);
                }
			}

			
		} catch(e){
			console.error(e);
			return false;
		}		
	}
	
	static async getWalletRank(){
		////console.log("getWalletRank running " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length]);
		this.funcUp[ this.funcUp.length] = "getWalletRank";
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note 		= await this.#getCurrentNote();
			
			if( this.#note ){
				if( this.#note.blockID ){
					let block 	= await this.getTransBlock();
					block 		= block[0];
					if( block && block.rankCode){
						//the wallet rank ket on a note is the private key used to encrypt and decrypt the user rank in the network.
						var string 		=  this.#note.walletRank;
						let rankCode 		= this.decrypt( block.rankCode, this.hashed( string ) );
						
						if( rankCode != block.rankCode && typeof rankCode == "string" ) {
							let ranks = this.#scriptbillRanks;
							let rank, level, found = false;
							
							for( level in ranks ){
								rank = ranks[level];
								
								if( rank.code == rankCode ){
									found = true;								
									break;
								}
								
								
							}
							
							if( this.#note.rankPref && found){
								return rank[ this.#note.rankPref ];
							} else {
								return ranks[ Object.keys( ranks )[0] ][ this.#note.rankPref ];
							}
						} else {
							this.errorMessage("Note Didn't Successfully Decrypt the Rank Code on Block");
							return false;
						}
					} else {
						this.errorMessage("Note Didn't return a trans block!!!");
						return false;
					}
				}
				
				else {
					return await this.calculateWalletRank();
				}
			}
			else {
				return await this.calculateWalletRank();
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	
	//this function is meant to calculate the rank for the current wallet
	static async calculateWalletRank(){
		////console.log("calculateWalletRank running " + this.funcUp[ this.funcUp.length][ this.funcUp[ this.funcUp.length].length]);
		this.funcUp[ this.funcUp.length] = "calculateWalletRank";
		
		try {		
			//getting the current note if not defined.
			if( this.s.currentNote && ! this.#note )
				this.#note = await this.#getCurrentNote();
				
			if( ! this.#note ) return 'No Note';
			
			//console.log("note: " + JSON.stringify( this.#note ));
			
			let transBlock;
			if( ! this.formerBlock || ! this.nextBlock ) {
				this.blockID 		= this.#note.blockID;
				//getting the current transaction block for the current note
				transBlock 			= await this.getTransBlock();
				transBlock 			= transBlock[0];
			}
			let noteValue, noteType, blockID, nextBlockID, formerBlockID, formerWalletHASH, exValue, rankValue;
			
			//this will store the total note found under this wallet
			if( ! this.noteFound )
				this.noteFound = 0;
			
			//this will give us the total value of the whole note found under this wallet in
			//scriptbills.
			if( ! this.rankValue )
				this.rankValue = 0;
			
			if( ! this.formerBlock && transBlock && transBlock.blockID && transBlock.walletHASH ){
				//console.log("In Here >>>>");
				this.notefound++;
				this.walletHASH 		= transBlock.nextWalletHASH;
				noteValue 				= transBlock.noteValue;
				noteType				= transBlock.noteType;
				nextBlockID				= transBlock.nextBlockID;
				formerBlockID 			= transBlock.formerBlockID;
				formerWalletHASH		= transBlock.formerWalletHASH;
				blockID					= transBlock.blockID;
				let noteValue			= parseFloat( transBlock.noteValue );
				
				if( this.#transSend.includes( transBlock.transType ) )
					noteValue			-= parseFloat( transBlock.transValue );
				
				else if( this.#transRecieve.includes( transBlock.transType ) )
					noteValue			+= parseFloat( transBlock.transValue );
				
				if( transBlock.noteType != 'SBCRD' && ! transBlock.noteType.includes("STK") ) {
					exValue 				= await this.getExchangeValue( transBlock.noteType, 'SBCRD' );
					
					if( exValue )
						rankValue 			= noteValue * exValue[1];

					else 
						rankValue 			= noteValue;
				}
				 else {
					rankValue 			= noteValue;
				}
				this.workedID		= transBlock.blockID;
				this.rankValue		+= rankValue;
				this.formerBlock 	= transBlock;
				this.blockID		= this.formerBlock.blockID;
				transBlock 			= await this.getTransBlock();//getting the next trans block from the wallet hashes.
				transBlock			= transBlock[0];
				
				if( transBlock && transBlock.blockID ){
					this.nextBlock = transBlock;
					this.startBlockID = blockID;
					return await this.calculateWalletRank();
				} else {
					this.endBlockID 	= blockID;
					this.nextBlock 	= this.formerBlock;
					this.walletHASH	= this.nextBlock.formerWalletHASH;
					transBlock		= await this.getTransBlock();
					transBlock 		= transBlock[0];
					
					if( transBlock && transBlock.blockID ) {
						this.formerBlock = transBlock;
						return await this.calculateWalletRank();
					}
				}
			}
			else if( this.formerBlock && this.nextBlock ){
				if( this.formerBlock.nextBlockID != this.nextBlock.blockID || this.formerBlock.noteType != this.nextBlock.noteType ) {
					this.noteFound++;
					transBlock 			= this.nextBlock;
					if( transBlock.noteType != 'SBCRD' && ! transBlock.noteType.includes("STOCK") ) {
						exValue 			= await this.getExchangeValue( transBlock.noteType, 'SBCRD' );
						
						if( exValue )
							rankValue 			= transBlock.noteValue * exValue[1];

						else 
							rankValue 			= transBlock.noteValue;
					}
					else {
						rankValue 			= transBlock.noteValue;
					}
					this.rankValue 	+= rankValue;
				}
				
				let isNextBlock = false;
				
				if( this.workedID && this.workedID == this.formerBlock.blockID ) {
					this.walletHASH = this.nextBlock.nextWalletHASH;
					isNextBlock = true;
				}			
				else if( this.workedID == this.nextBlock.blockID )
					this.walletHASH	= this.formerBlock.formerWalletHASH;
				
				transBlock 				= await this.getTransBlock();
				transBlock 				= transBlock[0];
				
				if( transBlock && transBlock.blockID && isNextBlock ){
					this.formerBlock = this.nextBlock;
					this.nextBlock	= transBlock;
					return await this.calculateWalletRank();
				}
				else if( transBlock && transBlock.blockID && ! isNextBlock ) {
					this.formerBlock 	= transBlock;
					this.nextBlock	= this.formerBlock;
					return await this.calculateWalletRank();
				}
				else if( ! transBlock ){
					if( this.startBlockID && ! this.noBlock ){
						this.blockID = this.startBlockID;
						transBlock			= await this.getTransBlock();
						transBlock 			= transBlock[0];
						
						if( transBlock && transBlock.blockID ) {
							this.walletHASH	= transBlock.formerWalletHASH;
							this.nextBlock	= transBlock;
							this.formerBlock	= await this.getTransBlock();
							this.formerBlock 	= this.formerBlock[0];
							
							if( this.formerBlock && this.formerBlock.blockID ){
								this.noBlock		= true;
								return await this.calculateWalletRank();
							}
						}
					}else if( this.endBlockID && ! this.noBlock ){
						this.blockID 		= this.endBlockID;
						transBlock 			= await this.getTransBlock();
						transBlock 			= transBlock[0];
						
						if( transBlock && transBlock.blockID ) {
							this.walletHASH = transBlock.nextWalletHASH;
							this.formerBlock	= transBlock;
							this.nextBlock 	= await this.getTransBlock();
							this.nextBlock 	= this.nextBlock[0];
							
							if( this.nextBlock && this.nextBlock.blockID ){
								this.noBlock = true;
								return await this.calculateWalletRank();
							}
						}
					}
					else {
						this.noBlock = undefined;
						return [ this.rankValue, this.noteFound ];
					}
					
				}
			} else {
				return transBlock;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async scriptbillAssignRanks(){
		//console.log("scriptbillAssignRanks running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "scriptbillAssignRanks";
		
		try {
		
			this.calculateWalletRank();
			
			if( ! this.rankValue && ! this.walletID && ! this.#note ) return;
			
			let ranks = this.#scriptbillRanks;
			let level, rank;
			this.blockID = undefined;
			let levelFound;
			
			for( level in ranks ){
				rank = ranks[ level ];
				
				if( rank.min >= this.rankValue && rank.max <= this.rankValue ) {
					levelFound = level;
					break;
				}
			}
			if( levelFound ) {
				rank = ranks[ levelFound ];
			}	
			else {
				//simply revert to the default ranking
				rank = ranks[ Object.keys( ranks )[0] ];
			}				
			this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ) );
			//console.log("assign rank: " + rank.code, typeof rank.code );		
			//calculating the rank code.
			//first set the walvar id as a private key to encrypt the rank code.
			var string 			= this.#note.walletRank;
			this.details.rankCode  	= this.encrypt( rank.code, this.hashed( string ) );
			this.details.noteValue 	= this.#note.noteValue;
			this.details.transType 	= "UPDATE";
			return await this.generateScriptbillTransactionBlock();
		} catch( e ){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
		
	}
	
	static currentTime(){
		//console.log("currentTime running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "currentTime";
		return Date.now().toString();
	}
	
	static async setUpDatabase(){		
		//console.log("setUpDatabase running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "setUpDatabase";
		
		//initializing storage
		this.l 		= await this.l;
		this.s 		= await this.s;
		
		//set up the database here
		if( ! this.l.personal ){
			if( ! this.#password ) {
				this.#password = await this.#getPassword();
			}

			if( ! this.walletID ){
				this.walletID = await this.generateKey(20);
			}
			let object = {
				walletID : this.walletID,
				transTime : this.currentTime()				
			}
			let o = object;
			var string  = JSON.stringify( o ) + this.#password;
			o.hash = this.hashed( string );

			this.l.personal = JSON.stringify( o );
		}
		
		await this.loginUserDetails();
		
	}	
	
	static async generateKey( num = 10, isDouble = false, isSign = false ){
		//console.log("generateKey running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "generateKey";
		
		try {
			if( ! isDouble ) {
				let string = Date.now().toString();
				
				if( this.seedin ){
					string 		+= this.seedin;
				}
				
				let hashed = CryptoJS.SHA512( string ).toString( CryptoJS.enc.Base64 );
				
				if( hashed.length >= num )
					return hashed.slice( 0, num );
				
				else {
					let remaining 	= num - hashed.length;
					//this describes the number of loops we are going to follow to get the key length;
					let loop 		= Math.round( remaining / hashed.length );
					let x, key;
					for( x = 0; x <= loop; x++ ){
						key 		= CryptoJS.SHA512( Date.now().toString() ).toString( CryptoJS.enc.Base64 );
						hashed 		= hashed + key;
						
						if( hashed.length >= num ){
							hashed 		= hashed.slice( 0, num );
							break;
						}
					}
					return hashed;
				}
			} else {
				let key;
				
				if( ! isSign ){
					key = await crypto.subtle.generateKey(
					 {
						name: "RSA-OAEP",
						modulusLength: 1024,
						publicExponent: new Uint8Array([1, 0, 1]),
						hash: "SHA-256",
					  },
					  true,
					  ["encrypt", "decrypt"]
					);
				} else {
					key = await window.crypto.subtle.generateKey(
					  {
						name: "ECDSA",
						namedCurve: "P-384",
					  },
					  true,
					  ["sign", "verify"]
					);
				}
				
				if( key && key.publicKey && key.privateKey ){
					let publicKey, privateKey;
					publicKey 			= await crypto.subtle.exportKey( 'jwk', key.publicKey );
					privateKey 			= await crypto.subtle.exportKey( 'jwk', key.privateKey );
					this.privateKeyN 	= key.privateKey;
					this.publicKeyN 	= key.publicKey;
					
					if( ! isSign ){					
						publicKey 		= publicKey.n;
						privateKey 	= privateKey.d + privateKey.dp + privateKey.dq + privateKey.n + privateKey.p + privateKey.q + privateKey.qi;
					} else {
						publicKey 		= publicKey.x + publicKey.y;
						privateKey 	= privateKey.d + privateKey.x + privateKey.y;
					}
					
					return privateKey;
				}
				
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
		
	}
	
	static async setPublicKey( key, id ){
		//console.log("setPublicKey running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "setPublicKey";
		
		if( ! this.publicKey || typeof this.publicKey != "object" )
			this.publicKey = {};
		
		this.publicKey[id] = key;

		if( this.privateKey && this.privateKey[id]){
			this.privateKey[id] = undefined;
		}
	}
	
	static async setPrivateKey( key, id ){
		//console.log("setPrivateKey running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "setPrivateKey";
		
		if( ! this.privateKey || typeof this.privateKey != "object" )
			this.privateKey	= {};
		
		this.privateKey[id] = key;	
	}
	
	static async getPrivateKey(id = ""){
		//console.log("getPrivateKey running "+ this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "getPrivateKey";
		try {
			if( this.privateKey && this.privateKey[id] )
				return this.privateKey[id];
			
			else{
							
				let privKey = await this.generateKey( 50, true );
				
				if( privKey != null )
					return privKey;
				
				return false;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	
	
	//for security purposes, the publicKey variable can't be trusted,it must be in line with the privateKey of Scriptbill function.
	//so to get the expected publicKey when running Scriptbill function, you must set a private key that will return your expected public key.
	static async getPublicKey(  id = "", isSign = false){
	//console.log("getPublicKey running " + this.funcUp[ this.funcUp.length]);
	this.funcUp[ this.funcUp.length] = "getPublicKey";
		try {
			if( ! this.publicKey && typeof this.publicKey != "object" )
				this.publicKey = {};
			
			if( typeof this.publicKey == "string" )
				this.publicKey = {};
			
			if( this.privateKey && this.privateKey[id]){			
				if( ! isSign )
					this.publicKey[id] 	= this.privateKey[id].slice( 343, 514 );
				
				else
					this.publicKey[id] 	= this.privateKey[id].slice( 64, this.privateKey[id].length );
				
				return this.publicKey[id];
			}
			else if( this.publicKey && this.publicKey[id] ) {						
				return this.publicKey[id];
			}
			//generate a public key if none is found.
			else {
				
				if( typeof this.privateKey == "string" )
					this.privateKey = {};
				
				if( typeof this.publicKey == "string" )
					this.publicKey = {};
				
				this.privateKey[id] = await this.generateKey( 50, true, isSign );				
				
				if( ! isSign )
					this.publicKey[id] 	= this.privateKey[id].slice( 343, 514 );
				
				else
					this.publicKey[id] 	= this.privateKey[id].slice( 64, this.privateKey[id].length );
				
				return this.publicKey[id];
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	/*  */
	
	//Scriptbill method stores and attempt to output error messages to the user when running Scriptbill class
	static async errorMessage( message, funcName = "" ){
		//console.log("errorMessage running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "errorMessage";
		//the message must be in string format for the function to work
		if( typeof message != 'string' ) return;
		
		if( ! this.error )
			this.error = {};
		
		if( funcName )
			this.error[funcName] = message;
		
		try {
			
			let note = false;
			
			if( this.s.currentNote && this.isJsonable( this.s.currentNote ) )
				note = JSON.parse( this.s.currentNote );
			
			if( this.s.eMessages == undefined )
				this.s.eMessages = JSON.stringify({});
			
			let messages 	= JSON.parse( this.s.eMessages );
			
			if( Object.values( messages ).includes( message ) ){
				let index = Object.values( messages ).indexOf( message );
				let time 	= Object.keys( messages )[index];
				delete messages[time];
			}			
			
			let key 		= this.currentTime();
			messages[ key ]	= message;			
			let hour 		= 3600000, diff = 0;
			
			for( let time in messages ){
				diff = parseInt( key ) - parseInt( time );
				
				if( diff >= hour ){
					delete messages[time];
				}
			}
			
			this.s.eMessages = JSON.stringify( messages );
			
			if( note && note.noteAddress ){
				
				//this.getData(['address', 'walletID', 'errorMessage', 'time'],[note.noteAddress, note.walletID, message, key], this.#default_scriptbill_server);
			}
			//console.log( message );
		} catch(e){
			let currentNote = this.s.currentNote;
			let pass 		= this.s.user_pass;
			let upload 		= this.s.uploaded;
			//alert("checking session");
			this.s.clear();
			//this.errorMessage(e.toString());
			console.error(e);
			this.s.currentNote = currentNote;
			this.s.user_pass 	= pass;
			this.s.uploaded 	= upload;
		}
	}
	
	static async createAlert(message){
		
		return new Promise( ( resolve, reject )=>{
			let alert = document.createElement("div");
			let button = document.createElement("button");
			let alertInner = document.createElement("div");
			let alertLogo 	= document.createElement("div");
			alert.setAttribute("style", "position:fixed; background-color:rgba(0,0,0,0.4); top:0;left:0; width:100%;height:100%;display:flex;align-items:center;justify-content:center;z-index:" + Date.now()+";");
			alertInner.setAttribute("style", "background-color:white;padding:4%;padding-bottom:50px;position:relative;width:60%; height:auto;border-radius:8px;word-wrap: break-word;overflow-wrap: break-word;word-break: break-word; max-width:400px;");
			alertLogo.setAttribute("style", "width:30px;height:30px;border-radius:50%;background-image:url('images/logo.png');background-size:cover;background-repeat:no-repeat;background-position:center;position:absolute; top:5px; left:5px;");
			button.setAttribute("style","position:absolute; bottom:10px; left:25%; width:50%; height:auto; padding:5px; color:white; background-color:#444;border:none; border-radius:3px;");
			button.innerText 	= "Close";		
			button.addEventListener("click", function(){
				alert.remove();
				resolve( true );
			});
			alertInner.innerHTML 	= message;
			alertInner.appendChild( alertLogo );
			alertInner.appendChild( button );
			alert.appendChild( alertInner );
			document.body.appendChild( alert );
		});		
	}
	
	static async createPrompt(message, def = "" ){
		return new Promise( ( resolve, reject )=>{
			let alert = document.createElement("div");
			let confirm = document.createElement("button");
			let button = document.createElement("input");
			let coverConfirm = document.createElement("div");
			let alertInner = document.createElement("div");
			let alertLogo 	= document.createElement("div");
			alert.setAttribute("style", "position:fixed; background-color:rgba(0,0,0,0.4); top:0;left:0; width:100%;height:100%;display:flex;align-items:center;justify-content:center;z-index:" + this.currentTime() + ";");
			alertInner.setAttribute("style", "background-color:white;padding:4%;padding-bottom:50px;position:relative;width:60%; height:auto;border-radius:8px;word-wrap: break-word;overflow-wrap: break-word;word-break: break-word; max-width:400px;");
			alertLogo.setAttribute("style", "width:30px;height:30px;border-radius:50%;background-image:url('images/logo.png');background-size:cover;background-repeat:no-repeat;background-position:center;position:absolute; top:5px; left:5px;");
			coverConfirm.setAttribute("style","position:absolute; bottom:10px; left:0%; width:100%; height:auto; padding:5px; color:white; background-color:transparent; display:flex; justify-content:space-between;flex-direction:column;gap:5px;align-items:center;");
			confirm.setAttribute("style","width:50%; height:auto; padding:5px; color:white; background-color:green; border:none; border-radius:3px;");
            button.setAttribute("type", "text");
            button.setAttribute("name", "prompt");
			button.setAttribute("style","width:70%; height:auto; padding:5px; color:black; background-color:white;outline:none; border:1px solid green; margin-bottom: 7px;border-radius:3px;");
           
			button.setAttribute("value", def);
			
			confirm.innerText 	= "Done";		
			confirm.addEventListener("click", function(){
				alert.remove();
				resolve( button.value );
			});
			
			coverConfirm.appendChild( button );
			coverConfirm.appendChild( confirm );
			alertInner.innerHTML 	= message;
			alertInner.appendChild( alertLogo );
			alertInner.appendChild( coverConfirm );
			alert.appendChild( alertInner );
			document.body.appendChild( alert );                              
		});
	}
	
	static async createConfirm(message){
		return new Promise( ( resolve, reject )=>{
			let alert = document.createElement("div");
			let confirm = document.createElement("button");
			let button = document.createElement("button");
			let coverConfirm = document.createElement("div");
			let alertInner = document.createElement("div");
			let alertLogo 	= document.createElement("div");
			alert.setAttribute("style", "position:fixed; background-color:rgba(0,0,0,0.4); top:0;left:0; width:100%;height:100%;display:flex;align-items:center;justify-content:center;z-index:" + this.currentTime() + ";");
			alertInner.setAttribute("style", "background-color:white;padding:4%;padding-bottom:50px;position:relative;width:60%; height:auto;border-radius:8px;word-wrap: break-word;overflow-wrap: break-word;word-break: break-word; max-width:400px;");
			alertLogo.setAttribute("style", "width:30px;height:30px;border-radius:50%;background-image:url('images/logo.png');background-size:cover;background-repeat:no-repeat;background-position:center;position:absolute; top:5px; left:5px;");
			coverConfirm.setAttribute("style","position:absolute; bottom:10px; left:0%; width:100%; height:auto; padding:5px 30px; color:white; background-color:transparent; display:flex; justify-content:space-between;");
			confirm.setAttribute("style","width:fit-content; height:auto; padding:5px; color:white; background-color:green;border:none;border-radius:3px");
			button.setAttribute("style","width:fit-content; height:auto; padding:5px; color:white; background-color:red;border:none;border-radius:3px");
			
			confirm.innerText 	= "Accept";		
			confirm.addEventListener("click", function(){
				alert.remove();
				resolve( true );
			});
			button.innerText 	= "Reject";		
			button.addEventListener("click", function(){
				alert.remove();
				resolve( false );
			});
			coverConfirm.appendChild( button );
			coverConfirm.appendChild( confirm );
			alertInner.innerHTML 	= message;
			alertInner.appendChild( alertLogo );
			alertInner.appendChild( coverConfirm );
			alert.appendChild( alertInner );
			document.body.appendChild( alert );
		});
	}
	
	static async successMessage( message ){
		//console.log("successMessage running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "successMessage";
		//the message must be in string format for the function to work
		if( typeof message != 'string' ) return;
		
		try {
		
			//initializing storage;
			this.s 		= await this.s;
			this.l 		= await this.l;
			
			if( this.s.sMessages == undefined )
				this.s.sMessages = JSON.stringify({});
			
			let messages 	= JSON.parse( this.s.sMessages );
			let key 		= this.currentTime();
			messages[ key ]	= message;
			
			this.s.sMessages = JSON.stringify( messages );
			//console.log( message );
		} catch( e ){
			this.errorMessage(e.toString());
			console.error(e);
		}
	}
	
	static async #encrypt( data, id = "" ){
		//console.log("encrypt running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "encrypt";
		let publicKey = await this.getPublicKey(id);
		try {	
			if( ! publicKey || ! CryptoJS ) return data;
			
			let encryptKey 		= await this.generateKey();
			
			let keyObj =	{
				"alg": "RSA-OAEP-256",
				"e": "AQAB",
				"ext": true,
				"key_ops": [
					"encrypt"
				],
				"kty": "RSA",
				"n": "vGRdPqhiG4-APxcMG8ItvT43FzRHsa1QqALROwknpODKC7HV9icoDZI27Z885VcUo6isu4vqtt5eLmKgBaKaFHNSxv-CSFHgTEPBmr6cWEdrs6MOxYWycJnU6o_4OmkWL3Snr_Hwvmputfomm2N0EBkPYpjc3Il5agO0RpmqFh8"
			};
			keyObj.n 			= publicKey;
			
			try {
				publicKey 		= await crypto.subtle.importKey( 'jwk', keyObj, { name: "RSA-OAEP", hash: "SHA-256" }, keyObj.ext, keyObj.key_ops );
				//console.log( "publicKey: " + publicKey );
				let encoder 		= new TextEncoder();
				let encoded 		= encoder.encode( encryptKey );
				
				let keyEnc 			= await crypto.subtle.encrypt({name:"RSA-OAEP"}, publicKey, encoded );			
				this.encrypted		= keyEnc;
				let keyString 		= this.ab2str( keyEnc );			
				
				if( typeof data == 'object' )
					data = JSON.stringify( data );
				
				if( keyString && typeof data == 'string' ){			
					return this.Base64.encode( JSON.stringify( {key: keyString, data: this.encrypt( data, encryptKey ) } ) );
				}
				else return data;
			} catch (e){
				//console.log( "encrypt error: " + e );
				return data;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return data;
		}
	}	
	
	static async splitNote(value = 0, password = ""){
		try {
			if( this.s.currentNote ){
				let s = JSON.stringify( this.s );
				
				if( ( this.s.currentNote.length > 3000000 || s.length > 4500000 ) ||  this.splitPersistently ){
					this.#note 		= await this.#getCurrentNote();
					let note 		= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
					
					if( this.#note.noteBudgets.length > 1 && ! this.splitPersistently ){
						note.noteBudgets 	= this.#note.noteBudgets.splice( 0, Math.round( this.#note.noteBudgets.length / 2 ) );
					}
					
					if( this.#note.profitKeys.length > 1  && ! this.splitPersistently ){
						note.profitKeys 	= this.#note.profitKeys.splice( 0, Math.round( this.#note.profitKeys.length / 2 ) );
					}
					
					if( this.#note.agreements.length > 1  && ! this.splitPersistently ){
						note.agreements 	= this.#note.agreements.splice( 0, Math.round( this.#note.agreements.length / 2 ) );
					}
					
					//if generating for themself we generate the note keys
					note.walletID   =  ! this.sendConfig.recipients.length ? this.#note.walletID : "";
					note.noteSecret	=  ! this.sendConfig.recipients.length ?  await this.generateKey( 0, true ): "";
					var id 				= await this.generateKey(10);
					if( note.noteSecret )
						await this.setPrivateKey( note.noteSecret, id );
					
					note.noteAddress = ! this.sendConfig.recipients.length ? await this.getPublicKey(id): "";
					note.noteServer  = this.#note.noteServer;
					note.noteType	= this.#note.noteType;
				
					
					if( this.#note.motherKey  && ! this.splitPersistently )
						note.motherKey 	= this.#note.motherKey;
					
					this.details				= JSON.parse( JSON.stringify( this.defaultBlock ) );
					this.details.transType 		= "SPLIT";
					this.details.transValue 	= value;
					
					if( this.splitPersistently )
						this.details.agreement 	= await this.createAgreement();
					
					//make sure you add recipient when splitting persistently
					if( this.sendConfig.recipients.length && ! this.splitPersistently )
						this.details.recipient 			= this.sendConfig.recipients[0];
					
					else
						this.details.recipient 			= password ? password : this.splitPersistently;
					
									
					this.#splitNote = JSON.parse( JSON.stringify( note ) );
					return this.generateScriptbillTransactionBlock().then( block =>{
						if( block && block.transType == "SPLIT" ){
							//await this.createAlert("Note Splitted");
							let currentNote = this.s.currentNote;
							note 			= JSON.parse( JSON.stringify( this.#note ) );
							this.#note 		= JSON.parse( JSON.stringify( this.#splitNote ) );
							
							if( this.splitPersistently )
								this.#set_pass = this.splitPersistently;
							
							//let userPass 			= this.l.userPass;
							this.splitted 			= {};
							this.splitted.block 	= JSON.parse( JSON.stringify( block ));
							this.splitted.encrypt 	= this.encrypt( JSON.stringify( block ), ( password ? password : this.splitPersistently ) );
							return this.splitted.encrypt;
							
							/* return this.setCurrentNote().then( setNote =>{
								//console.log( setNote, JSON.stringify( setNote ));
								await this.createAlert( "Check current note");
								if( setNote ){
									let message = "Note succesfully Splitted. Splitted Note Now Downloading to be used with same password and key as the current note. Please note that Splitted Note may inherit some important transactional keys connected to the current note. See to it that it is logged in from time to time to fulfill these transactional request.";
									
									if( this.alertDetails ){
										await this.createAlert( message );
									} else {
										this.successMessage( message );
									}								
									return this.download_note('', false).then( isDownload =>{
										this.s.currentNote = currentNote;
										this.l.userPass 	= userPass;
										this.l.currentNote  = currentNote;
										this.#note 			= JSON.parse( JSON.stringify( note ) );
										return isDownload;
									});
								}
							}); */
						} else { 
							return false;
						}
					});				
				}
			}
		}catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}

	static async mergeNote(){
		try {
			if( ! this.#note )
				this.#note = await this.#getCurrentNote();
			
			if( this.mergeNoteBinary && this.mergePassword ){
				let password 	= await this.#generatePassword( this.mergePassword );
				this.binary 	= this.mergeNoteBinary;
				let noteEncrypt	= await this.debinarilize();
				this.mergeNote  = this.decrypt( noteEncrypt, password );
				
				if( this.isJsonable( this.mergeNote ) ){
					this.mergeNote 	= JSON.parse( this.mergeNote );
				} else {
					this.mergeNote = false;
				}
			}
			
			if( ! this.#note || ! this.mergeNote || ! this.mergeNote.block )
				return false;
			
			let block = JSON.parse( JSON.stringify( this.mergeNote.block ) );
			
			if( block.transValue != this.mergeNote.noteValue ){
				this.errorMessage("Can't Merge a Note if the Merge Transaction does not have the same value as the supplied note value.");
				return false;
			}
			
			if( block.transType != "SPLIT" ){
				this.errorMessage("Can't Merge a note not created with a Split Transaction.");
				return false;
			}
			
			let recipient 		= block.recipient;
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.noteSecret, id );
			let agreement 		= await this.#decrypt( recipient, id );
			
			if( ! this.isJsonable( agreement ) ){
				this.errorMessage("Couldn't Decrypt the agreement connected to the transaction block of the note");
				return false;
			}
			
			agreement 		= JSON.parse( JSON.stringify( agreement ) );
			
			//set the details handler.
			this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
			this.details.transType = "MERGE";
			this.details.transValue = block.transValue;
			this.details.agreement  = agreement;
			return await this.generateScriptbillTransactionBlock();
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
		
	}
	
	static ab2str(buf) {
	  return String.fromCharCode.apply(null, new Uint16Array(buf));
	}
	
	static str2ab(str) {
	  var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char
	  var bufView = new Uint16Array(buf);
	  for (var i=0, strLen=str.length; i<strLen; i++) {
		bufView[i] = str.charCodeAt(i);
	  }
	  return buf;
	}
	
	static salt( data, loop = 100 ){
		if( ! this.publicKey ) return data;
		
		data 	= typeof data == "object" ? JSON.stringify( data ) : data.toString();
		
		let salt = new TextEncoder();
		let salted = salt.encode( this.publicKey );
		let len 	= this.publicKey.length;
		let x, y, z, d1, d2, l, zz = 0;
		//console.log("Len: " + len );
		for( x = 0, y = 1; y < len; x++, y++ ){
			z = salted[x] ^ salted[y];
			l = 1;
			//console.log("z b4 while: " + z);
			while ( z > len && zz != z ){
				z 		= z ^ salted[ y + l ];
				zz  	= z;
				l++;
				//console.log("z in while: " + z );
				//if( l >= 5 ) break;
			}
			//console.log("z after while: " + z);
			if( z < len ){
				d1 = data.slice(0,z);
				d2 = data.slice(z,data.length);
				//console.log( "data b4: " + data, "added var: " +  this.publicKey[z], "Len: " + data.length );
				data = d2 + this.publicKey[z] + d1;
				//console.log( "data after: " + data, "Len: " + data.length );
			}
			if( x >= loop ) break;
		}
		
		return data;
	}
	
	static async desalt( data, loop = 100 ){
		if( ! this.privateKey ) return data;
		
		this.publicKey 		= await this.getPublicKey();
		
		data 	= typeof data == "object" ? JSON.stringify( data ) : data.toString();
		
		let salt = new TextEncoder();
		let salted = salt.encode( this.publicKey );
		let len 	= this.publicKey.length;
		let x, y = 1, z, d1, d2, l, zz = 0, dl;
		//console.log("Len: " + len );
		for( x = ( len - 2), y = ( len - 1 ); y > 0; x--, y-- ){
			z = salted[x] ^ salted[y];
			l = 1;
			//console.log("z b4 while: " + z);
			while ( z > len && zz != z ){
				z 		= z ^ salted[ y + l ];
				zz  	= z;
				l++;
				//console.log("z in while: " + z );
				//if( l >= 5 ) break;
			}
			//console.log("z after while: " + z);
			dl 	= data.length - ( z + 1 );
			if( z < len && this.publicKey[z] == data[dl] ){
				d1 = data.slice(0,dl);
				d2 = data.slice((dl + 1),data.length);
				//console.log( "data b4: " + data, "removed var: " +  this.publicKey[z], "Len: " + data.length );
				data = d2 + d1;
				//console.log( "data after: " + data, "Len: " + data.length );
			}
			
			if( x >= loop ) break;
		}
		
		return data;
	}


/**
*
*  Base64 encode / decode
*  http://www.webtoolkit.info/
*
**/
static Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode : function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        input = this._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
        }
        return output;
    },

    // public method for decoding
    decode : function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        //input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }

        output = this._utf8_decode(output);

        return output;
    },

    // private method for UTF-8 encoding
    _utf8_encode : function (string ) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = "";
        var i = 0;
		var c, c1, c2, c3;
        var c = c1 = c2 = 0;

        while ( i < utftext.length ) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }
        return string;
    }
}
	
	static async #decrypt( data, id = "" ){
		//console.log("decrypt running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "decrypt";
		let privateKey = await this.getPrivateKey(id);
		
		//console.log( "priv key: ", privateKey);
		if( ! privateKey || ! CryptoJS ) return false;	
		//console.log( "not falsing: ");
		
		/* //serializing the data if it'this.s an object.
		if( typeof data == 'object' )
			data = JSON.stringify( data ); */
		
				
		if( privateKey && data && privateKey.length == 772 ){
			//console.log( "privateKey key gotten: " + this.privateKey );
			try {
				
				data 		= JSON.parse( this.Base64.decode( data ) );
				
				if( data.data.length > 0 && data.key ){
					let decryptKey 		= data.key;
					data 				= data.data;
					let keyObj 			= {
						"alg": "RSA-OAEP-256",
						"d": "En2lW0-KpZrdoxOfiB_0flUbcica_Fj_CCaSo8E_x2Ka4i_3yLvKJh7aTlNpVjdIWtHk9lmC1aUYyGO8wiDWD42gkX9eyhqf2SZGGkOkcaUDh6tggQhNFiXTIopqrX2_WIZ34QnzKFwC7atFG26qHMWgGS7g_88OGmR-QcGDcHk",
						"dp": "Ij5ldtEGEGhHUpfUlGLZSv4IVTnxB8HS8B0jaNXFrA0knp_hUHCHEVbHvF_Gfq_Jq1Ehzwg6rBe-Bkkl-5sFNQ",
						"dq": "IRplxzjsn-5G_-1A6C8cVxGAPN47uIDgRax-APwKCHe9ZJmcMcT9gK88I6nShuifjyLy9KUjI4N7X7HgaW4XMQ",
						"e": "AQAB",
						"ext": true,
						"key_ops": [
							"decrypt"
						],
						"kty": "RSA",
						"n": "vGRdPqhiG4-APxcMG8ItvT43FzRHsa1QqALROwknpODKC7HV9icoDZI27Z885VcUo6isu4vqtt5eLmKgBaKaFHNSxv-CSFHgTEPBmr6cWEdrs6MOxYWycJnU6o_4OmkWL3Snr_Hwvmputfomm2N0EBkPYpjc3Il5agO0RpmqFh8",
						"p": "54HeBLapXc-B82hKQ-gQ2BshM6lV3wMv9Jf-C4uNwQMHOswviwIL_FoG8wwQpjhPupFhPSmBdgCVhfkJDS1_Bw",
						"q": "0FLEAoZQWx_If4oGhmqaCXwfnzTdzK_U5Wu2MOt5Zlrm4p_N72lXgUWWkGU8DEUvonPI7PnAM0s-Xp-XQyvSKQ",
						"qi": "pvrz4Dq3L1SO4Vp_NDZigm7x4GlSl2pvXNjY5tZfoM1Sp94_2ktO8i0Y2xQSBQlIx4A30Ug9hHgnH1JuQI1p1A"
					};
					keyObj.d 		= privateKey.slice( 0, 171 );
					keyObj.dp 		= privateKey.slice( 171, 257 );
					keyObj.dq 		= privateKey.slice( 257, 343 );
					keyObj.n 		= privateKey.slice( 343, 514 );
					keyObj.p 		= privateKey.slice( 514, 600 );
					keyObj.q 		= privateKey.slice( 600, 686 );
					keyObj.qi 		= privateKey.slice( 686, 772 );
					privateKey 		= await crypto.subtle.importKey( 'jwk', keyObj, { name: "RSA-OAEP", hash: "SHA-256" }, keyObj.ext, keyObj.key_ops );
					//console.log( "private key: " + privateKey );
					this.encrypted 	= this.str2ab( decryptKey );
					decryptKey 		= await crypto.subtle.decrypt( {name:"RSA-OAEP"}, privateKey, this.encrypted );
					//console.log( "decrypt key: " + decryptKey );
					
					if( decryptKey ){
						let decoder 	= new TextDecoder();
						decryptKey 		= decoder.decode( decryptKey );
						//console.log( "decrypt key: " + decryptKey );
						return this.decrypt( data, decryptKey );						
					} else {
						//console.log( " key was not decrypted: " );
						return false;
					}
				} else {
					//console.log( "no key: " );
					return false;
				}
			} catch(e){
				console.error(e);
				this.errorMessage( "error decrypt message: " +  e );
				return false;
			}
		}
		else if( privateKey && typeof data == 'string' ){
			var string    = privateKey;
			let pubKey     = this.hashed( string );
			return this.decrypt( data, pubKey );
		}
		else return data;
	}	
	
	static async runRecieveData(){
		//console.log("runRecieveData running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "runRecieveData";
		//looping the recieve data handler for a day.
		this.recieveData();		
		setInterval( async ()=>{
			this.recieveData();
		}, 60000);	
	}
	
	static async setUpWebConnection(){
		
		this.#servers = null;
		
		if( ! this.#note )
			this.#note 		= await this.#getCurrentNote();
		
		this.localConnection = new RTCPeerConnection(this.#servers);
		let DNS 			= JSON.parse( this.l.DNS && this.isJsonable( this.l.DNS ) ? this.l.DNS : '{}' );
		this.isWallet 		= false;
		let dns, walletID, x = 0, desc;
		for( walletID in DNS ){
			if( x >= 500 ) break;
			dns 							= DNS[walletID];
			this.sendServers[x] 			= this.localConnection.createDataChannel( walletID );
			this.sendServers[x].onopen 		= this.onSendChannelStateChange;
			this.sendServers[x].onclose 	= this.onSendChannelStateChange;
			this.sendServers[x].onmessage 	= this.onReceiveMessageCallback;
			desc 							= new RTCSessionDescription( JSON.parse( dns ) );
			this.localConnection.setRemoteDescription( desc );
			this.isWallet 					= walletID;
			this.localConnection.createAnswer().then(
			  this.gotDescription1,
			  this.onCreateSessionDescriptionError
			);
			x++;
		}
		this.localConnection.onicecandidate = e => {
			this.onIceCandidate(this.localConnection, e);
		};
		this.isWallet 			= false;
		this.sendChannel 		= this.localConnection.createDataChannel( this.#note ? this.#note.walletID : 'defaultChannel' );
		this.sendChannel.onopen 	= this.onSendChannelStateChange;
		this.sendChannel.onclose 	= this.onSendChannelStateChange;
		this.sendChannel.onmessage 	= this.onReceiveMessageCallback;
		this.localConnection.ondatachannel = this.recieveChannelCallback;
		this.localConnection.createOffer().then(
			this.gotDescription1,
			this.onCreateSessionDescriptionError
		 );
		 return this.localConnection;
	}
	
	static onSendChannelStateChange(){
		this.readyState = this.sendChannel.readyState;
		//console.log('Send channel state is: ' + this.readyState);
	}
	
	static async sendAnswer( answer, walletID ){
		
		if( ! this.#note )
			this.#note 		= await this.#getCurrentNote();
		
		this.data = {
			[ walletID ]	: {
				'answer' 	: answer,
				dns 		: this.#note ? this.#note.walletID : ''
			},
			type 			: 'answer',
			rep 			: walletID
		};
		
		this.sendData();
		
		return true;
	}
	
	static async gotDescription1(desc){
		this.localConnection.setLocalDescription(desc);
		//console.log(`Offer from localConnection\n${desc.sdp}`);
		if( ! this.#note )
			this.#note = await this.getCurrentNote();
		
		this.data = {};
		
		if( this.isWallet ){
			this.sendAnswer( desc, this.isWallet );
		} else {
		
			if( this.#note )
				this.data.walletID 	= this.#note.walletID;
			
			this.data.serverDesc 	= JSON.stringify( desc );
			this.sendData();
			
			let dns = JSON.parse( this.l.DNS ? this.l.DNS : '{}' );
			dns[this.#note.walletID] = JSON.stringify( desc );
			this.l.DNS 	= JSON.stringify( dns );
		}
		return true;
		
	}
	
	static recieveChannelCallback(event){
		//console.log('Receive Channel Callback');
		this.recieveChannel = event.channel;
		this.recieveChannel.onmessage = this.onReceiveMessageCallback;
		this.recieveChannel.onopen = this.onSendChannelStateChange;
		this.recieveChannel.onclose = this.onSendChannelStateChange;
	}	
	
	static gotDescription2( server ){
		let desc = null;
		if( server.walletID ){
			let dns 		= JSON.parse( this.l.DNS ? this.l.DNS : '{}' );
			
			dns[server.walletID] 	= JSON.stringify( server.serverDesc );
			desc 					= dns[server.walletID];
			this.l.DNS 				= JSON.stringify( dns );
		} else {
			desc 	= JSON.stringify( server );
		}
		desc 			= new RTCSessionDescription( this.isJsonable( desc ) ? JSON.parse( desc ): '' );
		this.localConnection.setRemoteDescription(desc);
		this.localConnection.createAnswer().then(
		  this.gotDescription1,
		  this.onCreateSessionDescriptionError
		);
	}
	
	static onCreateSessionDescriptionError(error){
		//console.log('Failed to create session description: ' + error.toString());
	}
	
	static onReceiveMessageCallback(event){
		let data 				= event.data;
		
		if( this.isJsonable( data ) ){
			this.response 			= JSON.parse( JSON.stringify( data ) );
			
			if( this.response.blockID ){
				this.l.latesTime 		= this.response.transTime;
				this.l.currentBlock 	= this.response.blockID;
				
				let server 				= this.response.noteServer;
				
				if( this.isJsonable( server ) ){
					server 				= JSON.parse( server );
					if( server.sdp ){
						this.gotDescription2(server);
					}
				}
				this.#noVerify	= false;
				this.storeBlock( this.response, this.#note ).then( stored =>{
					//checking if the block concerns us.
					this.recieveTransaction().then( recieved =>{
						this.checkFormerBlock().then( checked =>{
							this.shareData(100);
						});						
					});
				});
			}
		} else {
			//May be it's a message
			this.successMessage( data );
		}
	}
	
	static closeDataChannels(){
		this.sendChannel.close();
		this.localConnection.close();
		this.recieveChannel.close();
 	}
	
	static onIceCandidate( connection, event ){
		connection.addIceCandidate(event.candidate)
      .then(
          this.onAddIceCandidateSuccess,
          this.onAddIceCandidateError
      );
	}
	
	static onAddIceCandidateSuccess(){
		//console.log('AddIceCandidate success.');
	}
	
	static onAddIceCandidateError(){
		//console.log(`Failed to add Ice Candidate: ${error.toString()}`);
	}
	
	static async getServerCurrentBlock(){
		//console.log("getServerCurrentBlock running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "getServerCurrentBlock";	
		let x;
					
		setInterval( async ()=>{
			await this.runGetCurrentBlock();
		}, 1000 );
		
	}
	
	static async runGetCurrentBlock(){
		let x, server, data;
		server = this.#default_scriptbill_server;
				
		if( this.#note )
			server 	= this.#note.noteServer;
		
		if( this.s.processingData ) {
			setTimeout( ()=>{
				this.runGetCurrentBlock();
			},1000 );
			return;
		}
		
		try {
			if( ! this.run )
				this.run = 1;
			
			//console.log( "Running ", this.run );
			this.run++;
			
			let obj 	= {};
			obj.currentBlock 			= "TRUE";
			obj.noteServer 				= server;
			obj.defaultServer 			= this.#default_scriptbill_server;
			this.s.processingData = true;
			if( typeof chrome == "undefined" && chrome.runtime && Object.hasOwn("onMessage") ){
				chrome.runtime.sendMessage(obj);
				
				if( ! server.includes( this.#default_scriptbill_server ) && this.#note ){
					obj.noteServer 		= this.#default_scriptbill_server + this.#note.noteAddress.slice(0, 24).replaceAll('/','_');
					chrome.runtime.sendMessage(obj);
				}			
				
				chrome.runtime.onMessage.addListener( async (message, sender, sendResponse) => {
					//console.log("message current", message);
					if( message && message.blockID ){
						data  			= JSON.parse( JSON.stringify( message ) );
						this.response  	= JSON.parse( JSON.stringify( data ) );
									
						if( data.blockID == this.l.currentBlock || data.blockID ==  this.l.processedBlock || ( this.#note && this.#note.blockID == data.blockID ) ) return;
									
						this.l.currentBlock = data.blockID;
						this.l.processedBlock = data.blockID;				
						this.checkReferers( data, this.#note ).then( result =>{
							//console.log("recieving new block 1 " + this.response.blockID);
							this.recieveNewBlock(data).then( block =>{
								if( ! block )
									delete this.l.processedBlock;
								
								this.#noVerify	= false;
								this.storeBlock( data, this.#note ).then( stored =>{
									delete this.s.processingData;
									this.runGetCurrentBlock();									
								});
								
							});
						});								
					}
				});
				return;
			} else {
				const myWorker = new Worker("share.js");
				myWorker.postMessage( obj );
				myWorker.onmessage = (event)=>{
					const data = event.data;
					if( data && data.blockID ){
						this.response  	= JSON.parse( JSON.stringify( data ) );
											
						if( data.blockID == this.l.currentBlock || data.blockID ==  this.l.processedBlock || ( this.#note && this.#note.blockID == data.blockID ) ) return false;
									
						this.l.currentBlock = data.blockID;
						this.l.processedBlock = data.blockID;				
						this.checkReferers( data, this.#note ).then( result =>{
							//console.log("recieving new block 1 " + this.response.blockID);
							this.recieveNewBlock(data).then( block =>{
								if( ! block )
									delete this.l.processedBlock;
								
								this.#noVerify	= false;
								this.storeBlock( data, this.#note ).then( stored =>{
									delete this.s.processingData;
									this.runGetCurrentBlock();									
								});
								
							});
						});								
					}
				}
			}		
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	static async checkReferers( response, note ){
		let referers 		= note.referer;
		let refSign 		= response.referer;
		
		if( ! referers || ! refSign ) return false;
		
		let result 			= this.decrypt( refSign, referers );
		
		if( ! this.isJsonable( result ) ) return false;
		
		result 				= JSON.parse( result );
		let value 			= 0;
		
		if( ( response.transType == "DEPOSIT" || response.transType == "PROFITRECIEVE" ) && result.loanValue ){
			value 			= parseFloat( response.transValue ) - parseFloat( result.loanValue );
			
			if( value > 0 ){
				note.groupValue 	= parseFloat( note.groupValue ) + ( value * 0.2 );
				
				if( ! note.withdrawalStance || typeof note.withdrawalStance != "object" )
					note.withdrawalStance = {amount:0, rate:0};
				
				note.withdrawalStance.amount 	= parseFloat( note.withdrawalStance.amount ) + ( value * 0.1 );
				
				let rate = parseFloat( note.withdrawalStance.amount ) / parseFloat( note.noteValue );
				
				if( rate > 1 )
					note.withdrawalStance.rate = 1;
				
				else 
					note.withdrawalStance.rate = rate;
				
				note.withdrawalStance.rate 		= note.withdrawalStance.rate .toString();
			}
			
			if( response.transType == "DEPOSIT" && response.agreement && typeof response.agreement == "object" && response.agreement.agreeType == "ADVERT" ){
				value = this.l[ note.noteAddress.slice(0,12).replaceAll(/[^a-zA-Z0-9]/g, "_") + "_advert_earnings" ];
				
				if( ! value )
					value 	= 0;
				
				else
					value 	= parseFloat( value );
				
				let percent 		= parseFloat( response.transValue ) * 0.1;
				
				value 				+= percent;
				this.l[ note.noteAddress.slice(0,12).replaceAll(/[^a-zA-Z0-9]/g, "_") + "_advert_earnings" ] = value;
			}
		} 
		else if( response.transType == "WITHDRAW" ){
			value 				= parseFloat( response.transValue ) * 0.2;
			
			note.groupValue 	= parseFloat( note.groupValue ) - value ;
			
			if( ! note.withdrawalStance || typeof note.withdrawalStance != "object" )
					note.withdrawalStance = {amount:0, rate:0};
				
			note.withdrawalStance.amount 	= parseFloat( note.withdrawalStance.amount ) - ( value * 0.1 );
			
			let rate = parseFloat( note.withdrawalStance.amount ) / parseFloat( note.noteValue );
			
			if( rate > 1 )
				note.withdrawalStance.rate = 1;
			
			else 
				note.withdrawalStance.rate = rate;
			
			note.withdrawalStance.rate 		= note.withdrawalStance.rate .toString();
		}
		let details 		= JSON.parse( JSON.stringify( response ));
		details.transType 	= "UPDATE";
		details.transValue 	= 0;
		details.agreement 	= "";
		//because it succesfully decrypted the result.
		return await this.generateScriptbillTransactionBlock(details, note );
	}
	static async recieveData(){
		//console.log("recieveData running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "recieveData";
		
		//initializing storage.
		
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note 		= await this.#getCurrentNote();
			
			if( this.#note && ! this.walletID ){
				this.walletID 	= this.#note.walletID;
			}
			
			if( this.s.processingData ){
				setTimeout( ()=>{
					this.recieveData();
				}, 5000 );
				return false;
			}
			
			//without the walvar id, no recipient
			if( ! this.walletID || ! this.#note ) return false;
			
			let latestTime 	= this.l[this.#note.noteAddress.slice(0,12).replaceAll(/[^a-zA-Z0-9]/g, "_") + "_trans_time"];
			
			if( latestTime == undefined ) 
				latestTime = this.#note.transTime;
			
			let obj 				= {};
			obj.streamKey 			= this.#note.walletID;
			obj.latest 				= "TRUE";
			obj.time 				= latestTime;
			obj.noteServer 			= this.#note.noteServer;		
			obj.defaultServer 		= this.#default_scriptbill_server;		
			let response 			= null;
			if( typeof chrome != "undefined" && chrome.runtime && Object.hasOwn("onMessage")){
				//console.log( "Sending Message", obj );
				chrome.runtime.sendMessage(obj);
				chrome.runtime.onMessage.addListener( async (message, sender, sendResponse) => {
					//console.log("message latest", message);
					response 		= JSON.parse( JSON.stringify( message ));
					if( ! response || ! response.data || this.s.processingData ) return false;
					
					this.s.processingData = true;
					this.IP 	  	= 	response.IP;
					this.PORT	 	= 	response.PORT;
					response 		=  JSON.parse( JSON.stringify( response.data ) );
					let x, block;
					
					//console.log( "typeof response at recieve data: ", typeof response );
					let data;
					if( response.length ){
						for( x = 0; x < response.length; x++ ){
							if( ! response[x] || ! ( this.isJsonable( response[x] ) || typeof response[x] == "object" ) ) continue;
							
							if( this.isJsonable( response[x] ) )
								data 	= JSON.parse( response[x] );
							
							if( ! data.blockID || this.l.currentBlock == data.blockID ) continue;
							
							setTimeout( (data, response )=>{
								this.response = JSON.parse( JSON.stringify( data ) );
								this.l[this.#note.noteAddress.slice(0,12).replaceAll(/[^a-zA-Z0-9]/g, "_") + "_trans_time"] 		= data.transTime;
								this.l.currentBlock 	= data.blockID;
								
								this.checkReferers( data, this.#note ).then( result =>{
									this.#noVerify		= false;
									//console.log("recieving new block 2: " + response[x].blockID);
									this.storeBlock( data, this.#note ).then( stored =>{
										this.recieveNewBlock( data ).then( recieved =>{
											if( ( x + 1 ) == response.length ){
												delete this.s.processingData;
												setTimeout( ()=>{
													this.recieveData();
												}, 5000 );	
											}											
										});
									});
								
								});								
							}, 1000 * ( x + 1 ), data, response );
														
						}
					} else if( response.blockID ){
						if( response.blockID == this.l.currentBlock ) return;
						this.l.latesTime 		= response.transTime;
						this.l.currentBlock 	= response.blockID;
						this.checkReferers( response, this.#note ).then( result =>{
							this.#noVerify			= false;
							//console.log("recieving new block 3" + response.blockID);
							this.storeBlock( response ).then( stored =>{
								this.recieveNewBlock( response ).then( recieved =>{
									delete this.s.processingData;
									setTimeout( ()=>{
										this.recieveData();
									},5000 );
								});
							});							
						});					
					}					
				});
				return true;
				
			} else {
				const myWorker = new Worker("share.js");
				myWorker.postMessage( obj );
				myWorker.onmessage = (event)=>{
					const response = event.data;

					if( ! response || ! response.data || this.s.processingData ) return false;
					
					this.s.processingData = true;
					this.IP 	  	= 	response.IP;
					this.PORT	 	= 	response.PORT;
					response 		=  JSON.parse( JSON.stringify( response.data ) );
					let x, block;
					
					//console.log( "typeof response at recieve data: ", typeof response );
					let data;
					if( response.length ){
						for( x = 0; x < response.length; x++ ){
							if( ! response[x] || ! ( this.isJsonable( response[x] ) || typeof response[x] == "object" ) ) continue;
							
							if( this.isJsonable( response[x] ) )
								data 	= JSON.parse( response[x] );
							
							if( ! data.blockID || this.l.currentBlock == data.blockID ) continue;
							
							setTimeout( (data, response )=>{
								this.response = JSON.parse( JSON.stringify( data ) );
								this.l[this.#note.noteAddress.slice(0,12).replaceAll(/[^a-zA-Z0-9]/g, "_") + "_trans_time"] 		= data.transTime;
								this.l.currentBlock 	= data.blockID;
								
								this.checkReferers( data, this.#note ).then( result =>{
									this.#noVerify		= false;
									//console.log("recieving new block 2: " + response[x].blockID);
									this.storeBlock( data, this.#note ).then( stored =>{
										this.recieveNewBlock( data ).then( recieved =>{
											if( ( x + 1 ) == response.length ){
												delete this.s.processingData;
												setTimeout( ()=>{
													this.recieveData();
												}, 5000 );	
											}											
										});
									});
								
								});								
							}, 1000 * ( x + 1 ), data, response );
														
						}
					} else if( response.blockID ){
						if( response.blockID == this.l.currentBlock ) return;
						this.l.latesTime 		= response.transTime;
						this.l.currentBlock 	= response.blockID;
						this.checkReferers( response, this.#note ).then( result =>{
							this.#noVerify			= false;
							//console.log("recieving new block 3" + response.blockID);
							this.storeBlock( response ).then( stored =>{
								this.recieveNewBlock( response ).then( recieved =>{
									delete this.s.processingData;
									setTimeout( ()=>{
										this.recieveData();
									},5000 );
								});
							});							
						});					
					}
				}
			}
			
			//this.response 		= await this.getData(["streamKey", "latest", "time"], [this.#note.walletID, "true", latestTime], this.#note.noteServer );
			
			//console.log( "the response: ", this.response );
			
				
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async checkFormerBlock(){
		
		if( ! this.response || ! this.runResponse ) return;
		
		try {
			let response = JSON.parse( JSON.stringify( this.response ) );
			
			setTimeout( async ()=>{
				if( ! this.l[ response.exFormerBlockID ] ){
					block 		= await this.getData("exBlockID", response.exFormerBlockID, this.#default_scriptbill_server);
					if( ! this.blockNo )
						this.blockNo = 1;
					
					if( block && block.blockID ){
						setTimeout(()=>{
							this.response 	= block;
							this.runResponse = block;
							if( this.blockNo < 100 ){
								this.blockNo++;
								this.checkFormerBlock();						
							}else{
								delete this.blockNo;
							}
						}, 1500);
						
					} else if( block && block.length && block.length > 0 ){
						let x;
						for( x = 0; x < block.length; x++ ){
							setTimeout((x,block)=>{
								this.response = block[x];
								this.runResponse = block[x];
								if( this.blockNo < 100 ){
									this.blockNo++;
									this.checkFormerBlock();						
								}else{
									delete this.blockNo;
								}
							}, ( 1000 *(x+1)), x, block);
						}
					}
				}
			}, 1000);
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}		
	}
	
	static async checkNextBlock(){
		if( ! this.response ) return false;
		
		try {
			let nextBlockID 	= this.response.nextBlockID;
			let server 			= this.response.noteServer;
			
			this.#note 			= await this.#getCurrentNote();
			
			if( this.#note.blockID == this.response.blockID )
				server 			= this.#note.noteServer;
			
			try {
				let url 		= new URL( server );
				this.url 		= url.href;
				this.blockID 	= nextBlockID;
				let block 		= await this.getTransBlock();
				
				if( block && block[0].blockID ){
					return true;
				}
			} catch( e ){
				//console.log( e );
				return false;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async recieveTransaction(){
		//console.log("recieveTransaction running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "recieveTransaction";
		
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
			
			if( ! this.#note && ! this.response && ! this.#note.noteAddress && ! this.response.blockID ) return false;
			
			this.details 		= JSON.parse( JSON.stringify( this.response ) );
			//check the send and agreement transactions which would likely loved to be processed automatically as we recieve 
			//the blocks
			if( this.#transSend.includes( this.response.transType ) || this.response.transType == "AGREEMENTREQUEST" ) {
				
				if( this.response.transType == "PROFITSHARING" )
					this.details.transType = "PROFITRECIEVE";
				
				else if( this.response.transType == "INVEST" )
					this.details.transType = "INVESTRECIEVE";
				
				else if( this.response.transType == "AGREEMENTREQUEST" )
					this.details.transType = "AGREEMENTSIGN";
				
				else if( this.response.transType == "ADVERT" )
					this.details.transType = "VIEWADVERT";
				
				else
					this.details.transType = "RECIEVE";
				
				return await this.generateScriptbillTransactionBlock( this.details, this.#note );
			} 
		}catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
		
	}
	
	static async sendData( data = false ) {
		//console.log("sendData running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "sendData";
		try {
			if( this.response || this.data ) {
				if( this.response )
					this.data = this.response;
								
			}
			
			if( ! data )
				data 	= this.data;
				
			
			if( ! data ) return;
			
			if( this.sendChannel ){		
				this.sendChannel.send(JSON.stringify( data));
			}
			
			if( ! this.#note && this.s.currentNote )
				this.#note 	= await this.#getCurrentNote();
			
			if( ( ! this.#note || ! this.#note.walletID ) || ! this.executeStrictly	) return;
			
		//	await this.createAlert("send data return not");
			
			let url = this.executeStrictly ? this.#default_scriptbill_server: this.#note.noteServer;
			if( data.blockID ) {
				setTimeout( ()=>{
					this.response 	= JSON.parse( JSON.stringify( data ) );
					this.shareData( false, data );			
					//console.log( 'blockID ' + this.data.blockID );			
				}, 500 );
				return this.response;
			}
			
			
			data = await this.getData('data', JSON.stringify( data ), url);
					
			this.response = data;
			return this.response;
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
		
	}
	
	static async getNoteBudgets(){
		//console.log("getNoteBudgets running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getNoteBudgets";
		if( ! this.#note )
			return null;
		
		try {
			let budgets = this.#note.noteBudgets;
			
			if( ! budgets || ! budgets.length )
				return null;
			
			//console.log( JSON.stringify( this.#note ) );
			return null;
					
			if( typeof budgets == 'string' && ! this.isJsonable( budgets ) ) return null;		
			
			let x, privKey, budgetID, results = [], budget;
			for( x = 0; x < budgets.length; x++ ){
				privKey = budgets[x];
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( privKey, id );
				budgetID 		= await this.getPublicKey(id);
				budget 			= await this.getCurrentBudgetBlock( budgetID );
				
				if( budget.agreement ){					
					result.push( budget );
				}
			}
			
			return results;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return null;
		}
	}
	
	static async getNoteSubscription(){
		let storage = this.s;
		try {
			if( ! this.#note && storage.currentNote )
				this.#note 		= await this.#getCurrentNote();
			
			if( ! this.#note || ! this.#note.noteSubs )
				return null;
			
			let noteSubs 	= this.#note.noteSubs;
			let productID, sub, block, result = [];
			
			for( productID in noteSubs ){
				sub 		= noteSubs[ productID ];
				this.productBlockID		= sub.subsID;
				block 		= await this.getTransBlock();
				block 		= block[0];
				
				if( block && block.blockID ){
					block.subscription = sub;
					result.push( block );
				}
			}
			
			return result;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return null;
		}
	}
	static async calculateLoanEligibility(){
		this.funcUp[ this.funcUp.length ] = "calculateLoanEligibility";
		//alert( "Yeah" );
		if( ! this.#note && this.s.currentNote )
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note || this.#note.noteType.lastIndexOf("BND") == 3 || this.#note.noteType.lastIndexOf("STK") == 3) {
			this.errorMessage("No note was found while calculating eligibility or you are not logging in a credit note.");
			return 0 ;
		}
		let note 		= JSON.parse( JSON.stringify( this.#note ));
		
		let currentNote = await this.getCurrentExchangeNote( note.noteType );
		
		//console.log(  currentNote.demandValue, currentNote.noteValue, currentNote.exchangeValue );
		/* if( ! currentNote || ! currentNote.demandValue || ! currentNote.noteValue || ! currentNote.exchangeValue )
			return 0; */
		
		let enoteValue 		= parseFloat( currentNote.noteValue );
		let demandValue 	= parseFloat( currentNote.demandValue );
		let exValue 		= parseFloat( currentNote.exchangeValue );
		//this ratio tells us how much of the credit demanded is valued in the exchange market 
		//account. The note value holds the value of funds deposited to the exchange market 
		//credit account.
		//sometimes the exchange value can represent the loan value as it represent the CREDIT
		//held by the exchange market.
		let demandRatio 	= ( enoteValue + exValue ) / demandValue;
		
		//the loan value will be the demand ratio multiplied by the demand value.
		//this is expected to give a rough value of the number of credit that can be mined as 
		//loan at the particular time.
		let loanValue 		= demandValue * demandRatio;
		
		if( isNaN( loanValue ) || ! demandValue )
			loanValue = 0;
		
		//if there are previously unpaid loan in the network the loan value should be 
		//influenced by this
		let lastLoan = 0;
		
		if( currentNote.loanValue )
			lastLoan  = parseFloat( currentNote.loanValue );
		
		loanValue 		= loanValue - lastLoan;
		
		let trans			= await this.getNoteTransactions();
		let transTime 		= parseInt( this.currentTime() ) - parseInt( this.calculateTime( "2 weeks" ) ); 
		let eligibility 	= 1;
		
		let loanVal			= 0;
       // let transTypes      = Scriptbill.getTransTypes();
		let block, no;
		
		
		//looping through the transaction, the limit is 1000 transactions and the transTime limit is last week.
		let processedIDs = [];
		for( no = ( trans.length - 1); no >= 0; no-- ){
			block 				= trans[no];
			if( typeof block == "string" ){
				try {
					block = JSON.parse( block );
				} catch(e){
					console.error( "could not parse a transaction block, the error " + e, "the block: " + block );
				}
			}
					
			if(block && ( this.#transRecieve.includes( block.transType ) || block.transType == "DEPOSIT" || block.transType == "WITHDRAW" || this.#transSend.includes( block.transType ) )  && parseInt( block.transTime ) < transTime ) {
			
				if( block.transType == 'PROFITRECIEVE' && block.budgetID && ! processedIDs.includes( block.budgetID ) ){
					 processedIDs.push( block.budgetID );
					 eligibility     += parseFloat( block.transValue ) * 3.5;
				} else if( block.transType == "WITHDRAW" || this.#transSend.includes( block.transType ) ){
					eligibility 		-= 		parseFloat( block.transValue );
				} else {
					eligibility 	+= parseFloat( block.transValue );
				}
			} 
		}		
		
		let accountData   		= await this.getAccountData();
		let url 				= new URL( this.#default_scriptbill_server );
		//url.searchParams.set('paypal-acc', note.walletID );

		let ret = await this.getData('paypal-acc', note.walletID, url.href );


       /*  if( ( ! accountData[ note.noteAddress ] || ! accountData[ note.noteAddress ].savedCards ) && ( ! ret || ( ! ret.userName && ! ret.isVerified)) ){
          await this.createAlert('An Card or PayPal Account Must Be Associated with This note to access loans. Redirecting you to your Profile Page to add an Account!');
          location.href = bankUrl;
        }
		 */
		let noteValue 			= note.noteValue;
		let testType 			= note.noteType.slice(0, note.noteType.lastIndexOf("CRD"));
		if( accountData.loanValue )
			loanVal 		+= parseFloat( accountData.loanValue );

        let ranks 			= this.getRanks();
		/*
		if( ! accountData.rank || ( ranks[accountData.rank] && ranks[accountData.rank].credit_level < 10000))
			accountData.rank = "SJUSGRFIDUGVDISCSI";*/
		let creditLevel = 0;
		if( accountData.rankCode ){
			
			if( ranks[accountData.rankCode] ){
				creditLevel 	= ranks[accountData.rankCode].credit_level;
				
				let rates 	= await fetch( "/exRate.json" ).then( resp =>{ return resp.json() }).then( result =>{ return result.rates; }).catch( error =>{ console.error( error ); return {}; } );
				
				creditLevel 	= creditLevel * rates[ testType ];
				if( accountData.value )
					eligibility 	+= parseFloat( accountData.value ) / rates[ testType ];
				
				eligibility 	+= creditLevel * 0.5;
				
				eligibility		-= loanVal; 
			}
		}
		//console.log("loanval", loanValue, "eligibility", eligibility, "loanval", loanVal );
		if( loanValue < eligibility )
			eligibility 			= ( eligibility - ( creditLevel * 0.5 ) ) + (( eligibility - ( creditLevel * 0.5 ) ) *  0.25 );
		
		if( loanValue < eligibility )
			loanValue 				= loanValue + ( eligibility - loanValue );
		
		return loanValue;
	}
	
	static async getNoteTransactions(){
		this.funcUp[ this.funcUp.length ] = "getNoteTransactions";
		let storage = this.s;
		let local 	= this.l;
		
		try {
			
			this.#note 		= await this.#getCurrentNote();
			//console.log("note: " + JSON.stringify( this.#note ));		
			if( ! this.#note )
				return [];
			//alert("checks 2");
			//console.log("note: " + JSON.stringify( this.#note ));
			//let local;
			
			if( ! localStorage[ this.#note.noteAddress ] || ! this.isJsonable( localStorage[ this.#note.noteAddress ] ) ) {
				local 	= [];
			} else {			
				local = JSON.parse( localStorage[ this.#note.noteAddress ] );
			}
			//await this.createAlert("something in tr");
			//get stored trans.
			
			let stored 	= await window.navigator.storage.getDirectory("scriptStorage", {create: true}).catch( error =>{this.errorMessage( error.toString() );  return false;});
			
			if( ! stored ){
				this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
				return false;
			}
			
			stored 		= await stored.getDirectoryHandle( this.#note.noteAddress, {create:false} ).catch( error =>{this.errorMessage( error.toString() );  return false;});
			/* await this.createAlert("something ou tr"); */
			//console.log( "stored: " + JSON.stringify( stored ));
			if( stored ){
			 let file, text, blocky, block;
				for await( const value of stored.values()){
					//////console.log('value: ' + value );
					try {
						file 		= await value.getFile();
						text 		= await file.text();
						block 		= this.isJsonable( text ) ? JSON.parse( text ) : {};
						
						if( ! block.noteAddress && ! block.noteSecret && block.blockID )
							local.push( block );
						/* if( local[ local.length - 1 ] && local[ local.length - 1 ].transTime < block.transTime ) 
							local.push( block );
						
						else {
							for( let x = local.length - 1; x >= 0; x-- ){
								if( local[ x ] && local[ x ].transTime < block.transTime ){
									local.splice( x, 0, block );				
								} else {
									local.push( block );
								}
							}
						} */
					} catch( e ){
						//////console.log('couldn\'t fetch data error: ', e);
					}
				}
				//console.log(local);
				return local;
			} else {
				return local;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return null;
		}
	}
	
	static async getNoteAgreements(){
		let storage = this.s;
		let local 	= this.l;
		try {
			if( ! this.#note && storage.currentNote )
				this.#note 		= await this.#getCurrentNote();
			
			if( ! this.#note )
				return null;
					
			let block 		= null;
			
			if( this.l[this.#note.noteAddress + '_current_block'] ){
				block 	= JSON.parse( this.l[this.#note.noteAddress + '_current_block'] );
			} else {
				block 	= await this.getNoteTransactions();
				let transTimes = [];
				for( let x = 0; x < block.length; x++ )
					transTimes.push( block[x].transTime );
				
				let lastTimes = JSON.parse( JSON.stringify( transTimes ));
				transTimes.sort();

				let key = lastTimes.indexOf( transTimes[0] );
				block 	= block[key];
			}
			
			if( ! block.agreements ) return null;
			
			return block.agreements;
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return null;
		}
	}
	
	static async saveNoteDetails( key, details ){
		
		let storage = this.s;
		
		if( ! this.#note && storage.currentNote )
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note ) {
			this.errorMessage("No note data while trying to save note details");
			return;
		}
		
		//test the key and details
		if( typeof key != "string" || typeof details != "string" ) {
			this.errorMessage("details or key must be in string format");
			return;
		}
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( this.#note.noteSecret, id );
		//await this.createAlert("encrypt note secret: " + this.#note.noteSecret);
		
		this.#encrypt( details, id ).then( async encrypt =>{
			
			if( ! encrypt || ! chrome.storage ) {
				this.errorMessage("storage of note data can't be done on a local website. If done on an extension or mobile app, then your note details was not properly configured.");
				return;
			}
			
			let savedCards = await chrome.storage.sync.get(key);
			
			if( savedCards[key] ){
				savedCards 		= JSON.parse( savedCards[key] );
			} else {
				savedCards 		= [];
			}
			
			savedCards.push( encrypt );
			
			chrome.storage.sync.set({[key]: JSON.stringify( savedCards )});			
		});
	}
	
	static async getNoteDetails( key ){
		let storage = this.s;
		
		if( ! this.#note && storage.currentNote )
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note ) {
			this.errorMessage("no note data installed while trying to get note details..");
			return;
		}
		
		if( typeof key != "string" ) {
			this.errorMessage("your note details can only be gotten with a string key type..");
			return;
		}
		
		if( ! chrome.storage ){
			this.errorMessage("Can't get a note detail in a non app or extension environment..");
			return;
		}
		
		let data = await chrome.storage.sync.get( key );
		
		if( ! data[ key ] ){
			this.errorMessage("no note data found associated with this key: " + key);
			return;
		} else {
			data 		= data[ key ];
		}
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( this.#note.noteSecret, id );
		//await this.createAlert("decrypting profit keys: " + this.#note.profitKeys );
		
		let result = await this.#decrypt( data, id );
		
		if( result && Scriptbill.isJsonable( result ) )
			result 		= JSON.parse( result );
		
		return result;
	}
	
	static async shareData( limit = true, response = false ){
		//console.log("shareData running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "shareData";
		
		if( ! this.funcUpCheck ){
			let setLen 	= this.setLen && typeof this.setLen == "number" ? this.setLen : 20;
			this.funcUpCheck = setInterval(()=>{
				setLen 	= this.setLen && typeof this.setLen == "number" ? this.setLen : setLen;
				if( this.funcUp.length > setLen ){
					let rem = this.funcUp.length - setLen;
					this.funcUp.splice( rem, this.funcUp.length );
					
				}
			}, 2000);
		}

		console.log("Inside Share Data: ");
		
		if( this.shareDataRunning && limit ) return;

		console.log("Won Share Data and Limit ");
		
		if( typeof chrome != "undefined"  && chrome.runtime && Object.hasOwn( chrome.runtime, "onMessage" )){
		
			chrome.runtime.onMessage.addListener( async (message, sender, sendResponse )=>{
				if( message.runBlock ){
					let lastRunBlock = Scriptbill.l.lastRunBlock;
					
					if( lastRunBlock && lastRunBlock == message.runBlock ) return;
					
					Scriptbill.l.lastRunBlock 	= message.runBlock;
					let data = await this.getDataPersistently( message.runBlock );
					
					if( data && data.blockID ){
						this.sharePersistently = true;
						this.shareData( false, data );
					}
				}
				
				else if( message.createRequest ){
					response 	= JSON.parse( JSON.stringify( message.block ));
					let password = message.password;
					
					if( this.l.depositID == response.blockID || ! response.transType == "DEPOSIT" || ! response.agreement || ! response.agreement.agreeKey ) return;
					this.l.depositID = response.blockID;
					
					this.details  	= JSON.parse( JSON.stringify( response ));
					this.details.transType = "AGREEMENTREQUEST";
					this.details.recipient = response.agreement.agreeKey;
					this.details.password  = password;
					this.details.agreement = JSON.parse( JSON.stringify( response.agreement ));
					let block = await this.generateScriptbillTransactionBlock( this.details, this.#note, response );				
					
					if( block && block.transType == "AGREEMENTREQUEST" ){
						
						if( ! this.#note )
							this.#note = await this.#getCurrentNote();
						
						let agreement = this.#note.agreements.filter((agrees)=>{
							return agrees.agreeID == response.agreement.agreeID;
						});
						
						if( agreement && agreement.key ){
							block.exchangeNote.agreement = agreement.key.split("----")[0];
							this.details 		= JSON.parse( JSON.stringify( block ));
							this.details.transType = "AGREEMENTSIGN";
							this.details.password = password;
							this.details.agreement = JSON.parse( JSON.stringify( response.agreement ));
							//this.#isExchangeMarketMining = true;
							this[this.#odogwu] = true;
							this.generateScriptbillTransactionBlock( this.details, this.#note, block );
						}
					}
					
				}
			});
		
		}
		//this.getData( "shareScriptbillData", this.Base64.encode( JSON.stringify( this.#default_scriptbill_servers ) ), this.#default_scriptbill_server );
		
		let shareData = async ( blocks, countShares, blockIDs )=>{
			try	{
				let blocked 	= blocks[ countShares ], nextBlock, time;

				console.log("Block gotten: ", blocked );
				
				//sharing the block to the network to encourage data consistency					
				
				if( blocked && blocked.blockID ){
					//console.log("is block? " , ( blockIDs.includes( blocked.blockID ) && ! blockIDs.includes( blocked.formerBlockID ) ) );
					//block 		= await this.getData("blockID", blocked.blockID, this.#default_scriptbill_server );
					if( blockIDs.includes( blocked.blockID ) && ! blockIDs.includes( blocked.formerBlockID ) ){
						let realBlock = await this.getTransBlock(1, {blockID: blocked.formerBlockID});
						realBlock 		= realBlock[0];
						//console.log("Drilling...", realBlock.blockID );
						
						if( realBlock && realBlock.blockID ){
							this.#setNoteBlocks = true;
							this.storeBlock( realBlock );
						}
					}
					console.log("sharing block: ", blocked.blockID )
					//this.response = JSON.parse( JSON.stringify( blocked ));
					this.shareData(false, blocked);
					
					time = this.currentTime();					
					//checking if the block has expired
					if( blocked && blocked.nextBlockID && typeof blocked.nextBlockID == "string" )
						nextBlock 		= await this.resolvePersistentData(blocked.nextBlockID);
					
					//delete the current block only if the block has a next block in her chain
					//and at least 12 witnesses in his chain.
					if( nextBlock && nextBlock.blockID && blocked.expiry <= time )
						this.deleteBlock( blocked.blockID );
											
					//handle the agreement and subscriptions on the block.
					return await this.handleAgreement( blocked ).then( finished =>{
						return finished;
					});
				} else {
					return false;
				}	
				
				/* this.handleSubscriptions().then( isHandled =>{
					this.response = this.block;
					this.recieveNewBlock().then( recieved =>{
						this.initiateExchange().then( async isInitiated =>{
							//we first of all set the current window as location url, if not we revert to the default server.
							//test if the current server is a Scriptbill Server.					
								
							if( ! isScriptbill )
								url = this.#default_scriptbill_server;
							
							//next is to check if the current block is fully verified.
							if( ! block.witnesses || ( block.witnesses && block.witnesses.length < 12 ) ){
								block = await this.resolveRemoteData( 'blockID', block.blockID, url );
								if( block && block.blockID ){
									//attempting to verify block
									this.response = JSON.parse( JSON.stringify( block ) );
									this.storeBlock();
								}
							}								
							//next is to check if the current block has a next block saved.
							if( block && block.nextBlockID && nextBlock && nextBlock.blockID == block.nextBlockID )
								return;
							
							else {					
								
								data 		= await this.getData('blockID', block.nextBlockID, url );
								
								if( data != 'BLOCK NOT FOUND' && this.isJsonable( data ) ){
									this.response = JSON.parse( data );
									
								} else if( typeof data == "object" && data.blockID ){
									this.response = JSON.parse( JSON.stringify( data ) );
								}
								this.recieveNewBlock();					
							}
							
							
						});
					});					
				}); */
			} catch(e){
				console.error(e);
				return false;
			}
		}

		if( ! limit ){ 
			
			
			if( typeof this.response == "string" && this.isJsonable( this.response ) && ! response && ! response.blockID )
				response 		= JSON.parse( this.response );
			
			else if( ! response && ! response.blockID && this.response && this.response.blockID )		
				response 			= JSON.parse( JSON.stringify( this.response ));
			
			else if( ! response && ! response.blockID ){
				this.errorMessage(" No Transaction Block to Share" );
				return false;
			}

			console.log("share data now running for: ", response.blockID )
			
			if( response && ( ! response.exchangeNote || ! response.exchangeNote.exchangeKey ) ){
				try {
					if( typeof response == "string" && Scriptbill.isJsonable( response ) )
						response 		= JSON.parse( response );
					
					let exchangeNote 	= await this.getCurrentExchangeNote( response.noteType );
					
					if( exchangeNote && exchangeNote.exchangeID ){
						response.exchangeNote = exchangeNote;
					}
				} catch(e){
					console.error(e);
					this.errorMessage(e.toString());
					return false;
				}
			}
			
			let servers 	= this.l.scriptbillServers && this.isJsonable( this.l.scriptbillServers ) ? JSON.parse( this.l.scriptbillServers ) : [];
			console.log("share data now running for: ", response.blockID, "part 2" )
			
			let obj 			= {};
			obj.dataMes			= JSON.stringify( response );
			obj.encoded 		= Scriptbill.Base64.encode( obj.dataMes );
			obj.dataIntent 		= "shareData";
			obj.clients 		= JSON.stringify( servers );
			obj.defaultServer 	= this.#default_scriptbill_server;
			obj.note 			= JSON.stringify( this.#note );
			
			if( this.sharePersistently ){
				obj.runPersistently = true;
				delete this.sharePersistently;
			}

			this.runWebSocket(response, this.#note ? this.#note.noteServer : this.#default_scriptbill_server )
			
			try {
				chrome.runtime.sendMessage(obj);
				return true;
			}
			catch( e ){
				try {
					const myWorker = new Worker("share.js");
					myWorker.postMessage( obj );
					return true;
				} catch( e ){
					console.error( e );
					return false;
				}
			}
		} else {
				console.log("share data else is running! ");		
			try {			
				this.shareDataRunning	= true;
				const url 			= location.origin;
				
				return await this.resolveRemoteData( 'scriptbillPing', 'TRUE', url ).then(data =>{
					let isScriptbill 	= false;
					if( typeof data == 'object' && data.isScriptbillServer == 'TRUE' ){
						isScriptbill = true;
					}
					
					if( typeof limit != "number" )
						limit = 100;

					console.log("Resolved Data: ", data, "limit: ", limit)
					
					this.getNoteTransactions().then( blocks =>{
						console.log("note blocks gotten: ", blocks )
						this.resolvePersistentData("ALL", limit ).then(serveblocks =>{
							console.log("stored blocks gotten: ", serveblocks)
							blocks 			= blocks.concat( serveblocks );
							
							const blockIDs 	= blocks.map( (block)=>{
								return block.blockID;
							});
							
							//console.log( "block length: " + blocks.length );
							//await this.createAlert( "block length: " + blocks.length );
							
							//check whether there is the note's block in the storage.			
							if( this.#note && this.#note.blockID ) {								
								this.resolvePersistentData( this.#note.blockID ).then(async block=>{
									if( ! block ){
										block 				= await this.getTransBlock(1, {blockID: this.#note.blockID});
										block 				= block[0];						
									}

									if( block && block.blockID ) {
										this.response = JSON.parse( JSON.stringify( block ) );
										this.#noVerify	= false;
										this.storeBlock(block, this.#note);
									}
								});								
							}
							
							let countShares = 0
							
							for( countShares = 0; countShares < limit && countShares < blocks.length; countShares++ ){
								setTimeout( async (countShares, blocks, limit, blockIDs )=>{              
									/*if(  this.isSharingData ){
										let shareInterval = setInterval( ()=>{
											if( this.isSharingData ) return;
											
											this.isSharingData 		= true;
											clearInterval( shareInterval );
											shareData( blocks, countShares, blockIDs ).then( shared =>{
												if( ( countShares + 1) == limit ){
													this.shareDataRunning = false;
													//this.shareData();
												}
												
												this.isSharingData = false;
											});
										}, 1000, countShares, blocks, limit );
										return;
									}
									this.isSharingData 	= true;*/
									console.log("count shares running: ", countShares, " limit: ", limit )
									shareData( blocks, countShares, blockIDs ).then( shared =>{
										if( ( countShares + 1) == limit ){
											this.shareDataRunning = false;
											setTimeout(()=>this.shareData(), 60000 );
										}
										
										this.isSharingData = false;
									});					
								}, ( 10000 * ( countShares + 1 ) ), countShares, blocks, limit, blockIDs );
									
							}
						});					
					});
					return true;
				}).catch(error =>{
					console.error("resolve error ", error );
					return false;
				});
			} catch(e){
				console.error(e);
				return false;
			}
		}		
	}

	static async runWebSocket(block, url){

		if(supabase)
			return this.runSupabase(block);

		console.warn("supabase not found, ", supabase )
		return false;
	}

	static async #subscribeChannels(){
		//channel for specific block messages targetting the note
		const  client = this.#createClient();

		if(!client) return;

		if(! this.#note){
			this.#note = await this.#getCurrentNote();
		}
		const accountData = await this.getAccountData();
		let email,phone;

		if(accountData?.emails && accountData.emails.length && typeof accountData.emails == "object"){
			email = accountData.emails[0]
		}
		else if(accountData[this.#note?.noteAddress]?.emails && accountData[this.#note?.noteAddress].emails.length && typeof accountData[this.#note?.noteAddress].emails == "object"){
			email = accountData[this.#note?.noteAddress].emails[0];
		}

		if(accountData?.phones && accountData.phones.length && typeof accountData.phones == "object"){
			phone = accountData.phones[0]
		}
		else if(accountData[this.#note?.noteAddress]?.phones && accountData[this.#note?.noteAddress].phones.length && typeof accountData[this.#note?.noteAddress].phones == "object"){
			phone = accountData[this.#note?.noteAddress].phones[0];
		}

		if(email){
			const emalChannel = client.channel(email);
			emalChannel.on("broadcast", {event: "transaction_update"}, (payload)=>{
				this.recieveNewBlock(this.isJsonable( payload.payload.text ) ? JSON.parse(payload.payload.text) : payload.payload.text)
			})
			await emalChannel.subscribe();
		}
		if(phone){
			const phoneChannel = client.channel(phone);
			phoneChannel.on("broadcast", {event: "transaction_update"}, (payload)=>{
				this.recieveNewBlock(this.isJsonable( payload.payload.text ) ? JSON.parse(payload.payload.text) : payload.payload.text)
			})
			await phoneChannel.subscribe()
		}
		const channel = client.channel("general");
		const clientChannel = client.channel(this.#note?.noteAddress ?? "client-channel");
		const walletChannel =  client.channel(this.#note?.walletID  ?? "wallet-channel");

		clientChannel.on("broadcast", {event: "transaction_update"}, (payload)=>{
			this.recieveNewBlock(this.isJsonable( payload.payload.text ) ? JSON.parse(payload.payload.text) : payload.payload.text)
		})

		walletChannel.on("broadcast", {event: "transaction_update"}, (payload)=>{
			this.recieveNewBlock(this.isJsonable( payload.payload.text ) ? JSON.parse(payload.payload.text) : payload.payload.text)
		})

		await clientChannel.subscribe();
		await  walletChannel.subscribe();

		// Listen for broadcasts
		channel.on("broadcast", { event: "block_broadcast" }, (payload) => {
			console.log("broadcasted block recieved");
			this.recieveNewBlock(this.isJsonable( payload.payload.text ) ? JSON.parse(payload.payload.text) : payload.payload.text)
		})

		// Subscribe to the broadcast channel
		await channel.subscribe()

		// Database realtime subscription
		const dbChannel = client
			.channel('blocks-changes')
			.on(
			'postgres_changes',
			{
				event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
				schema: 'public',
				table: 'blocks'
			},
			(payload) => {
				console.log('[v0] Database change detected:', payload.eventType)
				
				// Post message with the type of change and the data
				this.recieveNewBlock(this.isJsonable( payload.new ) ? JSON.parse(payload.new) : payload.new)
			}
			)
			.subscribe()

		// Optional: Listen to specific events separately
		const insertChannel = client
			.channel('blocks-inserts')
			.on(
			'postgres_changes',
			{
				event: 'INSERT',
				schema: 'public',
				table: 'blocks'
			},
			(payload) => {
				console.log('[v0] New block inserted:', payload.new)
				this.recieveNewBlock(this.isJsonable( payload.new ) ? JSON.parse(payload.new) : payload.new)
			}
			)
			.subscribe()
	}

	static #createClient(){

		if(! supabase )  return false;

		if(this.supabase )
			return this.supabase;

		const supabaseUrl = this.#note?.superbaseUrl ?? "https://svtbqnysmjffbstuotwd.supabase.co";
		const supabaseAnonKey = this.#note?.superbaseKey ?? "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN2dGJxbnlzbWpmZmJzdHVvdHdkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTE4NDcsImV4cCI6MjA3OTI2Nzg0N30.5DTPDygrRnQDW5W-NadS7cYr_PmQuVGC5K8BXWBsqtQ";

		const { createClient } = supabase;
		const client 			= createClient(supabaseUrl, supabaseAnonKey);
		this.supabase 			= client;
		return  client;
	}

	static async runSupabase(block) {
		// Enhanced WebSocket and Supabase with broadcast AND database subscriptions
		//const websocket = new WebSocket(`${url}`)


		if(! this.#note )
			this.#note =  await this.#getCurrentNote();

		
		const  client = this.#createClient();

		if(!client) return;

		console.log("supabase running for: ", block.blockID );

		// Broadcast channel for real-time messaging
		const channel = client.channel("general")
		await channel.subscribe()

		// Save block to database
		async function saveBlock(block) {
			try {
				const { data, error } = await client
					.from('blocks')
					.insert(block)
					.select()

				const budgets = ["CREATEBUDGET", "UPDATEBUDGET", "REMOVEBUDGET"];
				const products = ["CREATEPRODUCT", "BUYPRODUCT", "PRODUCTSUB"];
				const adverts = ["ADVERT", "VIEWADVERT",  "PUBLISHADVERT"];
				let agreement = false;

				if(block.agreement && budgets.includes(block.transType) && block.agreement.budgetID){
					const budget = Object.assign(block.agreeement);
					budget["blockID"] = block.blockID;
				await client
				.from('budgets')
				.insert(budget).select()
				agreement = Object.assign( block.agreement.agreement );
				} 
				else if(block.agreement && products.includes(block.transType) && block.agreement.productConfig){
					const product = Object.assign(block.agreement.productConfig)
					product["blockID"]	= block.blockID;
					product["agreeID"]	= block.agreement.agreeID;
				await client
				.from('products')
				.insert( product).select()
				agreement = Object.assign( block.agreement );
				} 

				
				else if(block.agreement && adverts.includes(block.transType) && block.agreement.advertID){
					const advert = Object.assign(block.agreement);
					advert["blockID"]	= block.blockID;
				await client
				.from('adverts')
				.insert( advert ).select()
				} 
				else if(block.agreement && block.agreement.agreeID){
				agreement = Object.assign(block.agreement);
				}
				
				if( agreement && agreement.agreeID ){
					agreement["blockID"] = block.blockID;
				await client
				.from('agreements')
				.insert(agreement)
				.select()
				}

			if (error) {
				console.error('[v0] Error saving block:', error)
				throw error
			}

			console.log('[v0] Block saved successfully:', data)
			return data
			} catch (err) {
			console.error('[v0] Failed to save block:', err)
			throw err
			}
		}

		// Save and broadcast the block
		async function processBlock(block) {
			try {
			console.log("processing block: ", block.blockID )
			
			// Also broadcast to channel for immediate updates
			await channel.send({
				type: "broadcast",
				event: "block_broadcast",
				payload: { text: JSON.stringify(block) }
			})
			console.log("block: ", block.blockID , " Broadcasted successfully")
			// Save to database (this will trigger the database subscription)
			await saveBlock(block)
			
			
			console.log('[v0] Block processed successfully')
			} catch (error) {
			console.error('[v0] Error processing block:', error)
			
			}
		}
		// Call the function with your block
		await processBlock(block)
		channel.unsubscribe();

	}
	
	static async recieveNewBlock( response = false ){
		//console.log( "recieveNewBlock running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "recieveNewBlock";
		try {
			
			if( (this.response && this.response.blockID) && ( ! response || ! response.blockID ) )
				response 	= JSON.parse( JSON.stringify( this.response ));
			
			if( response && response.blockID ) {
				//if it is a send transaction and it is a verifiable data, we attempt recieving
				//the data.
				this.#noVerify	 = false;
				let block 		= false;
				let verifyData = await this.storeBlock(response, this.#note );
				this.response 	= JSON.parse( JSON.stringify( response ));
				if( this.#transSend.includes( response.transType )/*  && verifyData  */){
					this.details = JSON.parse( JSON.stringify( response ) );
					if( response.transType == "INVEST" )
						this.details.transType = "INVESTRECIEVE";
					
					else if( response.transType == "AGREEMENTREQUEST" )
						this.details.transType 	= "AGREEMENTSIGN";
					
					else if( response.transType == "SPLIT" || response.transType == "SOLDBOND" || response.transType == "SOLDSTOCK" ) {
						if( response.transType == "SPLIT" )
							this.details.transType 	= "MERGE";
						else if( response.transType == "SOLDBOND" )
							this.details.transType 	= "QUOTEBOND";
						else if( response.transType == "SOLDSTOCK" )
							this.details.transType 	= "QUOTESTOCK";
						
						this.mergeNote 				= JSON.parse( JSON.stringify( this.defaultScriptbill ));
						this.mergeNote.block 		= JSON.parse( JSON.stringify( response ));
					}
					
					else 
						this.details.transType = 'RECIEVE';
					//console.log("generating transaction block");
					block = await this.generateScriptbillTransactionBlock( this.details );
				} else {
					this.errorMessage("couldn't recieve block, verify data " + verifyData + " " + response.blockID );
					block = false;
				}
				/* this.#profitSharing( response );
				this.monitorScriptbillCredit(); */
				return block;
			} else {
				return false;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	static async deleteBlock( blockID ){
		//console.log("deleteBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "deleteBlock";
		
		//initializing storage.
		this.l 		= await this.l;
		try {
			if( this.l[ blockID ] ){
				let block = this.l[ blockID ];
				
				if( block && this.isJsonable( block ) ){
					block = JSON.parse( block );
					
					if( block.budgetID && (block.transType == "CREATEBUDGET" || block.transType == "UPDATEBUDGET") ){
						this.errorMessage("Can't Delete an Original Budget Block");
						return false;
					}
					
					//if it is a product or budget block, we don't delete except we find another block that connects to it.
					if( block.blockID && block.blockID == blockID ){
						
						let expiry 		= parseInt( block.expiry );
						let time 		= parseInt( this.currentTime() );
						
						if( block.productID || block.budgetID ){
						//first check the expiry date.						
							if( expiry > time ){
								
								//next we check if the block has another block connected with it.
								this.blockID 	= block.nextBlockID;
								let nextBlock	= await this.getTransBlock();
								nextBlock 		= nextBlock[0];
								
								if( ! nextBlock || ! nextBlock.blockID ){						
									this.errorMessage( "Current Block " + blockID + " Can't be deleted. The block hasn't expired." );
									return false; //we can't delete a product block that hasn't expired
								}
							} else {
								this.errorMessage( "Current Block " + blockID + " Can't be deleted. The block hasn't expired." );
								return false; //we can't delete a product block that hasn't expired
							}
						}
						//if a send transaction, then there must be a corresponding recieve transaction before we can delete it
						else if( this.#transSend.includes( block.transType ) ){
							//first as usual we check the expiry. if a block expires then it can be deleted.					
							if( expiry > time ) {
								//checking for corresponding recieve block. We do this by setting the block ref and the transType
								this.blockRef 	= block.blockRef;
								let recieveBlock = await this.getTransBlock();
								
															
								//we didn't find a recieved block;
								if( (  !recieveBlock.length || ( recieveBlock[0].blockID == block.blockID  || ! this.#transRecieve.includes( block.transType ) ) ) ) {
									this.errorMessage( "Current Block " + blockID + " Can't be deleted. The block hasn't expired." );
									return false;
								}
								else if( recieveBlock && recieveBlock.length > 0 ){
									let bleck;
									let x;
									let recieved = false;
									let cancelled = false;
									for( x = 0; x < recieveBlock.length; x++  ){
										bleck = recieveBlock[x];
										
										if( bleck.blockID && bleck.blockID != block.blockID && this.#transRecieve.includes( bleck.transType ) ){										
											recieved = true;
										}
										else if( bleck.blockID && bleck.blockID != block.blockID && this.#otherTrans.includes( bleck.transType ) ){
											cancelled = true;
										}
									}
									
									if( ! recieved ){										
										this.errorMessage( "Current Block " + blockID + " Can't be deleted. The block hasn't expired." );
										return false;
									}
									else if( cancelled && ! recieved ){
										if( recieveBlock.length == 2 ){
											this.errorMessage( "Current Block " + blockID + " Can't be deleted. The block hasn't expired." );
											return false;
										}
									}
								}
							}//FOR EXCHANGE TRANSACTION TYPE
						} else if( block.transType == 'EXCHANGE' ){
							//we will only delete an exchange block if the exchange request is fulfilled.
							this.blockRef   = block.blockRef;
							let transBlock = await this.getTransBlock();
							let x, bleck, buyRequest = false, sellRequest = false;
							
							if( transBlock.length ){
								for( x = ( transBlock.length - 1); x > ( transBlock.length - 500 ) && x >= 0 ; x-- ){
									bleck = transBlock[x];
									//a response transaction type to an exchange request is a send transaction.
									if( bleck.transType == 'SEND' && bleck.noteType == block.sellCredit ){
										sellRequest = true;
									}
									
									if( bleck.transType == 'SEND' && bleck.noteType == block.buyCredit ){
										buyRequest = true;
									}
								}
							}
							
							if( ! buyRequest || ! sellRequest ){
								this.errorMessage( "Can't Delete an Exchange Block Until all Exchange Request are Fulfilled!!!" );
								return false;
							}
						} else if( ! block.witnesses || ! block.witnesses.length || block.witnesses.length < 12 ){
							this.errorMessage( "Block Can't Be Deleted, Block not Yet Verified!" );
							return false;
						}
					}				
				}
				
				
				delete this.l[ blockID ];
				return true;
			}
			else {
				return false;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	
	
	static isJsonable( data ){
		//console.log("isJsonable running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "isJsonable";
		
		if( typeof data == 'string' && ( ( data.indexOf('{') == 0 && data.lastIndexOf('}') == ( data.length - 1 ) ) || ( data.indexOf('[') == 0 && data.lastIndexOf(']') == ( data.length - 1 ) ) ) && data != "[object Object]" )
			return true;
		
		return false;
	}
	
	static async verifyDeposit(){
		
		try {
			if( ! this.response || ! this.response.blockID || Object.keys( this.response.agreements ).length < 1 || ! this.#transSend.includes( this.response.transType ) ) return false;
			
			
			//add support to check sending of money if the deposit is not yet confirmed here.
			let agrees = this.response.agreements;
			let agrID, agr;
			let noteValue 	= parseFloat( this.response.noteValue );
					
			for( agrID in agrees ){
				agr 	= agrees[agrID];
				if( agr.agreeType != "DEPOSIT" ) continue;
						
				if( ! agr.recieverSign ){
					noteValue -= parseFloat( agr.value );
				}
				else {
						
					if( ! await this.Verify(agr.recieverSign, agr.recieverKey, agr.recieverID) ){
						noteValue 	-= parseFloat( agr.value );
					} else {
						this.blockID 		= agr.recieverID;
						withBlk 			= await this.getTransBlock();
						withBlk 			= withBlk[0];
								
						if( ! withBlk || withBlk.blockID != agr.recieverID || withBlk.transType != "AGREEMENTSIGN" ){
							noteValue 	-= parseFloat( agr.value );
						}
						else {
							if( ! agr.senderID ){
								noteValue -= parseFloat( agr.value );
							}
							else {
									
								if( ! await this.Verify(agr.senderSign, agr.senderKey, agr.senderID) ){
									noteValue 	-= parseFloat( agr.value );
								}
								else {
									this.blockID 			= agr.senderID;
									depBlk					= await this.getTransBlock();
									depBlk 					= depBlk[0];
											
									if( ! depBlk || depBlk.blockID != agr.senderID || depBlk.transType != "AGREEMENTREQUEST" ){
										noteValue 	-= parseFloat( agr.value );
									} else {
										//block ref verification.
										if( withBlk.blockRef != depBlk.blockRef ){
											noteValue 	-= parseFloat( agr.value );
										} else {
											//Since the block refs are equal, let verify the 
											//references.
													
											if( ! await this.Verify(withBlk.signRef, withBlk.blockRef, depBlk.signRef ) ){
												noteValue 	-= parseFloat( agr.value );
											}
													
										}
									}
								}
							}
						}
					}
				}
			}
			/* await this.createAlert( "noteValue: " + noteValue );
			await this.createAlert( "transValue: " + this.response.transValue ); */
			if( noteValue < this.response.transValue  ){
				//await this.createAlert("Deposit Unverified");
				return false;
			}
			
			return true;
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	static async checkExchangeBlock( response, formerBlock = null, nextBlock = null ){
		if( response && response.exFormerBlockID ){
			let block 			= await this.getTransBlock(1, {exBlockID: response.exFormerBlockID});
			
			this.#noVerify 		= true;

			if( block && block[0] && block[0].blockID ){
				block 		= JSON.parse( JSON.stringify( block[0] ));
				
				if( formerBlock && formerBlock.exBlockID != block.exBlockID && formerBlock.exNextBlockID == response.exBlockID ){
					//this clearly shows that the former block came earlier than the Current
					//block and should be honored by being the current block
					if( formerBlock.transTime > block.transTime ){
						
						//but we'll check to see if there were earlier blocks 
						//earlier then the current response block.
						this.transTime 	= formerBlock.transTime.toString() + " >";
						let blocks 		= await this.getTransBlock();
						
						//so only blocks that were ealier than the current response block would be 
						//returned.
						blocks 			= blocks.filter( (block)=>{
							return block.transTime < response.transTime;
						});
						
						//if there are any block left after the filter then it must be looked into.
						if( blocks.length ){
							
							//we create the transaction time array where we can easily sort out.
							let transTimes = blocks.map( ( block )=>{
								return parseInt( block.transTime );
							});
							
							//sorted in decending order.
							let sortedTimes = transTimes.toSorted( (a,b)=>{
								return b - a;//decending order
							});
							
							
							sortedTimes.forEach( (time, index)=>{
								block			= blocks[ transTimes.indexOf( time ) ];		
								
								response.exFormerBlockID = block.exBlockID;
								
								if( block.exNextBlockID != response.exBlockID ){
									block.exNextBlockID 	= response.exBlockID;
								}
								
								this.#checkExchangeMarkets( response, block );
								response 		= JSON.parse( JSON.stringify( block ));
								
								if( index == ( sortedTimes.length - 1 ) ){
									response.exFormerBlockID	= formerBlock.exBlockID;
									
									if( formerBlock.exNextBlockID != response.exBlockID )
										formerBlock.exNextBlockID 	= response.exBlockID;
									
									this.#noVerify 		= true;
									this.#checkExchangeMarkets( response, formerBlock );
									this.storeBlock( formerBlock, note );
									this.shareBlock( false, formerBlock );
								}
							});
						} else {
							//else we just set the former block as the former block id and compare 
							//their exchange markets.
							response.exFormerBlockID = formerBlock.exBlockID;
							this.#checkExchangeMarkets( response, formerBlock );
						}
						
						//if( formerBlock.exFormerBlockID != block.exBlockID )
					}
				}
				
				//since the former block id brought this block, then if any next block id.
				//exist on this block then it should be the current block id.
				if( block.exNextBlockID && block.exNextBlockID != response.exBlockID ){
					this.exBlockID 		= block.exNextBlockID;
					let newBlock 		= await this.getTransBlock();
					if( newBlock && newBlock[0] && newBlock[0].blockID ){
						newBlock 		= JSON.parse( JSON.stringify( newBlock[0] ));
						
						//if the block that carries the next exchange block has a later Trans
						//time than the current exchange block. The former block id of the New
						//block must be this new block which will be checked in the recursive 
						//call to this function.
						if( newBlock.transTime < response.transTime ){
							this.checkExchangeBlock( newBlock, block, response );
						}
						else {
							block.exNextBlockID 		= response.exBlockID;
							this.#noVerify 				= true;
							this.storeBlock( block );
							this.shareBlock( false, block );
						}
					}
				} else if( ! block.exNextBlockID ){
					block.exNextBlockID 		= response.exBlockID;
					
					this.#checkExchangeMarkets( response, block );
					this.#noVerify 		= true;
					this.storeBlock( block, note );
					this.shareBlock( false, block );
				} 
			}
		}
		
		//but we'll check to see if there were latest blocks 
		//later than the current response block.
		this.transTime 	= response.transTime.toString() + " >";
		let blocks 		= await this.getTransBlock();
		
		if( response.exNextBlockID ){
			this.exBlockID 		= response.exNextBlockID;
			let block 			= await this.getTransBlock();
			block 				= block[0];
			
			if( block && nextBlock && block.transTime < nextBlock.transTime )
				nextBlock 		= JSON.parse( JSON.stringify( block ) );
		}
		
		blocks 			= blocks.filter( (block)=>{
			
			if( nextBlock && nextBlock.transTime )
				return block.transTime < nextBlock.transTime;
			
			return true;
		});
					
		//if there are any block left after the filter then it must be looked into.
		if( blocks.length ){
			
			//we create the transaction time array where we can easily sort out.
			let transTimes = blocks.map( ( block )=>{
				return parseInt( block.transTime );
			});
			
			//sorted in ascending order.
			let sortedTimes = transTimes.toSorted( (a,b)=>{
				return a - b;//ascending order
			});
			
			
			sortedTimes.forEach( (time, index)=>{
				let block			= blocks[ transTimes.indexOf( time ) ];		
				
				response.exNextBlockID = block.exBlockID;
				
				if( block.exFormerBlockID != response.exBlockID ){
					block.exFormerBlockID 	= response.exBlockID;
				}
				
				this.#checkExchangeMarkets( block, response );
				response 		= JSON.parse( JSON.stringify( block ));
				
				if( index == ( sortedTimes.length - 1 ) && nextBlock ){
					response.exNextBlockID	= nextBlock.exBlockID;
					
					if( nextBlock.exFormerBlockID != response.exBlockID )
						nextBlock.exFormerBlockID 	= response.exBlockID;
					
					this.#checkExchangeMarkets( nextBlock, response );
					this.#noVerify 		= true;
					this.storeBlock( response, note );
					this.shareBlock( false, response );
				}
			});
		
		}
	}
	
	static async checkProductBlock( response, formerBlock = null, nextBlock = null ){
		
		if( ! response.productID ) return;
		
		if( response && response.productFormerBlockID ){
			this.productBlockID 		= response.productFormerBlockID;
			let block 					= await this.getTransBlock();
			
			this.#noVerify 				= true;

			if( block && block[0] && block[0].blockID ){
				block 		= JSON.parse( JSON.stringify( block[0] ));
				
				if( formerBlock && formerBlock.productBlockID != block.productBlockID && formerBlock.productNextBlockID == response.productBlockID ){
					//this clearly shows that the former block came earlier than the Current
					//block and should be honored by being the current block
					if( formerBlock.transTime > block.transTime ){
						
						//but we'll check to see if there were earlier blocks 
						//earlier then the current response block.
						this.transTime 	= formerBlock.transTime.toString() + " >";
						let blocks 		= await this.getTransBlock();
						
						//so only blocks that were ealier than the current response block would be 
						//returned.
						blocks 			= blocks.filter( (block)=>{
							return block.transTime < response.transTime;
						});
						
						//if there are any block left after the filter then it must be looked into.
						if( blocks.length ){
							
							//we create the transaction time array where we can easily sort out.
							let transTimes = blocks.map( ( block )=>{
								return parseInt( block.transTime );
							});
							
							//sorted in decending order.
							let sortedTimes = transTimes.toSorted( (a,b)=>{
								return b - a;//decending order
							});
							
							
							sortedTimes.forEach( (time, index)=>{
								block			= blocks[ transTimes.indexOf( time ) ];		
								
								response.productFormerBlockID 	= block.productBlockID;
								
								if( block.productNextBlockID != response.productBlockID ){
									block.productNextBlockID 	= response.productBlockID;
								}
								
								this.#checkExchangeMarkets( response, block, true );
								response 		= JSON.parse( JSON.stringify( block ));
								
								if( index == ( sortedTimes.length - 1 ) ){
									response.productFormerBlockID	= formerBlock.productBlockID;
									
									if( formerBlock.productNextBlockID != response.productBlockID )
										formerBlock.productNextBlockID 	= response.productBlockID;
									
									this.#checkExchangeMarkets( response, formerBlock, true );
									this.#noVerify		= true;
									this.storeBlock( formerBlock, note );
									this.shareBlock( false, formerBlock );
								}
							});
						} else {
							//else we just set the former block as the former block id and compare 
							//their exchange markets.
							response.productFormerBlockID 	= formerBlock.productBlockID;
							this.#checkExchangeMarkets( response, formerBlock, true );
						}
						
						//if( formerBlock.exFormerBlockID != block.exBlockID )
					}
				}
				
				//since the former block id brought this block, then if any next block id.
				//exist on this block then it should be the current block id.
				if( block.productNextBlockID && block.productNextBlockID != response.productBlockID ){
					this.productBlockID 		= block.productNextBlockID;
					let newBlock 		= await this.getTransBlock();
					if( newBlock && newBlock[0] && newBlock[0].blockID ){
						newBlock 		= JSON.parse( JSON.stringify( newBlock[0] ));
						
						//if the block that carries the next exchange block has a later Trans
						//time than the current exchange block. The former block id of the New
						//block must be this new block which will be checked in the recursive 
						//call to this function.
						if( newBlock.transTime < response.transTime ){
							this.checkProductBlock( newBlock, block, response );
						}
						else {
							block.productNextBlockID 		= response.productBlockID;
							this.#noVerify		= true;
							this.storeBlock( block, note );
							this.shareBlock( false, block );
						}
					}
				} else if( ! block.productNextBlockID ){
					block.productNextBlockID 		= response.productBlockID;
					
					this.#checkExchangeMarkets( response, block, true );
					this.#noVerify		= true;
					this.storeBlock( block, note );
					this.shareBlock( false, block );
				} 
			}
		}
		
		//but we'll check to see if there were latest blocks 
		//later than the current response block.
		this.transTime 	= response.transTime.toString() + " >";
		let blocks 		= await this.getTransBlock();
		
		if( response.productNextBlockID ){
			this.exBlockID 		= response.productNextBlockID;
			let block 			= await this.getTransBlock();
			block 				= block[0];
			
			if( block && nextBlock && block.transTime < nextBlock.transTime )
				nextBlock 		= JSON.parse( JSON.stringify( block ) );
		}
		
		blocks 			= blocks.filter( (block)=>{
			
			if( nextBlock )
				return block.transTime < nextBlock.transTime;
			
			return true;
		});
					
		//if there are any block left after the filter then it must be looked into.
		if( blocks.length ){
			
			//we create the transaction time array where we can easily sort out.
			let transTimes = blocks.map( ( block )=>{
				return parseInt( block.transTime );
			});
			
			//sorted in ascending order.
			let sortedTimes = transTimes.toSorted( (a,b)=>{
				return a - b;//ascending order
			});
			
			
			sortedTimes.forEach( (time, index)=>{
				block			= blocks[ transTimes.indexOf( time ) ];		
				
				response.productNextBlockID = block.productBlockID;
				
				if( block.productFormerBlockID != response.productBlockID ){
					block.productFormerBlockID 	= response.productBlockID;
				}
				
				this.#checkExchangeMarkets( block, response, true );
				response 		= JSON.parse( JSON.stringify( block ));
				
				if( index == ( sortedTimes.length - 1 ) && nextBlock ){
					response.productNextBlockID	= nextBlock.productBlockID;
					
					if( nextBlock.productFormerBlockID != response.productBlockID )
						nextBlock.productFormerBlockID 	= response.productBlockID;
					
					this.#checkExchangeMarkets( nextBlock, response, true );
					this.#noVerify		= true;
					this.storeBlock( response, note );
					this.shareBlock( false, response );
				}
			});
		
		}
	}
	
	static async #checkExchangeMarkets( response, block, isProductBlock = false ){
		//verifying the exchange note value.
		
		if( ! response || ! response.blockID || ! block || ! block.blockID ) return;
		
		
		if( ! isProductBlock ){
		
			if( ["INTERESTPAY", "BUYBOND", "BUYPRODUCT", "PRODUCTSUB"].includes( response.transType ) ){
				if( block.exchangeNote && parseFloat( block.exchangeNote.exchangeValue ) > parseFloat( response.exchangeNote.exchangeValue ) ){
					
					if( response.transType == "INTERESTPAY" )
						response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) + parseFloat( response.transValue );
					
					else if( response.transType == "BUYBOND" ) {
						this.blockRef 		= response.blockRef;
						let win_blocks 		= await this.getTransBlock();
						
						if( win_blocks.length ){
							
							if( win_blocks.length == 1 )
								response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) + parseFloat( response.transValue );					
						} 
					}
					else if( response.transType == "BUYPRODUCT" || response.transType == "PRODUCTSUB" ) {
						let shareRate = 0.2;
						
						if( response.agreement && response.agreement.productConfig && response.agreement.productConfig.shareRate )
							shareRate 	= parseFloat( response.agreement.productConfig.shareRate );
						
						let amount 	= parseFloat( response.transValue ) * shareRate;
						
						response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) + parseFloat( amount );
						
					}
				}  else {
					let remValue 	= parseFloat(  response.exchangeNote.exchangeValue ) - parseFloat( block.exchangeNote.exchangeValue );
					let value 		= parseFloat( response.transValue );
					
					if( response.transType == "BUYBOND" || response.transType == "DEPOSIT" ){
						this.blockRef 		= response.blockRef;
						let win_blocks 		= await this.getTransBlock();
						
						if( win_blocks.length > 1 ){
							value 	= 0;
						}
					}
					else if( response.transType == "BUYPRODUCT" || response.transType == "PRODUCTSUB" ){
						let shareRate = 0.2;
						
						if( response.agreement && response.agreement.productConfig && response.agreement.productConfig.shareRate )
							shareRate 	= parseFloat( response.agreement.productConfig.shareRate );
						
						value 			= parseFloat( response.transValue ) * shareRate;
					}
					
					if( remValue != value ){
						response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) + parseFloat( amount );					
					}
				}
			} 
			else if( ["BONDPAY", "LOAN", "INVEST", "WITHDRAW"].includes( response.transType ) ){
				//this transaction are likely to increase the demand value of the 
				//exchange market except the exchangeValue could handle the request.
				
				if( response.transType == "WITHDRAW" ){
					if( ! response.agreement )
						return;
					
					if( ! response.exchangeNote ) return;
					
					let agreeID 		= response.agreement.agreeID;
					
					if( ! agreeID ) return;
					
					let agreeKey 		= response.exchangeNote.agreement;
					
					if( ! agreeKey || typeof agreeKey != "string" ) return;
					
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( agreeKey, id );
					
					if( agreeID != await this.getPublicKey(id) ) return;
				}
				
				if( block.exchangeNote && block.exchangeNote.demandValue > response.exchangeNote.demandValue ){
					if( block.exchangeNote.exchangeValue < response.transValue ){
						response.exchangeNote.demandValue = parseFloat( block.exchangeNote.demandValue ) + parseFloat( response.transValue );
					} else {
						response.exchangeNote.demandValue 	= block.exchangeNote.demandValue;
						response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) - parseFloat( response.transValue );
					}
				} else if( block.exchangeNote ){
					let remValue	= parseFloat( response.exchangeNote.demandValue ) - parseFloat( block.exchangeNote.demandValue );
					
					if( remValue != response.transValue ){
						if( block.exchangeNote.exchangeValue >= response.transValue ){
							response.exchangeNote.demandValue = block.exchangeNote.demandValue;
							response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) - parseFloat( response.transValue );
						} else {
							response.exchangeNote.demandValue 	= parseFloat( block.exchangeNote.demandValue ) + parseFloat( response.transValue );
						}					
					}
				}	
			} else if( response.transType == "DEPOSIT" && block.exchangeNote.noteValue >= response.exchangeNote.noteValue ){
				this.blockRef 		= response.blockRef;
				let win_blocks 		= await this.getTransBlock();
								
				if( win_blocks.length > 1 ) return;
				
				if( block.exchangeNote.exchangeValue < response.transValue ){
					response.exchangeNote.demandValue = parseFloat( block.exchangeNote.demandValue ) + parseFloat( response.transValue );
				} else {
					response.exchangeNote.exchangeValue = parseFloat( block.exchangeNote.exchangeValue ) - parseFloat( response.transValue );
				}
				
				response.exchangeNote.noteValue = parseFloat( block.exchangeNote.noteValue ) + parseFloat( response.transValue );
			}
		} else {
			if( ["BUYSTOCK", "BUYPRODUCT", "PRODUCTSUB"].includes( response.transType ) ){
				if( block.productNote && parseFloat( block.productNote.exchangeValue ) > parseFloat( response.productNote.exchangeValue ) ){
					
					/* if( response.transType == "STOCKPAY" )
						response.productNote.exchangeValue = parseFloat( block.productNote.exchangeValue ) - parseFloat( response.transValue ); */
					
					if( response.transType == "BUYSTOCK" ) {
						this.blockRef 		= response.blockRef;
						let win_blocks 		= await this.getTransBlock();
						
						if( win_blocks.length == 1 ){
							response.productNote.exchangeValue = parseFloat( block.productNote.exchangeValue ) + parseFloat( response.transValue );					
						}
					}
					else if( response.transType == "BUYPRODUCT" || response.transType == "PRODUCTSUB" ) {
						let shareRate = 0.8;
						
						if( response.agreement && response.agreement.productConfig && response.agreement.productConfig.shareRate )
							shareRate 	= 1 - parseFloat( response.agreement.productConfig.shareRate );
						
						let amount 	= parseFloat( response.transValue ) * shareRate;
						
						response.productNote.exchangeValue = parseFloat( block.productNote.exchangeValue ) + parseFloat( amount );
						
					}
				}  else {
					let remValue 	= parseFloat(  response.productNote.exchangeValue ) - parseFloat( block.productNote.exchangeValue );
					let value 		= parseFloat( response.transValue );
					let amount 		= value;
					
					if( response.transType == "BUYSTOCK" ){
						this.blockRef 		= response.blockRef;
						let win_blocks 		= await this.getTransBlock();
						
						if( win_blocks.length > 1 ){
							value 	= 0;
							amount 	= 0;
						}
					}
					else if( response.transType == "BUYPRODUCT" || response.transType == "PRODUCTSUB" ){
						let shareRate = 0.8;
						
						if( response.agreement && response.agreement.productConfig && response.agreement.productConfig.shareRate )
							shareRate 	= 1 - parseFloat( response.agreement.productConfig.shareRate );
						
						value 			= parseFloat( response.transValue ) * shareRate;
					}
					
					if( remValue != value ){						
						response.productNote.exchangeValue = parseFloat( block.productNote.exchangeValue ) + parseFloat( value );
						response.productNote.demandValue = parseFloat( block.productNote.demandValue ) - parseFloat( amount );
					}
				}
			} 
			else if( ["STOCKPAY", "LOAN", "CREATEPRODUCT", "UPDATEPRODUCT"].includes( response.transType ) ){
				//this transaction are likely to increase the demand value of the 
				//exchange market except the exchangeValue could handle the request.
				//this.#noVerify		= true;
				if( block.productNote && block.productNote.demandValue > response.productNote.demandValue && ( response.transType == "CREATEPRODUCT" || response.transType == "UPDATEPRODUCT" ) ){
					let units 		= 1;
					
					if( response.agreement.productConfig.units )
						units 		= parseInt( response.agreement.productConfig.units );
					
					response.productNote.demandValue = parseFloat( block.productNote.demandValue ) + ( parseFloat( response.transValue ) * units );
				} else if( block.productNote ){
					let remValue	= parseFloat( response.productNote.exchangeValue ) - parseFloat( block.productNote.exchangeValue );
					
					if( remValue != response.transValue ){
						response.productNote.demandValue = block.productNote.demandValue;
						response.productNote.exchangeValue = parseFloat( block.productNote.exchangeValue ) - parseFloat( response.transValue );				
					}
				}	
			}

		}
		this.#noVerify		= true;
		this.storeBlock( response, note );
		this.shareBlock( false, response );
	}

	static async verifyData( response = false ){
		//console.log("verifyData running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "verifyData";
				
		//await this.createAlert("Verifying Data");
		
		try {
			if( this.executeStrictly  && this.note )
				await this.sendData();
			
			let alreadyVerified = this.l.alreadyVerified;
			
			if( ! alreadyVerified || ! this.isJsonable( alreadyVerified ) )
				alreadyVerified		= [];
			
			else
				alreadyVerified 	= JSON.parse( alreadyVerified );
			
			
			if( ! response && this.response && this.response.blockID )
				response 		= JSON.parse( JSON.stringify( this.response ));
			
			if( alreadyVerified.includes( response.blockID ) ) return true;
			
			alreadyVerified.push( response.blockID );
			
			this.l.alreadyVerified 		= JSON.stringify( alreadyVerified );
			
			let isExchangeTrans 	= this.#isExchangeMarketMining || this.#isExchangeDeposit;
			
			var id 				= await this.generateKey(10);
			if( ! isExchangeTrans && response.exchangeNote && response.exchangeNote.blockKey ){		
				await this.setPrivateKey( response.exchangeNote.blockKey, id );
				isExchangeTrans 	= await this.getPublicKey( id, true ) == response.blockKey;
			}
			let fBlock = false;
			if( ! this.formerBlock || ! this.formerBlock.blockID ){
				fBlock 				= await this.getTransBlock(1, {blockID: response.formerBlockID});
				//console.log("Fblock getting, not former block: " , fBlock );
			} else if( this.formerBlock.blockID == response.formerBlockID || this.formerBlock.splitID == response.formerBlockID ) {
				fBlock 				= [ JSON.parse( JSON.stringify( this.formerBlock ) ) ];
				//console.log("Fblock getting, former: " , fBlock );
				this.formerBlock 	= false;
			} else {
				fBlock 				= await this.getTransBlock(1, {blockID: response.formerBlockID});
				//console.log("Fblock getting, former block bur from formerBlockID: " , fBlock );
			}
			
			if( response.defaultKey && response.defaultKey != this.#odogwu ){
				let defaultKey = await this.getData("defaultKey", "true", this.#default_scriptbill_server );
				
				if( defaultKey && defaultKey != this.#odogwu ){
					this.#odogwu = defaultKey;
					this.errorMessage("You are runnning an adulterated version of Scriptbill, block from this server will be rejected by the network");
				}else{
					this.#rejectResponse("block came from an adulterated Scriptbill server");
					return false;
				}
			}
			
			if( response.transType == "CREATE" || ( response.transType == "CREATEBUDGET" && ! fBlock.length /*This shows that this is a create budget transaction that deals with an exchange market. Exchange market are birthed first before any credit note would exist.*/) || response.blockKey == await this.getPublicKey(id) /* checking is it is an exchange block */ ){
				//this shows that the block is newly introduced to the Scriptbill database systems.
				this.response = response;
				await this.sendData();
				return true;
			}
			
			if( ( ! fBlock.length || ! fBlock[0].blockID ) ){
				fBlock 				= await this.getTransBlock(1, {splitID:response.formerBlockID});
				//console.log("Fblock getting, spliti: " , fBlock );
				this.splitBlock 	= fBlock[0];
			}
			this.response     = JSON.parse( JSON.stringify( response ) );
			//console.log("fBlock: " + JSON.stringify( fBlock ) );
			
			if( this.s.processingID == response.blockID ) return;
			
			this.s.processingID 	= response.blockID;

			if( ! fBlock.length && this.l[ response.formerBlockID ] && this.isJsonable( this.l[ response.formerBlockID ] ) ){
				fBlock = JSON.parse( this.l[ response.formerBlockID ] );
				//console.log("Fblock getting, local: " , fBlock );
			} else if( ! fBlock.length && this.storage[ response.formerBlockID ] && this.isJsonable( this.storage[ response.formerBlockID ] )){
				fBlock = JSON.parse( this.storage[ response.formerBlockID ] );
				//console.log("Fblock getting, storage: " , fBlock );
			} 
			else if( fBlock.length && fBlock[0].blockID ){
				fBlock 		= fBlock[0];
				//console.log("Fblock getting, length: " , fBlock );
			} else {
				//if the note value is greater than zero, then the client must have had transaction before. Hence we check the note sign.
							
				//await this.createAlert("Verifying Data 2 Former Block Not Directly Found");
				//checking if the current block is an exchange note block.
				if( response.noteValue != 0 && ! isExchangeTrans ){
					fBlock 	= await this.getTransBlock(1, {blockID: response.formerBlockID});
					fBlock	= fBlock[0];
					//console.log("Fblock getting, last: " , fBlock );
					
					if( ! fBlock || ! fBlock.blockID ){
						this.#rejectResponse("This Block Doesn't Seems to be connected to a Valid Scriptbill Note.", response );
						delete this.s.processingID;
						return false;
					}
					
				} else if( response.transType == "CREATE" || response.transType == "CREATEBUDGET" || response.blockKey == await this.getPublicKey(id) /* checking is it is an exchange block */ ){
					//this shows that the block is newly introduced to the Scriptbill database systems.
					this.response = response;				
					await this.sendData();
					delete this.s.processingID;
					return true;
				}
				
			}
			
			if( response.scriptSign ){
				let scriptKey = response.scriptKey;

				if( ! scriptKey ){
					scriptKey 	= this.#scriptbankKey;
				}
				
				let exNote 		= await this.getCurrentExchangeNote( response.noteType );
				
				if( ! exNote || ! exNote.noteServer ) return false;
				
				let verified = await this.getData(["staff", "sBlockID"], [scriptKey, response.blockID], exNote.noteServer);
				
				if( verified && verified.scriptKey ){
					
					if( ! await this.Verify(response.scriptSign, verified.scriptKey, response.blockID)){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Couldn't Verify The Staff Signature to This Block", response );
						delete this.s.processingID;
						return false;
					}
				} else {
					this.response     = JSON.parse( JSON.stringify( response ) );
					this.#rejectResponse("Couldn't Verify an Exchange Market Staff Block", response );
					delete this.s.processingID;
					return false;
				}
				
			}
			
			/* //console.log("Check Former Block: " + JSON.stringify( fBlock ), "Check Response Block: " + JSON.stringify( response ) );
			await this.createAlert("Check Verifying Blocks "); */
			
			if( ! response.exchangeNote || ! response.exchangeNote.exchangeKey ){
				this.#rejectResponse("No Exchange Key in the block being verified. The block is not valid! " + response.blockID + " trans type " + response.transType, response );
				delete this.s.processingID;
				return false;
			}
			
			if( this.#note.noteType == response.noteType ){
				let block 		= await this.getTransBlock(1, {blockID: this.#note.blockID});
				
				let exchangeNote 	= await this.getCurrentExchangeNote( this.#note.noteType );
				
				if( block[0] && block[0].blockID ){
					block 	= block[0];			
					
					if( block.exchangeNote && block.exchangeNote.exchangeKey && block.exchangeNote.exchangeKey != response.exchangeNote.exchangeKey ){
						
						let test = response.noteType.slice( 0, creditType.lastIndexOf("CRD"));
						//protect Scriptbank exchange Notes
						if( this.#fiatCurrencies[test] && response.exchangeNote.noteServer != this.#default_scriptbill_server )
							response.exchangeNote.noteServer = this.#default_scriptbill_server;
						
						if( block.exchangeNote.noteServer == response.exchangeNote.noteServer ){
							exchangeNote = await this.getData("exchangeNote", response.noteType, response.exchangeNote.noteServer);
							if( exchangeNote && exchangeNote.exchangeKey ){
								response.exchangeNote 	= JSON.parse( JSON.stringify( exchangeNote ) );
							}
						} else {
							//get the exchange note of the first block.
							exchangeNote = await this.getData("exchangeNote", response.noteType, response.exchangeNote.noteServer);
							block.exchangeNote = await this.getData("exchangeNote", block.noteType, block.exchangeNote.noteServer);
							
							if( block.exchangeNote.exchangeKey != exchangeNote.exchangeKey ){
								this.#rejectResponse( "Transaction Block is invalid, Scriptbill cannot verify the block being sent or recieved!", response );
								delete this.s.processingID;
								return false;
							}
						}
					} 					
				}
				
				this.checkExchangeBlock( response );
			}
			
			if( response.productID || this.#productTrans.includes( response.transType ) ){
				this.checkProductBlock( response );
			}
			
			//checking the budget block for authencity
			if( this.#budgetTrans.includes( response.transType ) ){
				if( ! response.agreement || ! response.agreement.budgetType || ! response.agreement.budgetID || ! response.agreement.name || ( ( ( response.agreement.budgetType == "business" && ( ! response.productNote || ! response.productNote.exchangeID ) ) || ( response.agreement.budgetType == "governmental" && ( ! response.exchangeNote || ! response.exchangeNote.exchangeID || ! response.exchangeNote.budgetID == response.budgetID ) ) ) && ! response.agreement.stockID ) ){
					this.#rejectResponse("Budget Block is not properly configured, Please reconfigure your budget block and try publishing it again", response );
					delete this.s.processingID;
					return false;
				}
				
				if( response.transType == "BUSINESS" ){
					if( ! response.agreement.businessID || ! response.agreement.businessKey || ! response.agreement.businessSign || response.agreement.businessID != response.blockID || ! response.rankPref == "businessManager" ){
						this.#rejectResponse("This business block was not properly sign or not signed by a Business Manager.", response );
						delete this.s.processingID;
						return false;
					}
					//verifying the business manager signature to the agreement
					
					if( ! await this.Verify(response.agreement.businessSign, response.agreement.businessKey, response.agreement.businessID)){
						this.#rejectResponse("Couldn't Verify the business manager signature to this block", response );
						delete this.s.processingID;
						return false;
					}
					//let's check if the business manaer is registered with the exchange market origin server.
					let verify 			= await this.getData("businessID", response.agreement.businessKey, this.#default_scriptbill_server );

					if( navigator.onLine && ( ! verify || ! verify.verified )){
						this.#rejectResponse("Business Manager Seems not to be verified", response );
						delete this.s.processingID;
						return false;
					}
				}
				
				if( ( ! response.budgetKey || ! response.budgetSign ) && response.transType != "BUSINESS" ){
					this.#rejectResponse("No Budget Key and Signature in the Budget Request, Budget Block is now invalid", response );
					delete this.s.processingID;
					return false;
				}
				
				//verifying the signature on the budget block.
				
				if( ! await this.Verify(response.budgetSign, response.budgetKey, response.blockID)){
					this.#rejectResponse("We couldn't verify the budget signature on this block", response );
					delete this.s.processingID;
					return false;
				}
				
				//lastly we verify if the key was correct or we are having a fraudulent change in the budget block's key. so we query for the create budget block to verify the budget key used.
				let budgetBlock 		= await this.getTransBlock(1, {budgetID: response.agreement.budgetID, transType: "CREATEBUDGET"});
				
				if( ! budgetBlock.length && navigator.onLine ){
					this.#rejectResponse("Couldn't find a corresponding block that created this budget", response );
					delete this.s.processingID;
					return false;
				}
				
				if( budgetBlock.length ){
					budgetBlock			= budgetBlock[0];
					
					if( response.budgetKey 	!= budgetBlock.budgetKey ){
						this.#rejectResponse("A Fraudulent budget block key was found on this block.", response );
						delete this.s.processingID;
						return false;
					}
				}
			}
			
			
			
			//verifying the product blocks now
			if( this.#productTrans.includes( response.transType ) ){
				if( ! response.agreement || ! response.agreement.productConfig || ! response.agreement.productConfig.name || ! response.agreement.productConfig.value || ! response.agreement.productConfig.budgetID || ! response.agreement.productConfig.totalUnits || ! response.productID ){
					this.#rejectResponse("Product Block is not properly configured, Please reconfigure your Product block and try publishing it again", response );
					delete this.s.processingID;
					return false;
				}
				let productID 		= response.productID;
				if( response.transType == "CREATEPRODUCT" || response.transType == "UPDATEPRODUCT" ){
					if( ! response.productID || ! response.productSign ){
						this.#rejectResponse("This product block was not properly sign or not signed by the product creator.", response );
						delete this.s.processingID;
						return false;
					}
					//verifying the business manager signature to the agreement
					
					if( ! await this.Verify(response.productSign, response.productID, response.blockID)){
						this.#rejectResponse("Couldn't Verify the product creator signature to this block", response );
						delete this.s.processingID;
						return false;
					}					
				}
								
				//lastly we verify if the key was correct or we are having a fraudulent change in the budget block's key. so we query for the create budget block to verify the budget key used.
				if( ! response.transType == "CREATEPRODUCT" ){
					let productBlock 		= await this.getTransBlock(1, {productID: productID, transType: "CREATEPRODUCT"});
					
					if( ! budgetBlock.length && navigator.onLine ){
						this.#rejectResponse("Couldn't find a corresponding block that created this Product", response );
						delete this.s.processingID;
						return false;
					}
				}
			}
			
			if( response.transType == "DEPOSIT" && response.agreement && response.agreement.depositServer && response.agreement.depositInstanceKey ){
				let url;
				
				if( ( response.agreement.depositServer.lastIndexOf("/") + 1 ) == response.agreement.depositServer.length )
					url = response.agreement.depositServer + response.agreement.depositInstanceKey;
				
				else 
					url = response.agreement.depositServer + "/" + response.agreement.depositInstanceKey;
				
				let data = await this.getData("","", url );
				
				if( data && data.data && data.data.transaction_status && data.data.transaction_status == "success" ){
					//delete the agreement from the deposit block.
					//but to avoid verificationn issues. We'll create a proper agreement 
					//signature request to the recipient.
					this.details 			= JSON.parse( JSON.stringify( response ));
					this.details.transType 	= "AGREEMENTREQUEST";
					this.details.transValue = 0;
					this.details.recipient 	= response.agreement.agreeKey;
					this.generateScriptbillTransactionBlock( this.details, this.#note );
				} else {
					if( navigator.onLine ){
						this.#rejectResponse("Fraudulent Deposit Deetected", response);
						return false;
					}
				}
			}
			
			
			
			if( isExchangeTrans ){
				//await this.createAlert("Exchange Verified");
				this.response = response;
				this.sendData();
				delete this.s.processingID;
				return true;
			}
			
			//this will be useful in calculating the current note value of the 
			//connected block. Only blocks with agreeType of product will UPDATE
			//the note's value, most of the time their trans value is always`
			//negative.
			let referenceBlocks		= await this.getTransBlock(100, {referenceID: response.blockID});
			
			
			//console.log( 'former block: ' + JSON.stringify( fBlock ));
			//console.log( 'new block: ' + JSON.stringify( response ));
			//to run Scriptbill code the former blocks must be intact.
			if( fBlock && fBlock.blockID && fBlock.nextBlockID ){

				//for budgets, we have to understand that budgets are preferences of the note holder and we can't check for
				//compromized content because the user can update and remove the budget from the database any time
				let budgets = response.budgetRefs;
				let x, budget, value = 0;
				let len 	= budgets && budgets.length ? budgets.length : 0; 
				for( x = 0; x < len; x++ ){
					this.budgetID		= budgets[x];
					this.server 		= fBlock.noteServer;
					budget				= await this.getCurrentBudgetBlock( this.budgetID );
					
					if( budget && budget.agreement && budget.agreement.value ) {
						value 			+= parseFloat( budget.agreement.value );
					}				
				}
				
				//budget means an already set transaction value.
				let transValue = parseFloat( response.transValue ) + value;		
				
				//verifying the blocks.
				//verifying the block id, the next block ID test will ensure that the current note secret was used to calculate
				//the block IDs
				if( fBlock.blockID != response.formerBlockID || fBlock.nextBlockID != response.blockID ) {
					this.response     = JSON.parse( JSON.stringify( response ) );					
					this.#rejectResponse('Block ID not Matched!!!', response );
					delete this.s.processingID;
					return false;
				}
				//verifying the block hash calculation, if the transaction was created using the former block, then the hash
				//should rime
				/*
				if( fBlock.blockHash.toString().slice(0, 10) != response.formerBlockHash ) {
					await this.createAlert('Block Hash Calculation Failed');
					return true;
				} */
				let noteValue 		= parseFloat( response.noteValue );
				//verifying the note value
				if( this.#transSend.includes( fBlock.transType ) || fBlock.transType == "SPLIT" || fBlock.transType == "WITHDRAW" || ( response.transType == "AGREESEND" && response.referenceID == response.blockID ) ) {
					if( response.noteValue != ( parseFloat( fBlock.noteValue ) - parseFloat( fBlock.transValue ) ) ) {
						if( referenceBlocks.length ){
							//this is the expected note value.
							noteValue 		= parseFloat( fBlock.noteValue ) - parseFloat( fBlock.transValue );
							//if there were reference block before the transaction, 
							//then the note value may change. so we loop through the
							//blocks to see the actual note value.
							for( let x = 0; x < referenceBlocks.length; x++ ){
								//ensuring that the agreement executed by the block is 
								//exempted from this calculation.
								if( referenceBlocks[x].blockID != response.blockID )
									noteValue 		-= parseFloat( referenceBlocks[x].transValue );
							}
							
							if( response.noteValue != noteValue ){
								this.response     = JSON.parse( JSON.stringify( response ) );
								this.#rejectResponse('note Value Not Match', response );
								delete this.s.processingID;
								return false;
							}
						} else {
							this.response     = JSON.parse( JSON.stringify( response ) );
							this.#rejectResponse('note Value Not Match', response );
							delete this.s.processingID;
							return false;
						}
					}				
				}else if( this.#transRecieve.includes( fBlock.transType ) || fBlock.transType == "LOAN" || fBlock.transType == "DEPOSIT" ) {
					
					if( response.noteValue != ( parseFloat( fBlock.noteValue ) + parseFloat( fBlock.transValue  ) ) ) {
						
						if( referenceBlocks.length ){
							//this is the expected note value.
							noteValue 		= parseFloat( fBlock.noteValue ) + parseFloat( fBlock.transValue );
							//if there were reference block before the transaction, 
							//then the note value may change. so we loop through the
							//blocks to see the actual note value.
							for( let x = 0; x < referenceBlocks.length; x++ ){
								noteValue 		-= parseFloat( referenceBlocks[x].transValue );
							}
							
							if( response.noteValue != noteValue ){
								this.response     = JSON.parse( JSON.stringify( response ) );
								this.#rejectResponse('note Value Not Match', response );
								delete this.s.processingID;
								return false;
							}
						} else {						
							this.response     = JSON.parse( JSON.stringify( response ) );
							this.#rejectResponse('Note Value Not Match', response );
							delete this.s.processingID;
							return false;
						}
					}
					
				}
				else if( this.splitBlock && this.splitBlock.blockID && this.splitBlock.splitID == response.formerBlockID ){
					let verify 	= await this.verifyData( this.splitBlock );
					
					if( ! verify ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse('Split Block not Authorized to Split Value to your Note.', response );
						delete this.s.processingID;
						return false; 		
					}
					
					if( this.splitBlock.transValue != response.noteValue ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse('Note Value For Split Note Not Match', response );
						delete this.s.processingID;
						return false;
					}
				}
				
				if( this.#transSend.includes( response.transType ) ||  response.transType == "AGREESEND" ){
					if( ! response.blockRef || ! response.signRef ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Can't Create a Send Transaction Without a Reference", response );
						delete this.s.processingID;
						return false;
					}
					
					this.blockRef = response.blockRef;
					let revBlocks = await this.getTransBlock(10, {blockRef: response.blockRef});
					let sendBlocks = [], revBlock, revCount = 0;
					/* //console.log("Recieve Blocks Gotten: " + JSON.stringify( revBlocks));
					await this.createAlert("Check Recieve Blocks"); */
					
					for(  x = 0; x < revBlocks.length; x++ ){
						
						if( revBlocks[x] && this.#transRecieve.includes( revBlocks[x].transType ) ){
							revBlock	= revBlocks[x];
							if( revBlock.blockID && revBlock.signRef ){
								//if we found the recieved block, we verify the BLOCK
								//to see if it is using the correct keys sent to it
								//in an encrypted manner.
								
								if( await this.Verify(revBlock.signRef,revBlock.blockRef, response.signRef)){
									//this verifies that the transaction block is 
									//authentically recieved.
									revCount++;
								} else {
									revBlock 	= false;
								}
								
							}
							//revCount++;
							
						} else if( revBlocks[x] && this.#transSend.includes( revBlocks[x].transType ) ){
							sendBlocks.push( revBlocks[x] );
							
						}else if( revBlock && sendBlocks.length > 1 ){
							break;
						}					
					}
					
					//we don't expect more than one send block in a transaction
					//if any exist, then it should be the current response block
					if( sendBlocks.length > 1 || ( sendBlocks[0] && sendBlocks[0].blockID != response.blockID ) ){
						if( revBlock ){
							this.response     = JSON.parse( JSON.stringify( response ) );
							this.#rejectResponse("Transaction Already Sent and Recieved!!", response );
							delete this.s.processingID;
							return false;
						}
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Can't Have More Than one Sender Per Transaction", response );
						delete this.s.processingID;
						return false;					
					}
					
					if( noteValue < transValue ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Sorry, your note does not have enough credit to fulfil this request. This may be as a result of unexecuted Budgets on your note!!!", response );
						delete this.s.processingID;
						return false;
					}
					this.transValue 	= transValue;
					let verifyDep 		= await this.verifyDeposit();
					delete this.transValue; 
				
					/* if( ! verifyDep ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Sorry, your note does not have enough credit to fulfil this request. This may be as a result of unconfirmed Credit Deposit Transactions on your note!!!");
						return false;
					} */
					
				}
				else if( this.#transRecieve.includes( response.transType ) ) {
					
					if( ! response.blockRef || ! response.signRef ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Can't Create a Recieving Transaction Without a Reference", response );
						delete this.s.processingID;
						return false;
					}
					
					let sendBlocks 	= await this.getTransBlock(10, {blockRef: response.blockRef});
					let revBlocks 	= [], sendBlock, sendCount = 0, sendBlockIDs = [];
					//console.log( "Send Blocks Returned: ", sendBlocks, response );
					
					for(  x = 0; x < sendBlocks.length; x++  ){
						if( this.#transSend.includes( sendBlocks[x].transType ) ){
							sendBlock	= sendBlocks[x];
							if( sendBlock.blockID && sendBlock.blockRef ){
								//if we found the recieved block, we verify the BLOCK
								//to see if it is using the correct keys sent to it
								//in an encrypted manner.
								
								if( await this.Verify(response.signRef, response.blockRef, sendBlock.signRef)){
									//this verifies that the transaction block is 
									//authentically recieved.
									//console.log( sendBlock.blockID, sendCount, "verify send block Transaction");
									if( sendBlockIDs.includes( sendBlock.blockID ) ) continue;
									
									sendBlockIDs.push( sendBlock.blockID );
									sendCount++;
								} else {
									sendBlock 	= false;
								}
								
							}
							
							//sendCount++;
						} else if( this.#transRecieve.includes( sendBlocks[x].transType ) ){
							
							if( sendBlockIDs.includes( sendBlocks[x].blockID ) ) continue;
							
							sendBlockIDs.push( sendBlocks[x].blockID );
							revBlocks.push( sendBlocks[x] );
							
						}else if( sendBlock && revBlocks.length > 1 ){
							break;
						}					
					}
					
					if( ! sendBlock || ( ! this.#transSend.includes( sendBlock.transType ) && sendBlock.transType != "AGREESEND" ) || sendCount > 1 ) {
						this.response     = JSON.parse( JSON.stringify( response ) );
						if( sendCount > 1 ){
							this.#rejectResponse("Can't have more than 1 send transaction to a recieve transaction!", response );
							delete this.s.processingID;
							return false;
						}
						
						if( response.referenceID ){
							sendBlock 		= await this.getTransBlock(1, {blockID: response.referenceID});
							sendBlock 		= sendBlock[0];
							//console.log("send block returned with reference: ", sendBlock );
						}
						
						if( ! sendBlock || ! this.#transSend.includes( sendBlock.transType )){
							this.#rejectResponse("We Couldn't Find a Corresponding Transaction to Qualify Your Recipient Funds!", response );
							delete this.s.processingID;
							return false;
						}
					}					
					
					if( ! sendBlock.blockRef || ! sendBlock.signRef ) {
						this.#rejectResponse("Can't Process a Recieve Transaction Without a Valid Reference Block!!!", response );
						delete this.s.processingID;
						return false;
					}
					
					if( sendBlock.blockRef != response.blockRef ) {
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Can't Process a Recieve Transaction Without a Valid Reference Key!!!", response );
						delete this.s.processingID;
						return false;
					}
					
					//we don't expect more than one recieve block in a transaction
					//if any exist, then it should be the current response block
					if( revBlocks.length > 0 && revBlocks[0].blockID != response.blockID ){
						if( revBlocks[0].nextBlockID == response.blockID ){
							this.response     = JSON.parse( JSON.stringify( response ) );
							this.#rejectResponse("Can't Recieve a Transaction More Than Once", response );
							delete this.s.processingID;
							return false;
						} else {
							this.response     = JSON.parse( JSON.stringify( response ) );
							this.#rejectResponse("Can't Have More Than one Recipient Per Transaction", response );
							delete this.s.processingID;
							return false;
						}
					}
					
					if( ! await this.Verify(response.signRef, sendBlock.blockRef, sendBlock.signRef) ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("We Can't Verify Your References To This Block " + sendBlock.blockID + "!!!", response );
						delete this.s.processingID;
						return false;
					}
				}
				//testing the credit type, a block that connects should have the same credit type.
				if( fBlock.noteType != response.noteType ) {
					this.response     = JSON.parse( JSON.stringify( response ) );
					this.#rejectResponse('Note Type Not Matched', response );
					delete this.s.processingID;
					return false;
				}
				
							
				//since we've successfully verified that the current wallet is the maker of Scriptbill transaction, we move forward to test the integrity of the wallet hashes by verifying the 
				//signature on the block
				/* this.VerifyText = response.walletHASH;
				this.VerifyKey	= response.blockKey;
				this.signature 	= response.walletSign;
				
				if( ! await this.Verify() ) {
					this.#rejectResponse( 'Walvar id provided does not belong to a verified note!' );
					return true;
				}
				
				*/
				
				if( ! await this.Verify(response.noteSign, fBlock.blockKey, response.blockID) ) {
					this.response     = JSON.parse( JSON.stringify( response ) );
					this.#rejectResponse( 'note block seems fraudulent!', response );
					delete this.s.processingID;
					return false;
				}
				
				if( ! await this.Verify(response.blockSign, response.blockKey, response.blockHash) ) {
					this.response     = JSON.parse( JSON.stringify( response ) );
					this.#rejectResponse( 'Transaction Block does not seem verified!', response );
					delete this.s.processingID;
					return false;
				}			

				//verifying block hashes. Experimental as at 5|8|2023
				if( response.lastBlockHash && response.lastNoteHash ){
					let newHash 	= fBlock.transHash + response.lastBlockHash;
					var string 	= newHash + fBlock.totalHASH;
					let totalHASH 	= this.hashed( string );
					
					if( totalHASH != response.totalHASH ){
						/* this.#rejectResponse("Block Hashes Do Not Match. Trans Block Invalid!");
						return false; */
					}
					
				/* 	newHash 		= fBlock.noteHash + response.lastNoteHash;
					var string 		= newHash + fBlock.realHash;
					totalHASH 		= this.hashed( string );
					
					if( totalHASH != response.realHash ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						this.#rejectResponse("Block Hashes Could Not Verify Original Trans Note Hashes. Trans Block Invalid!");
						return false;
					} */
					
				}
				
				if( ! response.lastAgreeHash ){
					this.response     = JSON.parse( JSON.stringify( response ) );
					/* this.#rejectResponse("Agreements on Block Could Not Be Successfully Verified!");
					return false; */
				}
				else {
					//console.log("fBlock: " + JSON.stringify( fBlock ), "response: " + JSON.stringify( response ) );
					if( ! fBlock.agreeHash ){
						this.response     = JSON.parse( JSON.stringify( response ) );
						/* this.#rejectResponse("Agreements on Block Could Not Be Successfully Verified!");
						return false; */
					} else {
						if( ! response.lastAgreeHash.includes( fBlock.agreeHash.slice(0,6) ) ){
							/* this.#rejectResponse("Agreements on Block Could Not Be Successfully Verified!");
							return true; */
						} else {
							//more stricter verification
							var string 	= JSON.stringify( fBlock.agreements );
							let agreeHash 	= this.hashed( string );
							
							if( agreeHash != response.lastAgreeHash ){
								this.response     = JSON.parse( JSON.stringify( response ) );
								/* this.#rejectResponse("Fraudulent Agreements Detected On Transaction Block. Please Retry The Transaction With Agreements on The Block!");
								return false; */
							}
						}
					}
				}		

				//checking the agreements, budgets and subscriptions that may exists on the note.			
				
				if( ! response.witnesses ){
					response.witnesses 	= [];
				}
				
				//to verify a transaction block, your own block must also be verified.
				//also verifiers can't be more than 12 for data bulky reasons.
				//also, the node must have not verified other node to have this honor.
				//we check that by checking the verifyID handler, a variable on the verifiers
				//block. This means before calculating the note's hash, the verifyID must be deleted
				if( response.witnesses.length < 12 && ! this.#note.verifyID && this.#note.blockID != response.blockID ){
					//we get the transaction block of the verifier.
					this.blockID 	= this.#note.blockID;
					let block 		= await this.getTransBlock();
					block 			= block[0];
					
					if(  block && block.witnesses && block.witnesses.length >= 3 ){
						//checking the integrity of the verified block.
						let x, verify = {}, veriBlock, isVerified = true;
						for( x = 0; x < block.witnesses.length; x++ ) {
							verify 			= block.witnesses[x];
							this.blockID 	= verify.verifyID;
							veriBlock 		= await this.getTransBlock();
							veriBlock 		= veriBlock[0];
							
							if( ! veriBlock ) {
								response.witnesses.splice(x,1);
								continue;
							}
							
							
							isVerified			= await this.Verify(veriBlock.blockSign, veriBlock.blockKey, verify.verifyID );
							
							//no need of calculating the remaining verifiers.
							if( isVerified === false ) {
								isVerified = true;
								response.witnesses.splice(x,1);
								continue;
							}
							
							//after verifying the verifiers block. we continue in verifying
							//signature on the verified block
							
							isVerified 			= await this.Verify(verify.Sign, veriBlock.blockKey, (verify.verifyID + verify.verifyTime));
							
							//no need of calculating the remaining verifiers.
							if( isVerified === false ) {
								isVerified = true;
								response.witnesses.splice(x,1);
								continue;
							}
						}
						
						//we will only allow this node to verify blocks if the node too has been
						//verified by other nodes.
						if( isVerified ){
							//set the new verify time.
							verify.verifyTime 		= this.currentTime();
							verify.verifyID 		= block.blockID;
							let signTxt				= verify.verifyID + verify.verifyTime;
							verify.Sign 			= await this.Sign(this.#note.blockKey, signTxt);
							this.verifyID 			= response.blockID;
							this.details 			= JSON.parse( JSON.stringify( response ));
							this.details.transType 	= "UPDATE";
							this.details.transValue = 0;
							this.generateScriptbillTransactionBlock( this.details, this.#note );
							response.witnesses.push( verify );
						} 
					}
				}
				
				
				//this.storeBlock();
				this.response = response;
				await this.sendData();
				delete this.s.processingID;
				return true;
			} else {
				this.#rejectResponse("No Former Block Found For This Block: " + response.blockID, response );
				delete this.s.processingID;
				return true;
			}
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			delete this.s.processingID;
			return false;
		}
	}
	
	static async #rejectResponse( resp, response = null ){
		//console.log("#rejectResponse running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "#rejectResponse";
		
		if( ! this.response && ! response ) return;
		
		//await this.createAlert("rejecting response " + resp );
		
		try {
			
			if( ! response || ! response.blockID )
				response = JSON.parse( JSON.stringify( this.response ) );
			
			
			if( this.#note && response.blockID == this.#note.blockID  ){
				let alerted = localStorage.alerted;
				let local   = ( ( Scriptbill.s.currentNote && this.isJsonable( Scriptbill.s.currentNote ) ) ? JSON.parse( Scriptbill.s.currentNote ) : {} );
				
				if( ! alerted )
					alerted = [];
				
				else 
					alerted = JSON.parse( alerted );
				
				if( ! alerted.includes( resp ) ) {
					localStorage.alerted 		= JSON.stringify( alerted );
				
					if( this.alertDetails )
						await this.createAlert("Transaction Incomplete!!! Reason: " + resp );
					
					else{
						this.errorMessage("Transaction Incomplete!!! Reason: " + resp);
						//await this.createAlert("check Response" );
					}
				}
				//deleting the data
				 
				try { 
					let dir 				= await window.navigator.storage.getDirectory("scriptStorage", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
					if( ! dir ){
						this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
						return false;
					}
					
					let userDirectory 		= await dir.getDirectoryHandle(this.#note.noteAddress, {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
							
					let file 				= await userDirectory.getFileHandle( response.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
					let doNotDelete = false;
					
					if( resp.includes("No Former Block Found For This Block") ){
						let formerBlock = await userDirectory.getFileHandle( response.formerBlockID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						
						if( formerBlock ){
							let block = await formerBlock.getFile();
							block 		= await block.text();
							block 		= this.isJsonable( block ) ? JSON.parse( block ): false;
							
							if( block && block.blockID )
								doNotDelete = true;
						}
					}
					let scriptNote			= await userDirectory.getFileHandle( response.formerBlockID.replaceAll(/[^a-zA-Z0-9]/g, "_") + "_note", {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
					if( scriptNote ){
						let noteFile = await scriptNote.getFile();
						let text 	= await noteFile.text();
						
						if( text && this.isJsonable( text ) ){
							this.s.currentNote = text;
						}
					}
					
					if( doNotDelete ) return;
					
					//console.log("deleting...");
					file.remove();
					scriptNote			= await userDirectory.getFileHandle( response.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_") + "_note", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					scriptNote.remove();
					
					let currentBlock 		= JSON.parse( this.l[this.#note.noteAddress + "_current_block"] );
					
					if( currentBlock.blockID == response.blockID ){
						file 				= await userDirectory.getFileHandle( response.formerBlockID, {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						
						if( ! file ){
							//.replaceAll(/[^a-zA-Z0-9]/g, "_")
							file 				= await userDirectory.getFileHandle( response.formerBlockID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						}
						
						if( file ){
							let block 	= await file.getFile();
							block 		= await block.text();
							this.l[this.#note.noteAddress + "_current_block"] = block;
						}
					}
					/* this.details 		= JSON.parse( JSON.stringify( response ));
					this.details.transType = "UPDATE";
					this.details.transValue = 0;
					this.#note.blockID 		= response.formerBlockID;
					await this.generateScriptbillTransactionBlock(); */
				} catch(e){
					console.error(e);
					this.errorMessage( e.toString());
				}
			} else {
				//console.log("Random Transaction Incomplete!!! Reason: " + resp + ". TransID: " + response.blockID );
			}
			var id 				= await this.generateKey(10);
			await this.setPublicKey( response.blockKey, id );
			let blockID 		= response.blockID;
			let url 			= response.noteServer;
			
			if( this.l[blockID] ) {
				delete this.l[blockID];
			}
			
			//await this.deletePersistentData( blockID );
			
			response = this.encrypt( JSON.stringify({responseID: blockID, code: resp}), this.publicKey[id] );			
			url = this.#default_scriptbill_server;
			//console.log("Sending the response to the server....");
			await this.getData(['data', 'reject'], [response, blockID], url);
		} catch(e){
			console.error(e);
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	//Scriptbill function will help the user send money to a number of recipient;
	//configured using the sendConfig object.
	static sendConfig = {
		amount : 0,
		recipients : [],
		
	};
	
	static async parseAccount( account ){
		//console.log(" parseAccount running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "parseAccount";
		if( typeof account == "string" ){
			return account;
		}
		else if( typeof account == "object" ) {
			let keys = Object.keys( account );
			let values = Object.values( account );
			
			if( typeof keys[0] != "number" ){
				let x, data = "";
				for( x = 0; x < keys.length; x++ ){
					data += keys[x] + ": " + values[x] + " - ";
				}
				
				return data;
			}
			
			let x, data = "";
			for( x = 0; x < values.length; x++ ){
				data += values[x] + " - ";
			}
				
			return data;
		}
	}
	
	static getRanks(){
		return this.#scriptbillRanks;
	}	
		
	static exchangeConfig = {
		value 		: 1,
		sellCredit 	: "",
		buyCredit 	: "",
		sellNote  	: "",//hide the string version of the note to sell with here.
		buyAccount 	: "",//can be a note or details of the account you want your sellers to send credits to. If a 
		//scriptbill note account then you enter your Scriptbill note address
		
	};
	
	//initiate exchange function.
	//an exchange function will only run only when it has been verified by at least three nodes.
	//this transaction checks if the exchange block has been verified and initiate the exchange
	//the exchange market.
	static async initiateExchange(){
		//console.log(" initiateExchange running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "initiateExchange";
		return true;
		if( ! this.response || this.response.transType != "EXCHANGE" || this.response.transType != "WITHDRAW" || this.response.witnesses.length < 3   ) return false;
		
		let response 		= JSON.parse( JSON.stringify( this.response ) );
		
		//first we have to verify that this chap has made a transaction to the exchange market 
		//before initiating the exchange.
		this.blockRef 		= response.blockRef;
		let block 			= await this.getTransBlock();
		
		if( ! block.length ) {
			this.#rejectResponse("This Exchange Has Not Been Verified To Be Valid!", response );
			return false;
		}
		
		if( block.length ) {
			let x;
			for( x = 0; x < block.length; x++ ){
				if( block[x].transType == "SEND" || block[x].transType == "DEPOSIT" ){
					block 		= block[x];
					break;
				}
			}
		}
		
		if( block.transType != "SEND" || block.transType != "DEPOSIT" ){
			this.#rejectResponse("This Exchange Has Not Been Verified To Be Valid!", response );
			return false;
		}
		
		if( block.noteType != response.sellCredit || block.transValue != response.transValue ){
			this.#rejectResponse("This Exchange Has Not Been Verified To Be Valid!", response );
			return false;
		}
		
		//getting the exchange note of the buyCredit concerned.
		let exchangeNote;

		this.sellCredit 		= block.buyCredit;
		let sellBlocks 			= await this.getTransBlock();
		
		//if the exchange market do not exists.
		if( ! sellBlocks.length && this.#fiatCurrencies[ block.buyCredit.slice( 0, block.buyCredit.lastIndexOf("CRD")) != undefined ] ) {
			//we revert to the default fiat currency like the USD market and we change the 
			//exchange value based on the base credit.
			this.sellCredit 	= "USDCRD";
			sellBlocks			= await this.getTransBlock();
			
			if( ! sellBlocks.length ){
				this.sellCredit 	= "BTCCRD";
				sellBlocks 			= await this.getTransBlock();
				let exValues 		= await this.getExchangeValue( block.buyCredit, "BTCCRD" );
				block.transValue 	= block.transValue * exValues[0];
			}
			else {
				block.transValue 	= block.transValue * await this.getExchangeValue( block.buyCredit, "USDCRD" )[0];
			}
			
		}
		
		this.noRequest			= true;
		this.exchangeBlocks 	= JSON.parse( JSON.stringify( sellBlocks ));
		let sellBlock			= await this.getCurrentExchangeBlock();
		
		if( sellBlock.exchangeNote ){
			exchangeNote 		= JSON.parse( JSON.stringify( sellBlock.exchangeNote ) );
			exchangeNote.noteAddress 	= sellBlock.exchangeNote.exchangeID;
			exchangeNote.noteSecret		= sellBlock.exchangeNote.exchangeKey;
		}
		
		if( ! exchangeNote ) {
			this.#rejectResponse("This Exchange Has Not Been Verified To Be Valid!", response );
			return false;
		}
		
		let exValue 	= exchangeNote.noteValue * block.miningRate;
		//the exchange rate calculation shows that we are getting the exchange rate of the 
		//number of buy credit that should be sent based on the number of sell credit that has.
		//been supplied.
		let exValues 	= await this.getExchangeValue( block.buyCredit, block.sellCredit );
		let exRate 		= exValues[0];
		let totalValue 	= block.transValue * exRate;
		
		
		if( block.transType != "DEPOSIT" && totalValue < exchangeNote.noteValue ){
			this.#rejectResponse("This Exchange Note Does Not Have Enough Credit To Fulfil This Request, It May Be Fulfilled Later!", response);
			return false;
		}
		
		//create the exchange.
		this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ));
		this.details.transType 	= "SEND";
		this.details.transValue = totalValue;
		this.details.noteType 	= exchangeNote.noteType;
		this.details.recipient 	= block.blockKey;
		this.details.agreement 	= await this.createAgreement();
		this.details.agreement.execTime = parseInt(this.currentTime()) + parseInt(this.calculateTime( "3 Days" ));
		
		//saving the current note before running the exchange.
		let note 				= JSON.parse( JSON.stringify( this.#note ) );
		this.#note 				= JSON.parse( JSON.stringify( exchangeNote ) );
		return await this.generateScriptbillTransactionBlock();
		
		this.#note 				= note;
		await this.saveNote( note );
	}
		
	static async #createDeposit( amount, creditType ){
		this.successMessage("Depositing to " + this.withdrawAccount + " amount:" + amount );
		//await this.createAlert( 'amount: ' + amount );
		try {
			if( ! this.details )
				this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ));
			
			amount = parseFloat( amount ).toFixed( 2 );			
			this.details.transValue = amount;
			let testType = creditType.slice( 0, creditType.lastIndexOf("CRD"));
			//a transaction type to allow the withdrawer of credit confirms
			this.details.transType 	= "DEPOSIT";
			//payment, which after that happens, the user of such note will create a SEND transaction
			//to tell he has recieved the fiat or other cryptocurrency sent by the sender.
			this.details.noteType 	= creditType;
			//await this.createAlert("check details: " + this.details.noteType );
			if( ( ! this.realB  || ( this.realB.transType != "WITHDRAW" && this.realB.transValue < amount ) ) && ! this.#isExchangeMarketMining ){
				this.errorMessage("Can't Create a Deposit Without a Withdraw Block!!!");
				//await this.createAlert("Returning false");
				return false;
			}		
			
			if( this.realB )
				this.details.recipient 	= this.realB.blockKey;

			else if( this.#currentNote && this.#isExchangeMarketMining )
				this.details.recipient 	= this.#currentNote.noteAddress;
					
			//console.log("currentNote: " + JSON.stringify( this.#currentNote ) );
			//await this.createAlert("Check CurrentNote");
			//console.log( "REALB: " + JSON.stringify( this.realB ) );
			//await this.createAlert("check realB");
			
			if( this.withdrawAccount && this.realB )
				this.withdrawAccount.withdrawBlock = JSON.parse( JSON.stringify( this.realB ) );
			
			if( ! this.#isExchangeMarketMining && ( ! this.#currentNote || ( this.#currentNote && this.#currentNote.noteAddress != this.realB.exchangeNote.exchangeID ) ) ){
				this.#currentNote 		= JSON.parse( JSON.stringify( this.realB.exchangeNote ) );
				this.#currentNote.noteAddress = this.realB.exchangeNote.exchangeID;
				this.#currentNote.noteSecret = this.realB.exchangeNote.exchangeKey;
			}
						
							
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ) || ( ! this.#note.walletID && this.s.currentNote ) ){
				
				this.#note 			= await this.#getCurrentNote();
			}
				
			if( ! this.#note  ){
				//every note must create with a create transaction before depositing.
				this.defaultScriptbill.noteType = creditType;
				
				if( this.#fiatCurrencies[ testType ] )
					this.defaultScriptbill.creditType = "fiat";
				
				await this.createNewScriptbillWallet();
			}
			
			//before running the transaction, we create an agreement to allow the 
			//recipient send the credit to the depositor, else the agreement will
			//help the sender send the money automatically when it expires.
			if( ! this.details.agreement || typeof this.details.agreement != "object" || this.details.agreement.length )				
				this.details.agreement 	= await this.createAgreement();		
			
			
			this.details.agreement.ExecTime = parseInt( this.currentTime() ) + parseInt( this.calculateTime("3 Days") );
			this.details.agreement.withdrawAccount = typeof this.withdrawAccount == 'object' ? this.withdrawAccount.accountDetails : this.withdrawAccount;
			this.details.agreement.maxExecTime = parseInt(this.currentTime() ) + parseInt( this.calculateTime("7 Days"));
			
			if( this.#createdAgreement && this.details.agreement.agreeType == "ADVERT" && this.s.advertAgreeID ){
				this.details.agreement.agreeID 		= this.s.advertAgreeID;
			}
			
			if( this.details.agreement.agreeType == "ADVERT" ){
				this.details.transNote 			= "Earning money on your browsing activities";
			}
			
			this.details.agreement.value 		= parseFloat( amount );
			

			if( this.realB ){
				this.response 	= JSON.parse( JSON.stringify( this.realB ));
				//await this.createAlert( "tt trans: " + this.realB.transType );
			}
			
			//console.log("response block: " + JSON.stringify( this.realB ));	
			 //console.log( "depositing transValue " + this.details.transValue );
			return await this.generateScriptbillTransactionBlock( this.details, this.#note ).then( block =>{
				//console.log("block: " + JSON.stringify( block ));
				//await this.createAlert("check block!");
				this.withdrawAccount.transBlock 	= block;
				
				if( block && this.realB && this.realB.recipient && this.isJsonable( this.realB.recipient ) ){
					this.withdrawAccount.transBlock.agreement = JSON.parse( this.realB.recipient );
				}
				
				return this.withdrawAccount;
			});
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	//this function allows fiat credits to be deposited into the Scriptbill network securely and worthily
	static async depositFiat( amount = 0, creditType = "BTCCRD" ){
		//console.log("depositFiat running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "depositFiat";
		//to run this function, we simply don't assume a valid note is running this function, since the
		//depositor do not need a note to deposit. We will simply look for the exchange market of the credit
		//type and 
		try {
			this.response = JSON.parse( JSON.stringify( this.defaultBlock ) );
			
			if( this.withdrawBlock )
				this.withdrawBlock = JSON.parse( JSON.stringify( this.withdrawBlock ));
			
			
			if( ( ! this.withdrawBlock || ! this.withdrawBlock.withdrawAccount ) && ! this.isExchangeDeposit ) {
				//we try to get the exchange block to see who have our sell Credit to buy,
				//maximum blocks to return, should not be more than 500 if limit not set.
				let exBlock 	= await this.getTransBlock(100, {transType:"WITHDRAW", noteType:creditType, transValue: amount + " >="});
				let testType 	= creditType.slice( 0, creditType.lastIndexOf("CRD") );
				let x, y;
								
				this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
				
				if( ! this.realB )
					this.realB 		= false;
				
				this.#note 			= await this.#getCurrentNote();
				
				let realB, rems = 0;
				/* //console.log( "Check exBlocks: " + JSON.stringify( exBlock ) );
				await this.createAlert( "Check Ex Blocks" ); */
						
				for( x = 0; x < exBlock.length; x++ ){			
					
					this.realB 		= JSON.parse( JSON.stringify( exBlock[x] ) );
					
					if( ! this.realB || ! this.realB.blockRef || this.realB.isExchangeMarketMining || typeof this.realB.agreement != "object" ) continue;
					
					rems 			= parseFloat( this.realB.transValue );
					realB 			= await this.getTransBlock(1, {blockRef: this.realB.blockRef });
					//await this.createAlert("Getting Trans");
							
					//this shows that the block must not have a deposit transaction already set
					//before creating another one. The block ref for a WITHDRAW transaction will
					//only return more than one block unless there is a DEPOSIT transaction that
					//has referenced it.
					if( realB[0] && realB[0].blockID ) {
						for( y = 0; y < realB.length; y++ ){
							if( realB[y].transType == "DEPOSIT" ){
								rems -= parseFloat( realB[y].transValue );
							}
						}

						if( rems <= 0 ) continue;
					}
							
					if( rems >= amount ){
						//the withdraw Account is stored on this handler to help programmers project the 
						//account details to their exchangers.
						//exchange market holders can create withdrawals of their credit each time to enable
						//demanders pay into their account.
						this.withdrawAccount 	= this.realB.withdrawAccount;
						this.details.recipient 	= this.realB.blockKey;
						//if no agrreement set by the withdrawer the default plays.
						if( ! this.realB.agreement ){
							this.realB.agreement = await this.createAgreement();
							this.realB.agreement.maxExecTime = parseInt(this.currentTime() ) + parseInt( this.calculateTime("7 Days"));
							this.realB.agreement.ExecTime   = parseInt(this.currentTime() ) + parseInt( this.calculateTime("3 Days"));
						}
						this.details.agreement = JSON.parse( JSON.stringify( this.realB.agreement ));
								
						if( this.alertDetails ) {
							let withdrawAccount = await this.parseAccount( this.withdrawAccount );
							await this.createAlert( "To Make Your Exchange Transaction Valid, Please make a Transfer to this Account: " + withdrawAccount );
						}
						break;
					}
				}
			} else {
				//this is just a way of overriding the default behaviour of the script which
				//checks for withdrawal before allowing the exchange market do the deposit.
				if( this.isExchangeDeposit ){
					//first check the current server to see if the private key is stored on
					//the server.
					
					let privKey = await fetch("/depositKey.txt").then( result =>{ 
						return result.text();
					}).catch( error =>{
						//console.log("Deposit Key Error: " + error);
						return false;
					});
					
					//if not stored on the current server we check the defualt server then		
					if( ! privKey ){
						privKey 	= await fetch( this.#default_scriptbill_server + "/depositKey.txt").then( result =>{ 
							return result.text();
						}).catch( error =>{
							//console.log("Deposit Key Error: " + error);
							return false;
						});
					}
					
					if( ! privKey ){
						this.errorMessage("Private Key not found, Exchange Market Deposit Can't Be Ignited!!!");
						//console.log("Private Key not found, Exchange Market Deposit Can't Be Ignited!!!");
						return false;
					}
					
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					
					if( ! this.exchangeKey || this.exchangeKey != await this.getPublicKey(id) ){
						this.errorMessage("Exchange Key Found didn't Match...");
						//console.log("Exchange Key Found didn't Match...");
						return false;
					}
					
					//a security addition to protect unsolicited deposits.
					if( ! this.depositInstance && ! this.depositInstanceKey ){
						this.errorMessage("Unsolicited deposits not allowed when depositing to the exchange market");
						//console.log("Unsolicited deposits not allowed when depositing to the exchange market");
						return false;
					}
					
					//if no note was withdrawing credit, the exchange market takes over.
					let note = false;
					this.#isExchangeDeposit = true;
						
					if( this.#note )			
						note 		= JSON.parse( JSON.stringify( this.#note ) );
					
					let exchangeNote 		= await this.getCurrentExchangeNote( creditType );
					let noteBlock 			= await this.getTransBlock(1, {noteType: creditType});
					//console.log( exchangeNote, typeof exchangeNote );
					if( noteBlock && noteBlock.length && noteBlock[0].blockID && noteBlock[0].noteType  ) {
						
						if( ! exchangeNote || ! exchangeNote.exchangeID )
							exchangeNote 	=  await this.getCurrentExchangeNote( noteBlock[0].noteType );
						
						if( ! exchangeNote && noteBlock[0].exchangeNote && noteBlock[0].exchangeNote.exchangeID )
							exchangeNote 		= JSON.parse( JSON.stringify( noteBlock[0].exchangeNote ) );
					}
						
					if( exchangeNote && exchangeNote.exchangeID ) {
						//console.log( "exchange note " + JSON.stringify( exchangeNote ) );
						//await this.createAlert("cheeck Exchange");
						
						this.#currentNote 				= JSON.parse( JSON.stringify( exchangeNote ) );
						this.#currentNote.noteAddress 	= exchangeNote.exchangeID;
						this.#currentNote.noteSecret 	= exchangeNote.exchangeKey;
						this.#isExchangeMarketMining 	= true;
						
						if( ! this.#currentNote.walletID ){
							if( this.#fiatCurrencies[testType] ){
								var string 		= "SCRIPTBANKFIATEXCHANGEWALLET";
								this.#currentNote.walletID 	= this.hashed( string );
							} else {
								this.#currentNote.walletID 	= await this.generateKey(30);
							}
						}
						
						if( this.#currentNote.noteType != creditType )
							this.#currentNote.noteType = creditType;
						
						if( ! this.#currentNote.demandValue )
							this.#currentNote.demandValue = 0;
						
						//this.#currentNote.demandValue 	+= parseFloat( amount );
						// let noteValue 					= this.#note.noteValue;
						// this.#note.noteValue 			= this.#note.demandValue;
						this.#currentNote.withdrawAccount = {
							accountType		: 'BTC',
							accountDetails	: await this.getScriptbankAccounts()
						};
						
						//
						//this.realB 						= await this.withdrawCredit( amount );
						//this.#note.noteValue 			= noteValue;
						// this.#currentNote 				= JSON.parse( JSON.stringify( this.#note ) );
						// this.#note 						= JSON.parse( JSON.stringify(  note ) );
						
						//console.log( "withdrawal block " + JSON.stringify( this.realB  ) );
						//await this.createAlert("cheeck Withdrawal");
						
						if( this.#currentNote.withdrawAccount ){
							this.withdrawAccount 				= JSON.parse( JSON.stringify( this.#currentNote.withdrawAccount ) );
							//console.log("Running Deposits...");
							return await this.#createDeposit( amount, creditType );
						} else {
							this.errorMessage("Not Running Deposits...", this.realB);
							return false;
						}
					} else {
						this.errorMessage("No Exchange Note Found to Handle this Request!");
						//console.log("No Exchange Note Found to Handle this Request!");
						return false;
					}
					
				} else {			
					this.withdrawAccount = this.withdrawBlock.withdrawAccount;
					this.realB 				= JSON.parse( JSON.stringify( this.withdrawBlock ) );
					this.blockRef 			= this.realB.blockRef;
					let exBlocks 				= await this.getTransBlock(), rems = parseFloat( this.realB.transValue );
					
					if( exBlocks.length > 1 ){
						for( let y = 0; y < exBlocks.length; y++ ){
							if( exBlocks[y].transType == "DEPOSIT" ){
								rems -= parseFloat( exBlocks[y].transValue );
							}
						}
						
						if( rems < amount ){						
							this.errorMessage( "Withdrawal Amount too Low for requested amount, Find another Deposit Block or reduce your request by: " + ( amount - rems ));
							return false;
						}
					}
				}
			}
			if( this.withdrawAccount ){
				//await this.createAlert("withdraw exists");
				if( typeof this.withdrawAccount == "string" ){
					if( this.isJsonable( this.withdrawAccount ) ){
						this.withdrawAccount = JSON.parse( this.withdrawAccount );
					} else {
						this.withdrawAccount = {
							"accountDetails" : this.withdrawAccount,
							"accountType"	: testType
						};
					}
				}
				
				this.withdrawAccount.withdrawBlock = JSON.parse( JSON.stringify( this.realB ) );
				
				return this.#createDeposit( amount, creditType );
							
			}
			
			//if no note was withdrawing credit, the exchange market takes over.
			let note = false;
				
			if( this.#note )			
				note 		= JSON.parse( JSON.stringify( this.#note ) );
			
			let noteBlock 			= await this.getTransBlock(1, {noteType: creditType});
			
			/* //console.log("Note Block: " + JSON.stringify( noteBlock ) );
			await this.createAlert("Check note Block"); */
				
			let exchangeNote 		= false;
			
			if( noteBlock && noteBlock.length && noteBlock[0].blockID && noteBlock[0].noteType  ) {
				exchangeNote 	=  await this.getCurrentExchangeNote( noteBlock[0].noteType );
			}
				
			if( exchangeNote && exchangeNote.exchangeID ) {
				//console.log( "exchange note " + JSON.stringify( exchangeNote ) );
				//await this.createAlert("cheeck Exchange");
				this.#note 				= JSON.parse( JSON.stringify( exchangeNote ) );
				this.#note.noteAddress 	= exchangeNote.exchangeID;
				this.#note.noteSecret 	= exchangeNote.exchangeKey;
				this.#isExchangeMarketMining 	= true;
				
				if( ! this.#note.walletID ){
					if( this.#fiatCurrencies[testType] ){
						var string 		= "SCRIPTBANKFIATEXCHANGEWALLET";
						this.#note.walletID 	= this.hashed( string );
					} else {
						this.#note.walletID 	= await this.generateKey(30);
					}
				}
				
				if( this.#note.noteType != creditType )
					this.#note.noteType = creditType;
				
				if( ! this.#note.demandValue )
					this.#note.demandValue = 0;
				
				if( ! this.#note.noteValue )
					this.#note.noteValue = 0;
				
				this.#note.demandValue 			+= parseFloat( amount );
				this.#note.noteValue 			+= parseFloat( amount );
				
				this.realB 						= await this.withdrawCredit( amount );
				this.#currentNote 				= JSON.parse( JSON.stringify( this.#note ) );
				this.#note 						=  note;
				
				//console.log( "withdrawal block " + JSON.stringify( this.realB  ) );
				//await this.createAlert("cheeck Withdrawal");
				
				if( this.realB && this.realB.transType == "WITHDRAW" && this.realB.withdrawAccount ){
					this.#isExchangeMarketMining 		= false;
					this.withdrawAccount 				= JSON.parse( JSON.stringify( this.realB.withdrawAccount ) );
					return await this.#createDeposit( amount, creditType );
				} else {
					return false;
				}
			}
			else if( this.#fiatCurrencies[ testType ] ){
				//configure and create a budget for the new Scriptbank credit.
				//this credit type are reserved for Scriptbank. This does not mean Scriptbank will not create
				//other credits using traditional means.
				let budget 			= this.budgetConfig;
				budget.name 		= this.#fiatCurrencies[ testType ] + " Scriptbill Credit";
				budget.max_exec 	= "Anytime";
				budget.stockID 		= creditType;
						
				if( creditType == "SBCRD" ){
					budget.budgetCredit 	= "BTC";
				} else {
					budget.budgetCredit 	= testType;
				}
						
				budget.budgetType 		= "governmental";
				budget.orientation 		= "recursive";
				let budgetNote			= false;
					
				if( this.#note )
					budgetNote	= JSON.parse( JSON.stringify( this.#note ) );	
					
				//creating the default note that will be used to create the budget.
				this.#note 				= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
				
					
				this.#motherKeys 		= await this.#generateMotherKeys();
				/* //console.log( "motherkeys: " + JSON.stringify( this.#motherKeys ) );
				await this.createAlert("Check Mother Keys" ); */
					
				let privKey 			= this.#motherKeys.noteAddresses[ creditType ];
				var id 					= await this.generateKey(10);
				await this.setPrivateKey( privKey, id );
				this.#note.noteAddress	= await this.getPublicKey(id);
				this.#note.noteSecret 	= await this.getPrivateKey(id);
				this.#note.noteType 	= creditType;
				this.#note.withdrawAccount = {
					accountType		: 'BTC',
					accountDetails	: await this.getScriptbankAccounts()
				};
					
				//generating a unique walletID.
				var string			= "SCRIPTBANKFIATEXCHANGEWALLET";
				this.#note.walletID 	= this.hashed( string );
						
				//creating the default agreement for the budget.
				var string 			= "SCRIPTBANKCREDIT"+this.#fiatCurrencies[ testType ].toUpperCase().split(" ").join("");
				privKey 				= this.hashed( string );
				var string 			= privKey;
				budget.agreement		= await this.createAgreement( this.hashed( string ) );
				this.#note.agreements.push( {agreeID: budget.agreement.agreeID, key: budget.agreement.privateKey} );
				delete budget.agreement.privateKey;
				budget.agreement.maxExecTime 	= parseInt( this.currentTime() ) + parseInt( this.calculateTime( "3 Months" ) );
				budget.agreement.ExecTime 		= budget.agreement.maxExecTime + parseInt( this.calculateTime("3 Days") );
				budget.agreement.isPeriodic 	= true;
				budget.agreement.delayInterest  = 1;
				budget.agreement.interestType   = "COMPOUND";
				budget.agreement.interestSpread = "3 Months";
				budget.agreement.interestRate 	= 0.01;
				budget.value 					= 1;
				this.#isExchangeMarketMining 	= true;

				return await this.createScriptbillBudget(budget, this.#note).then( async block =>{
					//console.log( "trt checking: " + JSON.stringify( block ) );
					//await this.createAlert( "check budget block 4" );
					this.withdrawAccount 		= JSON.parse( JSON.stringify( this.#note.withdrawAccount ) );
					return await this.withdrawCredit( amount ).then( async block 	=>{
						//console.log( "Withdraw Block: " + JSON.stringify( block ) );
						//await this.createAlert("check withdrawal block");
						if( block && block.transType == "WITHDRAW" ){
							this.withdrawAccount.withdrawBlock = JSON.parse( JSON.stringify( block ) );
							this.#isExchangeMarketMining	= false;
							this.#currentNote 				= JSON.parse( JSON.stringify( this.#note ) );
							this.#note 						= JSON.parse( JSON.stringify( budgetNote) );
							this.realB 						= JSON.parse( JSON.stringify( block ) );
							return await this.#createDeposit( amount, creditType );
						} else {
							return false;
						}
					});	
				});
			}
				
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}					
	}
	
	static chunk_data( data, limit = 50 ){
		
		let remaining = data;
		let chunked   = [];
		
		for( let x = 0; x < remaining.length; x++ ){
			chunked.push( remaining.slice(0, limit ) );
			remaining = remaining.slice(limit, remaining.length );
		}
		
		if( remaining.length > limit ){
			let rechunked = this.chunk_data( remaining, limit );
			chunked = chunked.concat( rechunked );
		} else if( remaining.length ){
			chunked.push( remaining );
		}
			
		return chunked;
	}

	//this function creates and configures the exchange block into the network.
	//it also helps depositors of fiat credits to deposit their fiats into the fiat accounts
	//on the exchange market or satifying a withdrawal request.
	//a withdrawal request is also satisfied by the exchange market if it has been verified by 
	//at least three blocks
	static async exchangeCredits(){
		//console.log("exchangeCredits running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] 	= "exchangeCredits";
		
		//initializing storage.
		
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();			
			
			//console.log( "this.note: " + JSON.stringify( this.#note ) );
			
			//the response variable should be set before running the exchangeCredit function
			if( ! this.response && this.exchangeConfig.sellCredit ) {
				
				let testType;
				
				if( this.exchangeConfig.sellCredit.includes("CRD") && ( this.exchangeConfig.sellCredit.length - this.exchangeConfig.sellCredit.lastIndexOf("CRD") ) == 3 ) { 
					testType = this.exchangeConfig.sellCredit.slice( 0, this.exchangeConfig.sellCredit.lastIndexOf("CRD") );
				}else{
					testType = this.exchangeConfig.sellCredit;
				}
				
				if( ! this.#note || ! this.#fiatCurrencies[ testType ] || this.#note.noteType == this.exchangeConfig.sellCredit ) {
					
					//creating a send transaction of the credit to the exchange market
					this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ) );
					this.details.transType 	= "SEND";
								
					this.details.noteType = this.exchangeConfig.sellCredit;
					
					
					this.noteTypeS 		= this.exchangeConfig.sellCredit;
					let sellBlock 		= await this.getTransBlock();
					let exchangeNote;
						
					if( sellBlock && sellBlock.length > 0 ){
						sellBlock 		= sellBlock.length ? sellBlock[ sellBlock.length - 1 ] : sellBlock;
							
						if( sellblock && sellBlock.exchangeNote ){
							exchangeNote 				= JSON.parse( JSON.stringify( sellBlock.exchangeNote ) );
							exchangeNote.noteAddress 	= sellBlock.exchangeNote.exchangeID;
							exchangeNote.noteSecret		= sellBlock.exchangeNote.exchangeKey;
						}						
					}
						
					if( exchangeNote ) {
						this.details.recipient 	= exchangeNote.noteAddress;
						if( this.#currentNote )
							this.currentNote = JSON.parse( JSON.stringify( this.#currentNote ));
						
						this.#currentNote 		= JSON.parse( JSON.stringify( exchangeNote ) );
					}
					else {
						//if we can't find the exchange note of the sellCredit we don't trust the transaction.
						this.errorMessage("The Exchange Credit Requested To Be Sold Does Not Have a Valid Exchange Account. Transaction now Aborting!!!");
						return false;
					}			
					
					this.details.transValue 	= this.exchangeConfig.value;
					this.details.agreement 		= await this.createAgreement();
					return await this.generateScriptbillTransactionBlock( this.details );
					
					//delaying the execution of the script till at least 2 seconds.
					setTimeout( function(){
						if( newBlock ){
							this.response = JSON.parse( JSON.stringify( newBlock ) );
						} else {
							this.response = false;
						}
						
						if( this.response )
							this.exchangeCredits();
						
					}, 2000 );

					return;
					
				} else {
					//if the sellcredit is a fiat currency and the test credit is not the current
					//note running. We create a deposit transaction instead.
					//test the sellCredit to be sure the credit is configured in a way Scriptbill will understand it.
					let testCredit = this.exchangeConfig.sellCredit.length - this.exchangeConfig.sellCredit.lastIndexOf("CRD");
					if( testCredit.length != 3 ){
						this.exchangeConfig.sellCredit += "CRD";
					}
					this.depositFiat( this.exchangeConfig.value, this.exchangeConfig.sellCredit );
				}
				
			}
			
				
			if( ! this.response || ! this.response.transValue || ! this.response.noteType || ! this.#note || this.#note.noteType == this.response.noteType ) return 0;//COMING
			
			
			this.details 			= JSON.parse( JSON.stringify( this.response ) );
			this.details.transType 	= 'EXCHANGE';
			//the sell credit is that credit that you supply to the exchange market
			this.details.sellCredit = this.response.noteType;
			//the buy credit is that credit you demand from the exchange market.
			this.details.buyCredit	= this.#note.noteType;
			//to help traders understand where to sell their credits to, the buyer must specify an account.
			//the account must he able to hold credit specified in the buyCredit handler.
			this.details.buyAccount = this.#note.withdrawAccount ? await this.parseAccount( this.#note.withdrawAccount ) : this.#note.noteAddress;//the withdraw account handler is always set if the current note is a non Scriptbill Credit type
			
			/*if( this.response.accountCredit )
				this.details.creditType = this.response.accountCredit;
			
			else
				this.details.creditType = 'scriptbills'; */
			
		
			//this will help Scriptbills generate the exchange request in the network
			return await this.generateScriptbillTransactionBlock();	
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}		
		
	}
	
	//withdrawal of credit must be automatically handled for it to be a transaparent transaction
	static async withdrawCredit( value ){
		//console.log("withdrawCredit running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "withdrawCredit";
		
		//initializing storage.
		
		try {
			if( this.currentNote )
				this.#note = JSON.parse( JSON.stringify( this.currentNote ));
			
			//attempt getting the note if not found.
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote && ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
			
			if( ! this.#note ) return false;
			
			//console.log("withdrawCredit running " + this.funcUp[ this.funcUp.length] );
			this.funcUp[ this.funcUp.length] = "withdrawCredit";
			let accountDetails;
			
			if( this.withdrawAccount )
				accountDetails = this.withdrawAccount ;
			
			else if( this.#note.withdrawAccount ) {
				accountDetails = this.#note.withdrawAccount;
					
			} else {
				this.errorMessage("Withdraw Account Not Set to Withdraw Credit");
				//console.log("Withdraw Account Not Set to Withdraw Credit");
				return false;
			}
			
			
			//this.#note.withdrawAccount = accountDetails;
			this.#currentNote = await this.getCurrentExchangeNote( this.#note.noteType );
			
			if( this.#currentNote && this.#currentNote.noteValue > value ){
				let demand = this.#currentNote.demandValue;
				let rate 	= parseFloat( this.#currentNote.noteValue ) / ( parseFloat( this.#currentNote.demandValue ) - parseFloat( this.#currentNote.exchangeValue ) );
				
				if( rate > this.#miningRate ){
					this.#isExchangeDeposit 	= true;
				} else {
					this.#isExchangeDeposit 	= false;
				}
			}
					
			this.details = JSON.parse( JSON.stringify( this.defaultBlock ) );
			this.details.transType = "WITHDRAW";
			this.details.transValue = value;
			this.details.noteType 	= this.#note.noteType;
			this.details.withdrawAccount = accountDetails;//to change the account details, the user must create 
			//an update transaction that will update the account details.
			//console.log("Running Withdraw and generating blocks");
			return await this.generateScriptbillTransactionBlock( this.details, this.#note );
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
		
	}
	
	
	static async getExchangeValue( creditType1, creditType2 ){		
		//console.log("getExchangeValue running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getExchangeValue";
		//to get the exchange value of a credit, we have to know the total unit of a credit supplied to the exchange market.
		try {
			let testType1, testType2;
			this.creditType1 = "scriptbill";
			this.creditType2 = "scriptbill";
			let creditType, totalDemand;
			const exRates = await fetch("/exRate.json").then( resp =>{ return resp.json(); }).then( data =>{ return data; }).catch( async error =>{ /*//console.log("Error from exchange rate " + error + " getting from main server ");*/ return await fetch( this.default_scriptbill_server + "/exRate.json" ).then( resp =>{ return resp.json(); }).then( data =>{ return data; }).catch( error =>{ /*//console.log("Error from exchange rate " + error );*/ return false; }); });
			
				
			if( creditType1.includes("CRD") && ( creditType1.length - creditType1.lastIndexOf("CRD") ) == 3  ){
				testType1 = creditType1.slice( 0, creditType1.lastIndexOf("CRD") );
			}
			else {
				testType1 = creditType1;
			}
			if( this.#fiatCurrencies[ testType1 ] ){
				this.creditType1 = "fiat";
			}
			
				
			if( creditType2.includes("CRD") && ( creditType2.length - creditType2.lastIndexOf("CRD") ) == 3  ){
				testType2 = creditType2.slice( 0, creditType2.lastIndexOf("CRD") );			
			}
			else {
				testType2 = creditType2;
			}
			if( this.#fiatCurrencies[ testType2 ] ){
				this.creditType2 = "fiat";
			}
			
			
			if( this.creditType1 == "fiat" && this.creditType2 == "fiat" && exRates && exRates.rates && exRates.rates[ testType1 ] && exRates.rates[ testType2 ] ) {
				//run exchange code	
				var exRate1 		= exRates.rates[ testType1 ] / exRates.rates[ testType2 ];						
				var exRate2 		= exRates.rates[ testType2 ] / exRates.rates[ testType1 ];
				
				return [ exRate1, exRate2 ];
			}
			else if( ( this.creditType1 == "scriptbill" && this.creditType2 == "fiat" ) || ( this.creditType1 == "fiat" && this.creditType2 == "scriptbill" ) ){
				
				if( this.creditType1 == "scriptbill" ){
					creditType 	= creditType1;				
				}
				else {
					creditType 	= creditType2;
					creditType2 = creditType1;
				}
				
				if( creditType != "SBCRD" ){
					this.sellCredit = creditType;
					this.buyCredit  = creditType;
					this.transType  = 'EXCHANGE';
					let exchangeNote  = await this.getCurrentExchangeNote( creditType );
					/* let currentRate 	= parseFloat( exchangeNote.noteValue ) / ( parseFloat( exchangeNote.demandValue ) - parseFloat( exchangeNote.exchangeValue ) ); */
					totalDemand  	=	( parseFloat( exchangeNote.demandValue ) - parseFloat( exchangeNote.exchangeValue ) );
					totalSupply		= parseFloat( exchangeNote.noteValue );
					
					if( exchangeNote.noteType != creditType2 ){
						let exRates 		= await this.getExchangeValue( exchangeNote.noteType, creditType2 );
						totalSupply			= totalSupply * exRates[1];
					}
					return [ totalDemand / totalSupply, totalSupply / totalDemand ];
					

				} else {
					creditType2 		= creditType2.slice( 0, creditType2.lastIndexOf("CRD") );
				
					let exRates         = await this.getData("base", "USD", "https://api.exchangerate.host/latest" );
					/* //console.log("exRates: " + exRates, "stringified: " + JSON.stringify( exRates ) );
					await this.createAlert("check exRate" ); */
					this.exRate1 = 1;
					this.exRate2 = 1;
					
					if( exRates && exRates.rates ){
						this.l[ "USDEX" ] = JSON.stringify( exRates.rates );
						exRates 			= exRates.rates;
					} else if( this.l[ "USDEX" ] && this.isJsonable( this.l[ "USDEX" ] ) ){
						exRates 	= JSON.parse( this.l[ "USDEX" ] );	
					} else {
						let urle;
						if( chrome && chrome.runtime && Object.hasOwn( chrome.runtime, "getURL" ) ){
							urle = chrome.runtime.getURL("exRate.json");
						} else {
							urle = "/exRate.json";
						}
						exRates 	= await fetch(urle).then( resp =>{return resp.json();} ).then(result =>{  return result;});
						
						if( exRates ){
							exRates 	= exRates.rates;
						}
						
						/* //console.log( "rates: " + JSON.stringify( exRates));
						await this.createAlert("check exRate 2" ); */
					}
					
					if( exRates && exRates[ creditType2 ] )
						this.exRate1 	= exRates[ creditType2 ];
					
					exRates         = await this.getData("base", creditType2, "https://api.exchangerate.host/latest" );
					//console.log( 'exrates', exRates, JSON.stringify( exRates ));
					
					if( exRates ){
						this.l[ creditType2 + "EX" ] = JSON.stringify( exRates.rates );
						exRates 			= exRates.rates;
					} else if( this.l[ creditType2 + "EX" ] && this.isJsonable( this.l[ creditType2 + "EX" ] ) ){
						exRates 	= JSON.parse( this.l[ creditType2 + "EX" ] );	
					}
					if( exRates && exRates[ "USD" ] )
						this.exRate2 	= exRates[ "USD" ];
					
					return [ this.exRate1, this.exRate2 ];
				}
				
			}
			else if( this.creditType1 == "scriptbill" && this.creditType2 == "scriptbill" ){
				this.sellCredit = creditType1;
				this.transType  = 'EXCHANGE';
				let sellBlocks  = await this.getTransBlock();
				let x, block, totalSupply = 1, lastTime = 0, lastBlock, totalDemand = 1;
				let exRate, demand, supply, exRate1, exRate2;
				for(  x = ( sellBlocks.length - 1); x > ( sellBlocks.length - 500 ) && x >= 0 ; x-- ){
					block 			= JSON.parse( JSON.stringify( sellBlocks[x] ) );
					
								
					if( lastBlock && lastBlock.transTime < block.transTime ) {
						lastBlock = JSON.parse( JSON.stringify( block ) );
					}
				}
				
				if( typeof lastBlock == "object" ){
					//this is because the total supply to the exchange market is the total value of 
					//exchange credit in the exchange market. The most recent block in the time 
					//the credit type was supplied will have the most accurate information about the 
					//exchange market.
					this.#miningRate = lastBlock.miningRate;
					totalSupply = lastBlock.exchangeNote.exchangeValue * this.#miningRate;
					
					if( creditType2 != "SBCRD" ){
						demand  		= lastBlock.exchangeNote.noteValue;
						totalDemand  	= await this.getTotalFiat();
						this.sellCredit = "SBCRD";
						this.transType 	= "EXCHANGE";
						sellBlocks 		= await this.getTransBlock();
						this.noRequest 	= true;
						this.exchangeBlocks = JSON.parse( JSON.stringify( sellBlocks ));
						lastBlock 		= await this.getCurrentExchangeBlock();
						supply			= lastBlock.exchangeNote.exchangeValue;
						exRate 			= totalDemand / supply;
						totalDemand 	= demand * exRate;
					}
					else {
						totalDemand  = await this.getTotalFiat();
					}
				
				}
				
				exRate1 = totalDemand / totalSupply;
				
				this.sellCredit = creditType1;
				this.transType  = 'EXCHANGE';
				sellBlocks  = await this.getTransBlock();
				for(  x = ( sellBlocks.length - 1); x > ( sellBlocks.length - 500 ) && x >= 0 ; x--  ){
					block 			= JSON.parse( JSON.stringify( sellBlocks[x] ) );
					
								
					if( lastBlock && lastBlock.transTime < block.transTime ) {
						lastBlock = JSON.parse( JSON.stringify( block ) );
					}
				}
				
				if( typeof lastBlock == "object" ){
					//this is because the total supply to the exchange market is the total value of 
					//exchange credit in the exchange market. The most recent block in the time 
					//the credit type was supplied will have the most accurate information about the 
					//exchange market.
					this.#miningRate = lastBlock.miningRate;
					totalSupply = lastBlock.exchangeNote.exchangeValue * this.#miningRate;
					
					if( creditType1 != "SBCRD" ){
						demand  		= lastBlock.exchangeNote.noteValue;
						totalDemand  	= await this.getTotalFiat();
						this.sellCredit = "SBCRD";
						this.transType 	= "EXCHANGE";
						sellBlocks 		= await this.getTransBlock();
						this.noRequest 	= true;
						this.exchangeBlocks = JSON.parse( JSON.stringify( sellBlocks ) );
						lastBlock 		= await this.getCurrentExchangeBlock();
						supply			= lastBlock.exchangeNote.exchangeValue;
						exRate 			= totalDemand / supply;
						totalDemand 	= demand * exRate;
					}
					else {
						totalDemand  = await this.getTotalFiat();
					}
				
				}
				
				exRate2 		= totalDemand / totalSupply;
				
				return [ exRate1 / exRate2, exRate2 / exRate1 ];			
			}
		} catch(e){
			console.error(e);
			return false;
		}
			
	}
	
	static generateHashBlock( algo = false ){
		let one = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ1234567890=";
		let two = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ1234567890=";
		let three = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ1234567890=";
		let equal = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ1234567890=";
		let additions = "`~!@#$%^&*()-_+}{[]|\\\"':;?/>.<,";
		try {
			//creating the hash table.
			let x, y, z, k, let1, let2, let3, key;
			let hash = {};
			
			for( x = 0; x < one.length; x++ ){
				let1 = one[x];
				for( y = 0; y < two.length; y++ ){
					let2 = two[y];
					for( z = 0; z < three.length; z++ ){
						let3 = three[z];
						key  = let1 + let2 + let3;
						if( y > 0 ){
							k = y - 1;
						}
						hash[ key ] = equal[z] + ( additions[k] ?  additions[k] : "" );
						/* //console.log( "key: " + key );
						//console.log( "equals: " + hash[ key ] ); */
						
					}
				}
			}
			let hashes = JSON.stringify( hash );
			/* await this.createAlert( hashes.length );
			//console.log( hashes ); */
			let hint;
			for( x = 0; x < hashes.length; x++ ){
				hint = hashes.slice( 0, 200 );
				hashes = hashes.slice( 200, hashes.length );
				localStorage['hashROCK'+x] = hint;
			}
			//localStorage.hashROCK = JSON.stringify( hash );
		} catch(e){
			console.error(e);
			return false;
		}		
	}
	
	static async hashBlock( data = "" ){
		
		let url;
		try {
			if( chrome && chrome.runtime && Object.hasOwn( chrome.runtime, "getURL" ) ){
				url 	= chrome.runtime.getURL("hashBlock.json");
			} else {
				url 	= location.origin + "/hashBlock.json";
			}
			
			let hashBlock = await this.getData("","",url);
			
			if( ! hashBlock ){
				this.errorMessage("no Hash Block Stored on This Server, Please run the generate hash Block function to create an hash block for this server with your own algorithm if you want. Save the generated json file on the index of your server, which could be gotten using http request before using this function.");
				return data;
			}
			
			
			
			if( typeof data == "object" )
				data 		= JSON.stringify( data );
			
			data 	= data.toString();
			
			if( typeof data != "string" ) return data;
			
			let x, save = "", dat;
			for( x = 0; x < data.length; x++ ){
				dat 	= data.slice(0, 3);
				save 	+= hashBlock[dat];
				data 	= data.slice( 3, data.length );
			}
			return save;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async getTotalFiat( base = "USDCRD" ){
		//console.log("getTotalFiat running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getTotalFiat";
		try {
			let symbol, credit, totalDemand = 0, sellBlocks, rate;
			const exRates = await fetch("/exRate.json").then( resp =>{ return resp.json(); }).then( data =>{ return data; }).catch( async error =>{ /*//console.log("Error from exchange rate " + error + " getting from main server "); */ return await fetch( this.default_scriptbill_server + "/exRate.json" ).then( resp =>{ return resp.json(); }).then( data =>{ return data; }).catch( error =>{ /*//console.log("Error from exchange rate " + error );*/ return false; }); });
					
			this.sellCredit = base;
			this.transType 	= "EXCHANGE";
			sellBlocks 		= await this.getTransBlock();
						
			//any fiat credit whose exchange market is not featured by scriptbill
			//will not be calculated.
			if( ! sellBlocks[0].blockID ) return;
					
			this.noRequest 			= true;
			this.exchangeBlocks 	= JSON.parse( JSON.stringify( sellBlocks ) );
			lastBlock 				= await this.getCurrentExchangeBlock();
					
			if( credit == base ){
				totalDemand += lastBlock.exchangeNote.exchangeValue;
			}
			
			return totalDemand;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	
	static async sendMoney(){
		//console.log("sendMoney running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "sendMoney";
		var funcUp	= this.funcUp[ this.funcUp.length];
		let rep = this.sendConfig.recipients;
		
		//initializing storage.
		
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
				
			if( ! this.#note ) {
				this.errorMessage("Can't send money without a Valid Scriptbill note data", funcUp);
				return false;
			}
			
					
			if( ! this.walletID ){
				this.walletID = this.#note.walletID;
			}
			
			if( rep.length <= 0 || ! this.walletID ) return;
			
			let y, z = 0, x, block = [];
			
			for( x = 0; x < rep.length; x++ ) {
				this.details = JSON.parse( JSON.stringify( this.defaultScriptbill ) );
				this.details.noteAddress = this.#note.noteAddress;
				
				//configuring the transaction value.
				if( typeof this.sendConfig.amount != 'object' )
					this.details.transValue = parseFloat( await this.sendConfig.amount );
				
				//if the amount handler was configured as an array.
				else {
					if( typeof  this.sendConfig.amount[x] != 'undefined' ){
						if( typeof this.sendConfig.amount[x] != 'object' )
							this.details.transValue = parseFloat( this.sendConfig.amount[x] );
						
						else
							this.details.transValue = 0;
					}
					else {
						//instead we keep reverting back and forth the amount array to set the transaction value.
						if( ! y ){
							y = x - 1;
						}
						if( typeof this.sendConfig.amount[y] != 'undefined' && ! z ){
							if( typeof this.sendConfig.amount[y] != 'object' ){
								this.details.transValue = parseFloat( await this.sendConfig.amount[y] );
								break;
							}							
							else
								this.details.transValue = 0;
							
							y--;
						} else {
							y = 1;
							
							if( ! z ) 
								z = y;
								
							
							if(typeof this.sendConfig.amount[z] != 'undefined' && y == 1 ){
								if( typeof this.sendConfig.amount[z] != 'object' ){
									this.details.transValue = parseFloat( this.sendConfig.amount[y] );
									break;
								}							
								else
									this.details.transValue = 0;
								
								z++;
							} else {
								y = z;
								z = undefined;
							}
						}					
						
					}
				}
							
				this.details.recipient = rep[x];
				this.details.transType = 'SEND';
				
				if( this.sendConfig.note )
					this.details.note = this.sendConfig.note;
				
				block.push( await this.generateScriptbillTransactionBlock(this.details, this.#note ) );
				
			}
			
			return block;
		} catch(e){
			this.errorMessage(e.toString(), funcUp);
			console.error(e);
			return false;
		}
	}
	
	static getDefaultServer(rand = false){
		
		if( ! rand )
			return this.#default_scriptbill_server;
		
		let servers = [ this.#default_scriptbill_server ];
		return servers[Math.round( Math.random() * servers.length )];		
	}
	
	static async download_note( noteAddress = '', download = true ){
		//console.log("download_note running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] 	= "download_note";
		var funcUp 		= this.funcUp[ this.funcUp.length];
		
		let note;//the stringified version of the note object.
		
		//initializing storage.
				
		//console.log( "hidden password while downloading note: " + this.#password )
		//console.log( "current note: " + JSON.stringify( this.#note ) );
		//console.log( "current note: " + JSON.stringify( this.#splitNote ) );
		//await this.createAlert( (( this.#note && this.s.currentNote && ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote )) && ! this.#splitNote );
		try {	
			if( (( this.#note && this.s.currentNote && ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote )) && ! this.#splitNote ) {
				this.#note = await this.#getCurrentNote();
			
				//console.log( "current note: " + JSON.stringify( this.#note ) );
				
			}
			else if( ! this.#note && noteAddress ) {
					this.#note 		= await this.#getNote( noteAddress );	
			}	
			else if( this.noteAddress && ! this.#note ){
				this.#note 		= await this.#getNote( this.noteAddress );
				
			}

			
			if( ! this.#note ){
				this.errorMessage("no note data was found to download", funcUp );			
				return false;
			}
			
			
			if( this.#note ){
				this.#note.block = this.l[ this.#note.noteAddress + "_current_block" ] ? this.l[ this.#note.noteAddress + "_current_block" ] : await this.getTransBlock(1,{blockID:this.#note.blockID});
				
				if( this.#note.block && this.#note.block.length && typeof this.#note.block == "object" )
					this.#note.block 		= this.#note.block[0];
				
				else if( this.#note.block && this.isJsonable( this.#note.block ) )
					this.#note.block 	 	= JSON.parse( this.#note.block );
				
				if( ! this.splitPersistently ){
					let blocks 			= await this.getNoteTransactions();
					this.#note.blocks 	= blocks;
				}			
			}
			
			
			let accountData = await this.getAccountData();
					
			if( accountData && accountData[this.#note.noteAddress] ){
				this.#note.accountData 	= accountData[ this.#note.noteAddress ];
				this.#note.rank  		= accountData.rank;
				this.#note.rankValue 	= accountData.value;
				this.#note.loanValue 	= accountData.loanValue;
			}
			
			
			if(  ! this.noteAddress || this.noteAddress != this.#note.noteAddress )
				this.noteAddress 		= this.#note.noteAddress;
			
			//console.log( "Password before download " + this.#password );
			//await this.createAlert("Take Note!");
			
			if( ! this.#password && ! this.splitPersistently )
				this.#password = await this.#getPassword();
			
			else if( this.splitPersistently && typeof this.splitPersistently == "string" )
				this.#password 	= await this.#generatePassword( this.splitPersistently );		
			
			
			
			var string 			= this.#password;
			note 				= JSON.stringify( this.#note );
			let pass 			= this.hashed( string );
			//console.log("hashed: " + pass );
			//await this.createAlert("check hashed");
			this.noteEncrypt 	= this.encrypt( note, pass );
			
			let noteEncrypt 	= await this.binarilize();
			
			if( this.l.currentNoteSaved )
				this.l.currentNoteUpload = noteEncrypt;
			
			//console.log( 'note encrypt: ' + noteEncrypt );
					
			if( noteEncrypt ){
				//delete any uploaded note before downloading the new note.
				
				delete this.s.uploadedNote;
				delete sessionStorage.uploadedNote;
				//delte the current note.
				
				delete this.s.currentNote;
				delete sessionStorage.currentNote;
				
				if( chrome && chrome.storage ){
					await chrome.storage.session.remove("currentNote");
				}
				
				if( this.#passwordKey )
					this.#passwordKey 		= false;
				
				
				delete this.l.user_pass;
				delete localStorage.user_pass;
				
				if( ! this.splitPersistently ){
					let storage 		= await navigator.storage.getDirectory("scriptStorage", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
					if( ! storage ){
						this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed", funcUp );
						return false;
					}
					
					let dir 		= await storage.getDirectoryHandle("userNotes", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
					if( ! dir ){
						this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed", funcUp );
						return false;
					}
					
					if( this.s.user_name ){
						let userDir 	= await dir.getFileHandle( this.s.user_name, {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
						let write 		= await userDir.createWritable();
						await write.write( noteEncrypt );
						await write.close();
					} 
					
					let userDir 	= await dir.getFileHandle( this.#note.noteAddress.replaceAll(/[^a-zA-z0-9]/g, "") + ".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					let write 		= await userDir.createWritable();
					await write.write( noteEncrypt );
					await write.close();
				}

				if( this.s.uploaded ){
					await this.deletePersistentData(this.s.uploaded, 'binaries');
					delete this.s.uploaded;
				}
				
				delete this.splitPersistently;//forgotten forever, senders take note.
				
				if( download ){			
					this.download( noteEncrypt, this.noteAddress + '.script', 'text/plain' );
					return true;
				}
				
				return noteEncrypt;
			}
		} catch(e){
			this.errorMessage(e.toString(), funcUp);
			console.error(e);
			return false;
		}
	}
	//https://github.com/AbyssalArmy/SmsEye/raw/main/sms%20eye%20app.apk
	//https://jiji.ng/api_web/v1/listing?slug=home-garden&webp=true&page=43&po=84.84.84&lsmid=1675349426720
	static async download( data, filename, dataType ){
		//console.log("download running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "download";
		if( ! dataType ) dataType = 'application/octet-stream';
		
		try {
			var a = document.createElement('a');
			var blob = new Blob( [data, { 'type': dataType }] );
			a.href = window.URL.createObjectURL( blob );
			a.download = filename;
			a.click();
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return;
		}
	}
	
	static async getScriptbankAccounts( num = 1 ){
		//console.log("getScriptbankAccounts running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getScriptbankAccounts";
		let rand 	= Math.round( Math.random() * this.#ScriptbankAccounts.length );		
		if( num > 1 ){
			rand = num;
		}		
		
		let data 	= this.#ScriptbankAccounts[ rand ];
		//console.log("rand " + rand, "account data: " + data );
		return data;
	}
	
	static async binarilize(){
		//console.log("binarilize running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "binarilize";
		
		if( ! this.noteEncrypt ) return;
		
		return this.noteEncrypt.split('').map( function ( char ) {
			return char.charCodeAt( 0 ).toString(2);
		}).join(' ');
	}
	
	static async debinarilize(){
		//console.log("debinarilize running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "debinarilize";
		if( ! this.binary ) return;
		
		if( this.binary.toString().includes(' ') ){
			return this.binary.toString().split(' ').map( function(bin) {
				return String.fromCharCode( parseInt( bin, 2 ) );
			}).join('');			
		}
		
		return String.fromCharCode( parseInt( this.binary, 2 ));
	}
	
	//Scriptbill function is designed to save the current note details to the database when generating a transaction.
	//everyhting is saved locally on the client'this.s server, Scriptbill means that an attempt to log in even with the same details//on a strange server would not work, except there is an access to the current server.
	static async saveNote( note = false, noteAddress = '' ){
		//console.log("saveNote running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "saveNote";
		//if the note address is not set, we return the this.
		//await this.createAlert( ! this.#note );
		if( ( ! this.noteAddress && noteAddress == '' ) && ! this.#note ) {
			this.errorMessage("couldn't find note to save when runing Scriptbill function saveNote");
			return;			
		}
		
		try {
			//console.log("Saving note!!!", note.noteValue );
			if( ! this.#saveNote ) return;
			
			if( this.executeStrictly && this.note )
				this.#note = this.note;		
			
			//this.autoInvestScriptbillBudget();	

			//console.log("Saving note!!!");
			
			let messages = [];
			if( this.s.message )
				messages = JSON.parse( this.isJsonable( this.s.message ) ? this.s.message : '{}' );
			
			messages.push('We are storing the current note for ' + this.walletID);
			this.s.message = JSON.stringify( messages );
			
			if( noteAddress != '' )
				this.noteAddress = noteAddress;
			
			else if( ! this.noteAddress || this.#note.noteAddress != this.noteAddress  )
				this.noteAddress = this.#note.noteAddress;
			
			
			if( ! this.#password )
				this.#password = await this.#getPassword();	
			
			
			if( ! this.#password ) {
				let pass 		= await this.generateKey( 15 );
				this.#password = await this.#generatePassword( pass );
				this.errorMessage("Note was saved with an autogenerated password!!! Please ensure you save this password to use later while logging in your note to the server. " + pass );
			}
			
			if( note && note.noteAddress )
				this.#note 	= JSON.parse( JSON.stringify( note ));
				
			
			return await this.setCurrentNote( note ).then( async currentNote =>{
				//console.log("Current Note Saved!!!");
				let notes	= await this.getDataPersistently('ScriptNotes', 'notes');
				let person	= await this.getDataPersistently('ScriptNotes', 'persons');
				
			
				if( ! notes || ! this.isJsonable( notes ) )
					notes = {};
				
				else 
					notes = JSON.parse( notes );
				
				
				let noteStr 				= JSON.stringify( this.#note );
				let password 				= await this.generateKey();
				notes[ this.noteAddress ]	= this.encrypt( noteStr, password );			
				await this.savePersistently(notes, 'ScriptNotes', 'notes');
				
				
				if(  this.#password ){
					
					if( ! person ){
						let o = {};
						o.walletID = this.#note.walletID;
						o.transTime = this.currentTime();
						var string = JSON.stringify( o ) + this.#password;
						o.hash		= this.hashed( string );
						person = JSON.parse( JSON.stringify( o ));
					}
					var string 	=  this.#password;
					person[this.#note.noteAddress]  			= {};
					person[this.#note.noteAddress].password 	= this.encrypt( password, this.hashed( string ) );
					person[this.#note.noteAddress].transTime 	= this.currentTime();
					var string 								= person[this.#note.noteAddress].password + person[this.#note.noteAddress].transTime;
					person[this.#note.noteAddress].hash 		= this.hashed( string );
					delete 	person.hash;
					var string 				= JSON.stringify( person );
					person.hash 				= this.hashed( string );
					await this.savePersistently( person, 'ScriptNotes', 'notes' );
				}
				return currentNote;
			});
		} catch(e){
			console.error(e);
			return false;
		}
	}	

	static async storeBlock( response = false, note = false ){
		//console.log("storeBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] 	= "storeBlock";
		
		try {
			let trivKey;
			//meant to store only scriptbill transaction blocks
			if( ( ! this.response || ! this.response.blockID  ) && ( ! response || ! response.blockID ) ) return false;
			
			if( ! response || ! response.blockID ){
				response = JSON.parse( JSON.stringify( this.response ));
			}
			
			if( response.exchangeNote && response.exchangeNote.exchangeID && response.exBlockID ){
				var string 		= response.exchangeNote.exchangeID;
				trivKey 			= this.hashed( string );
				if( ( this.l[ trivKey ] && this.l[ trivKey + "_triv_time" ] && this.l[ trivKey + "_triv_time" ] <= response.transTime ) || ! this.l[trivKey] ){
					this.l[ trivKey ] 	= response.exBlockID;
					this.l[ trivKey + "_triv_time" ] = response.transTime;
				}
			}
			if( response.productNote && response.productNote.exchangeID && response.productBlockID ){
				var string 		= response.productNote.exchangeID;
				trivKey 			= this.hashed( string );
				if( ( this.l[ trivKey ] && this.l[ trivKey + "_triv_time" ] && this.l[ trivKey + "_triv_time" ] <= response.transTime ) || ! this.l[trivKey] ){
					this.l[ trivKey ] 	= response.productBlockID;
					this.l[ trivKey + "_triv_time" ] = response.transTime;
				}
			}
			
			//await this.createAlert( "Storing Block " + response.blockID );
			
			if( ( ! note || ! note.noteAddress ) && this.#note )
				note 	= JSON.parse( JSON.stringify( this.#note ));
			
			
			//await this.createAlert("Storing Block");
			//console.log( "Storing Block" + JSON.stringify( response ) );
			//let saveNote 		= await this.saveNote();
			
			if( ! response.budgetID || ! response.exchangeNote || ! response.exchangeNote.exchangeID ){
				this.errorMessage("Can't Store a Block Without an Exchange Note or a Budget ID.");
				if( ! response.noteType )
					return false;
				
				let exchangeNote 		= await this.getCurrentExchangeNote( response.noteType );
				
				if( exchangeNote && exchangeNote.noteType == response.noteType && exchangeNote.exchangeID && exchangeNote.budgetID ) {
					response.exchangeNote 	= JSON.parse( JSON.stringify( exchangeNote ));
					response.budgetID 		= exchangeNote.budgetID;
				} else {
					this.errorMessage(" We Couldn't Retrieve the ExchangeNote for This Block, block May not Be Stored on this Instance ");
					return false;
				}
			}

			if( this.newBlock && this.newBlock.blockID == response.blockID && this.details && this.details.recipient && this.#transSend.includes(this.details.transType) ){
				this.getData(["repBlockID", "recipient"], [response.blockID, this.details.recipient ], note.noteServer );
			}
			
			//guarding against misconfigured product blocks
			
			if( response.productID && ( ! response.productNote || ! response.productNote.exchangeID ) ){
				this.errorMessage("Can't Store a Product Block without a Product Note.");
				return false;
			} else {
				if( ( response.productID || ( response.transType == "CREATEBUDGET" && response.agreement && response.agreement.budgetType && response.agreement.budgetType == "business" ) ) && response.agreement && response.agreement.stockID ){
					let noteID 				= response.agreement.stockID;
					if( ! this.l[noteID + "ExchangeNoteTime"] || ( this.l[noteID + "ExchangeNoteTime"] && this.l[noteID + "ExchangeNoteTime"] < response.transTime ) ){					
						let exchangeNote 	= false;
						
						if( this.l[ noteID + "ExchangeNote"] )
							exchangeNote 	= JSON.parse( this.l[ noteID + "ExchangeNote"] );
						
						if( exchangeNote ){
							if( exchangeNote.exchangeID != response.productNote.exchangeID || exchangeNote.budgetID != response.productNote.budgetID || exchangeNote.motherKey != response.productNote.motherKey )
								response.productNote 	= JSON.parse( JSON.stringify( exchangeNote ));
						}
						
						if( ! response.productNote.budgetID && response.budgetID )
							response.productNote.budgetID 	= response.budgetID;
						
						this.l[ noteID + "ExchangeNote" ] = JSON.stringify( response.productNote );
						this.l[ noteID + "ExchangeNoteTime"] = response.transTime;
					}
				}
			}
			
			if( this.encryptRecipient ){
				response.agreement.privateKey = await this.generateKey( 30, true, true );
				let agree = JSON.stringify( response.agreement );
				this.setPublicKey( response.recipient );
				if( response.recipient.length == 171 )
					response.recipient 	= await this.#encrypt( agree );
				
				else 
					response.recipient 	= this.encrypt( agree, this.publicKey );
				
				//await this.createAlert( "recipient: " + response.recipient );
				response.agreements[ response.agreement.agreeID ] = response.agreement;
				delete response.agreement;
			}
			
			if( this.#Reipient ){
				const client  = this.#createClient();
				if(client){
					//this will send the block directly to  the recipient if online at an instant, else the recipient will be notified through other means
					const channel = client.channel(this.#Reipient);
					await channel.subscribe();
					await channel.send({
						type: "broadcast",
						event: "transaction_update",
						payload: { text: JSON.stringify(response) }
				
					})
					await channel.unsubscribe();
				}
				
			}
			
			if( response.exchangeNote && response.noteType &&response.exchangeNote.exchangeID ){
				/* //console.log("Ex Note: " + JSON.stringify( response.exchangeNote ) );
				//console.log("Cur Note: " + JSON.stringify( this.#currentNote ) );
				await this.createAlert( "Saving Exchange Note " + response.noteType ); */
				if( ( ! response.productID || ( response.agreement && response.agreement.budgetType && response.agreement.budgetType != "business" ) ) ){
					if( ! this.l[response.noteType + "ExchangeNoteTime"] || ( this.l[response.noteType + "ExchangeNoteTime"] && this.l[response.noteType + "ExchangeNoteTime"] < response.transTime ) ){					
						let exchangeNote 	= false;
						
						if( this.l[ response.noteType + "ExchangeNote"] )
							exchangeNote 	= JSON.parse( this.l[ response.noteType + "ExchangeNote"] );
						
						if( exchangeNote ){
							if( exchangeNote.exchangeID != response.exchangeNote.exchangeID || exchangeNote.budgetID != response.exchangeNote.budgetID || exchangeNote.motherKey != response.exchangeNote.motherKey )
								response.exchangeNote 	= JSON.parse( JSON.stringify( exchangeNote ));
						}
						
						if( ! response.exchangeNote.budgetID && response.budgetID )
							response.exchangeNote.budgetID 	= response.budgetID;
						
						this.l[ response.noteType + "ExchangeNote" ] = JSON.stringify( response.exchangeNote );
						this.l[ response.noteType + "ExchangeNoteTime"] = response.transTime;
					}
				}
			}
			
			if( note && note.noteAddress && ( note.blockID == response.blockID || this.#setNoteBlocks ) ){
				
				if( note.blockID == response.blockID )
					this.l[ note.noteAddress + "_current_block" ] = JSON.stringify( response );
				
				let dir 				= await window.navigator.storage.getDirectory("scriptStorage", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
				if( ! dir ){
					this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
					return false;
				}
				
				let userDirectory 		= await dir.getDirectoryHandle(note.noteAddress, {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					
				let file 				= await userDirectory.getFileHandle( response.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
				if( this.s.currentNote ){
					let sesNote 				= JSON.parse( this.s.currentNote );
					let noteFile 				= await userDirectory.getFileHandle( sesNote.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_") + "_note", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					let write 				= await file.createWritable();
					await write.write( JSON.stringify( response ) );
					await write.close();
					write 				= await noteFile.createWritable();
					await write.write( JSON.stringify( this.s.currentNote ) );
					await write.close();
				}
				
			}


			return await this.savePersistently( response ).then ( async saved =>{
				if( ! this.#noVerify )
					return await this.verifyData( response );
				
				return saved;
			});
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			try {
				return await this.savePersistently( response ).then ( async saved =>{
						
					if( ! this.#noVerify )
						return await this.verifyData( response );
					
					return saved;
				});
			} catch(e){
				console.error(e);
				try {
					if( response && response.blockID ){
						this.l[ response.blockID ] = JSON.stringify( response );
						if( ! this.#noVerify )
							return await this.verifyData( response );
						
						return true;
					}
				} catch(e){
					console.error(e);
					return false;
				}
			}
			
		}
	
	}
	
	static async storeUserBlock( response ){
		
		if( ! this.#note )
			this.#note 	= await this.#getCurrentNote();
		
		if( ! this.#note || ! response || ! response.blockID ) return false;
		
		let dir 				= await window.navigator.storage.getDirectory("scriptStorage", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
		if( ! dir ){
			this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
			return false;
		}
		
		let userDirectory 		= await dir.getDirectoryHandle(this.#note.noteAddress, {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			
		let file 				= await userDirectory.getFileHandle( response.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		let sesNote 				= JSON.parse( this.s.currentNote );
		let noteFile 				= await userDirectory.getFileHandle( sesNote.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_") + "_note", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		let write 				= await file.createWritable();
		await write.write( JSON.stringify( response ) );
		await write.close();
		write 				= await noteFile.createWritable();
		await write.write( JSON.stringify( this.s.currentNote ) );
		await write.close();
		
		let nextBlock = await this.resolvePersistentData( response.nextBlockID );
		
		if( nextBlock && nextBlock.blockID ){
			//console.log("gotten next block: ", nextBlock.blockID );
			noteFile 				= await userDirectory.getFileHandle( nextBlock.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_") + "_note", {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			
			if( noteFile ){
				//console.log("note file found: ", nextBlock.blockID );
				file 		= await noteFile.getFile();
				sesNote 	= await file.text();
				
				if( sesNote && this.isJsonable( sesNote ) ){
					//console.log("jsonable note file: ", sesNote );
					let note = JSON.parse( this.s.currentNote );
					if( note.blockID == response.blockID )
						this.s.currentNote = sesNote;
				}
			}
			return await this.storeUserBlock( nextBlock );
		}
		
		return true;
	}
	static async saveFile(write, data, compare, type = 'transaction'){
		
		try {
			
			switch( type ){
				case 'transaction' :
					if( ! data || ! data.blockID ) return false;
					
					if( data.blockID != compare.blockID || data.noteValue != compare.noteValue || data.transValue != compare.transValue || data.transTime != compare.transTime ) return false;

				break;
				case 'budget' :
					if( ! data || data.budgetID ) return false;
					
					if( data.transTime <= compare.transTime ) return false;
					
				break;	
			}
			
			await write.write( JSON.stringify( data ) );
			await write.close();
			return true;
		} catch(e){
			console.error(e);
			return false;
		}
	}
	
	static async savePersistently( response = false, directory = false, handle = false){
		if( ! this.response && ! directory && ! handle && ! response ) return false;
		
		if( ! response )
			response = JSON.parse( JSON.stringify( this.response ));
		
		try {
			let main 		= await window.navigator.storage.getDirectory("scriptStorage", {create:true}).catch(error =>{this.errorMessage(error.toString()); return false;});
			if( directory && handle ){
				
				if( ! main ){
					this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
					return false;
				}
				
				let data 			= typeof response == "object" ? JSON.stringify( response ) : response;
				directory 		= await main.getDirectoryHandle(directory, {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
				if( directory ){
					let file 			= await directory.getFileHandle( handle.replaceAll(/[^A-Za-z0-9]/g, "_") + ".txt",{create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
					if( file ){
						let write 			= await file.createWritable();
						await write.write( data );
						await write.close();
						//getting data from the temp file.
						file 	= await directory.getFileHandle( "tempfile.txt",{create: true}).catch(error =>{this.errorMessage( error.toString() ); return false;});
						
						if( file ){
							let textFile = await file.getFile();
							let text 	= await textFile.text();
							let datas 	= text.split('\n');
							for( let x = 0; x < datas.length; x++ ){
								data 	= datas[x];
								
								if( Scriptbill.isJsonable( data ) ){
									response 	= JSON.parse( data );
									
									if( response.blockID ){
										let filey = await directory.getFileHandle( response.blockID.replaceAll(/[^A-Za-z0-9]/g, "_") + ".txt",{create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
										
										if( ! filey ) continue;
										
										write 			= await filey.createWritable();
										await write.write( data );
										await write.close();
										datas.splice(x,1);
									}
								}
							}
							data 			= datas.join('\n');
							write 			= await file.createWritable();
							await write.write( data );
							await write.close();
						}
						return true;
					} else {
						this.errorMessage("couldn't save this data " + response.blockID + " saving in temp file instead");
						file 	= await directory.getFileHandle( "tempfile.txt",{create: true}).catch(error =>{this.errorMessage( error.toString());  return false;});
						Scriptbill.l[response.blockID] = JSON.stringify( response );//athens georgia
						
						if( ! file ) return false;
						
						let text 			= await file.text();
						text 				+= '\n' + data;
						let write 			= await file.createWritable();
						await write.write( text );
						await write.close();
						return true;
					}
				}
				return directory;
			}
			
			if( ! response.blockID || ! response.transType || ! response.exchangeNote || ! response.budgetID ) return false;
			
			
			if( ! main ){
				this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
				return false;
			}
			
			let transactions 	= await main.getDirectoryHandle("transactions", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let exchanges 	 	= await main.getDirectoryHandle("exchanges", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let products	 	= await main.getDirectoryHandle("products", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let budgets		 	= await main.getDirectoryHandle("budgets", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let agreements	 	= await main.getDirectoryHandle("agreements", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let adverts	 		= await main.getDirectoryHandle("adverts", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			
			let transMap 		= await transactions.getFileHandle("transactionsMap.txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let exchangeMap		= await exchanges.getFileHandle("exchangesMap.txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let prodMap 		= await products.getFileHandle("productsMap.txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let budgetMap 		= await budgets.getFileHandle("budgetsMap.txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let agreeMap 		= await agreements.getFileHandle("agreementsMap.txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let adsMap 			= await adverts.getFileHandle("advertsMap.txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let transText 		= await transMap.getFile().then( file =>{ return file.text() });
			let exchangeText	= await exchangeMap.getFile().then( file =>{ return file.text() });
			let prodText 		= await prodMap.getFile().then( file =>{ return file.text() });
			let budgetText 		= await budgetMap.getFile().then( file =>{ return file.text() });
			let agreeText 		= await agreeMap.getFile().then( file =>{ return file.text() });
			let adsText 		= await adsMap.getFile().then( file =>{ return file.text() });		
			let key, transObj, adsObj, exObj, prodObj, budObj, agreeObj, budKey, agreeKey, length = 0, update = false, indexKey = -1, lastIndex = [];
			//parsing the trans map text.
			if( this.isJsonable( transText ) ){
				transObj 		= JSON.parse( transText );
			}
			else {
				transObj 		= {};
			}
			
			//parsing the ads map text.
			if( this.isJsonable( adsText ) ){
				adsObj 		= JSON.parse( adsText );
			}
			else {
				adsObj 		= {};
			}
			
			//parsing the exchange map text.
			if( this.isJsonable( exchangeText ) ){
				exObj 		= JSON.parse( exchangeText );
			}
			else {
				exObj 		= {};
			}
			
			//parsing the prod map text.
			if( this.isJsonable( prodText ) ){
				prodObj 		= JSON.parse( prodText );
			}
			else {
				prodObj 		= {};
			}
			
			//parsing the budget map text.
			if( this.isJsonable( budgetText ) ){
				budObj 		= JSON.parse( budgetText );
			}
			else {
				budObj 		= {};
			}
			
			//parsing the prod map text.
			if( this.isJsonable( agreeText ) ){
				agreeObj 		= JSON.parse( agreeText );
			}
			else {
				agreeObj 		= {};
			}
			
			let budget, write, saveFile;
			if( transObj.blockID && typeof transObj.blockID == "object" && transObj.blockID.includes( response.blockID ) ){
				update 		= true;
				lastIndex[ lastIndex.length ] = indexKey;
				indexKey 	= transObj.blockID.indexOf( response.blockID );
			} else {
				lastIndex[ lastIndex.length ] = indexKey;
			}
			
			for( key in response ){
				if( response[ key ] ){
					if( key == 'agreement' ){						
						//this shows that the agreement is a budget
						if( typeof response[ key ] == "string" && this.isJsonable( response[ key ] ) ){
							budget 		= JSON.parse( response[ key ] );								
						} else if( typeof response[ key ] == "object" ) {
							budget 			= JSON.parse( JSON.stringify( response[ key ] ));
						}
						if( this.#budgetTrans.includes( response.transType ) || response.noteType.includes("STK") || response.noteType.includes("BND") ){							
							if( typeof budget == "object" && budget.budgetID ){	
								//looping the budget
								length 			= 0;
								
								if( ! budObj.budgetID )
									budObj.budgetID		= [];
								
								length 			= budObj.budgetID.length;
								lastIndex[ lastIndex.length ]		= indexKey;
								indexKey 		= budObj.budgetID.indexOf( budget.budgetID );
								
								if( indexKey >= 0 )
									update 			= true;
								
								else 
									update 			= false;
															
																
								for( budKey in budget ){							
									if( budObj[ budKey ] && typeof budObj[ budKey ] == 'object' ){
										if( budKey == "agreement" && typeof budget[ budKey ] == 'object' && budget[ budKey ].agreeID ){
											length = 0;							
											if( ! agreeObj.agreeID  )
												agreeObj.agreeID	= [];
											
											length 		= agreeObj.agreeID.length;
											lastIndex[ lastIndex.length ]		= indexKey;
											indexKey 		= agreeObj.agreeID.indexOf( budget[ budKey ].agreeID );
											
											if( indexKey >= 0 )
												update 			= true;
											
											else 
												update 			= false;
											
											for( agreeKey in budget[ budKey ] ){
												if( agreeObj[ agreeKey ] && typeof agreeObj[ agreeKey ] == 'object' ){
													for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
														agreeObj[ agreeKey ].push( "" );
													}
													
													if( agreeObj[ agreeKey ].length > length ){
														agreeObj[ agreeKey ].splice(length, ( agreeObj[ agreeKey ].length - length ) );
													}
													if( ! update )
														agreeObj[ agreeKey ][length] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
													else 
														agreeObj[ agreeKey ][indexKey] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
												} else {
													agreeObj[ agreeKey ] = [];
													for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
														agreeObj[ agreeKey ].push( "" );
													}
													if( ! update )
														agreeObj[ agreeKey ][length] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
													else 
														agreeObj[ agreeKey ][indexKey] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
												}
											}
											length = 0;							
											if( budObj.budgetID && budObj.budgetID.length )
												length 		= budObj.budgetID.length;
											//saving the mappings
											agreeText 		= JSON.stringify( agreeObj );
											write 		= await agreeMap.createWritable();
											await write.write( agreeText );
											await write.close();
											//saving the agreement.
											saveFile = await agreements.getFileHandle( budget[ budKey ].agreeID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true});
											saveFile.createWritable().then( async write =>{
												await write.write( JSON.stringify( budget[ budKey ] ) );
												await write.close();
											});
											lastIndex.pop();
											indexKey 	= lastIndex[ lastIndex.length - 1 ];
											
											if( indexKey >= 0 )
												update 	= true;
											else
												update 	= false;
											
											for( let len = budObj[ budKey ].length; len < length; len++ ){
												budObj[ budKey ].push( "" );
											}
											budObj[ budKey ].splice( length, budObj[ budKey ].length - length );
											
											if( ! update )
												budObj[ budKey ].push( budget[ budKey ].agreeID );
											else 
												budObj[ budKey ][ indexKey ] = budget[ budKey ].agreeID;
										} else {
											for( let len = budObj[ budKey ].length; len < length; len++ ){
												budObj[ budKey ].push( "" );
											}
											budObj[ budKey ].splice( length, budObj[ budKey ].length - length );
											
											if( ! update )
												budObj[ budKey ].push( budget[ budKey ] ? budget[ budKey ] : ""  );
											else 
												budObj[ budKey ][ indexKey ] = budget[ budKey ] ? budget[ budKey ] : "" ;
										}
										
									} else {
										budObj[ budKey ] = [];
										for( let len = budObj[ budKey ].length; len < length; len++ ){
											budObj[ budKey ].push( "" );
										}
										budObj[ budKey ].splice( length, budObj[ budKey ].length - length );
										if( ! update )
											budObj[ budKey ].push( budget[ budKey ] ? budget[ budKey ] : ""  );
										else 
											budObj[ budKey ][ indexKey ] = budget[ budKey ] ? budget[ budKey ] : "" ;
									}
								}
								//saving the mapping
								budgetText		= JSON.stringify( budObj );
								write 		= await budgetMap.createWritable();
								await write.write( budgetText );
								await write.close();
								//saving the budget
								saveFile = await budgets.getFileHandle( budget.budgetID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
								//Possibility of getting the content of the file for 
								//review before saving the file.
								let saveText 	= await saveFile.getFile().then( file =>{ return file.text() });
								if( saveText && this.isJsonable( saveText ) )
									saveText 	= JSON.parse( saveText );
								saveFile.createWritable().then( async write =>{
									//this intended function will replace the 
									//normal scriptbill way of saving files. this will
									//have to check the file for consistency.
									//this.saveFile( write, budget, saveText, 'budget' )
									await write.write( JSON.stringify( budget ) );
									await write.close();
								});
								
								lastIndex.pop();
								indexKey 	= lastIndex[ lastIndex.length - 1 ];
								
								if( indexKey >= 0 )
									update 	= true;
								else
									update 	= false;
					
								length = 0;							
								if( transObj.blockID && transObj.blockID.length )
									length 		= transObj.blockID.length;			
														
								if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
									for( let len = transObj[ key ].length; len < length; len++ ){
										transObj[ key ].push( "" );
									}
									transObj[ key ].splice( length, transObj[ key ].length - length );
									if( ! update )
										transObj[ key ].push( budget.budgetID );
									else 
										transObj[ key ][ indexKey ] = budget.budgetID;
								} else {
									transObj[ key ] = [];
									for( let len = transObj[ key ].length; len < length; len++ ){
										transObj[ key ].push( "" );
									}
									transObj[ key ].splice( length, transObj[ key ].length - length );
									if( ! update )
										transObj[ key ].push( budget.budgetID );
									else 
										transObj[ key ][ indexKey ] = budget.budgetID;
								}
							}
							//this shows that the agreement is an advert
						} else if( response.transType == "ADVERT" ){							
							
							if( typeof budget == "object" && budget.advertID ){
								//looping the budget
								length 			= 0;
								
								if( ! adsObj.advertID  )
									adsObj.advertID 	= [];
								
								length 			= adsObj.advertID.length;
								lastIndex[ lastIndex.length ]		= indexKey;
								indexKey 		= adsObj.advertID.indexOf( budget.advertID );
								
								if( indexKey >= 0 )
									update 			= true;
								
								else 
									update 			= false;
								
								
								for( budKey in budget ){
									if( adsObj[ budKey ] && typeof adsObj[ budKey ] == 'object' ){
										if( budKey == "agreement" && typeof budget[ budKey ] == 'object' && budget[ budKey ].agreeID ){							
											if( ! agreeObj.agreeID )
												agreeObj.agreeID = [];
											
											length 		= agreeObj.agreeID.length;
											lastIndex[ lastIndex.length ]		= indexKey;
											indexKey 		= agreeObj.agreeID.indexOf( budget[ budKey ].agreeID );
											
											if( indexKey >= 0 )
												update 			= true;
											
											else 
												update 			= false;
											
											for( agreeKey in budget[ budKey ] ){
												if( agreeObj[ agreeKey ] && typeof agreeObj[ agreeKey ] == 'object' ){
													for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
														agreeObj[ agreeKey ].push( "" );
													}
													
													if( agreeObj[ agreeKey ].length > length ){
														agreeObj[ agreeKey ].splice(length, ( agreeObj[ agreeKey ].length - length ) );
													}
													
													if( ! update )
														agreeObj[ agreeKey ][length] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
													else 
														agreeObj[ agreeKey ][indexKey] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
												} else {
													agreeObj[ agreeKey ] = [];
													for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
														agreeObj[ agreeKey ].push( "" );
													}
													if( ! update )
														agreeObj[ agreeKey ][length] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
													else 
														agreeObj[ agreeKey ][indexKey] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
												}
											}										
											length = 0;							
											if( adsObj.advertID && adsObj.advertID.length )
												length 		= adsObj.advertID.length;
											
											lastIndex.pop();
											indexKey 	= lastIndex[ lastIndex.length - 1 ];
											
											if( indexKey >= 0 )
												update 	= true;
											else
												update 	= false;
											
											//saving the maping
											agreeText 		= JSON.stringify( agreeObj );
											write 		= await agreeMap.createWritable();
											await write.write( agreeText );
											await write.close();
											//saving the agreement
											
											saveFile = await agreements.getFileHandle( budget[ budKey ].agreeID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true});
											saveFile.createWritable().then( async write =>{
												await write.write( JSON.stringify( budget[ budKey ] ) );
												await write.close();
											});
											
											for( let len = adsObj[ budKey ].length; len < length; len++ ){
												adsObj[ budKey ].push( "" );
											}
											adsObj[ budKey ].splice( length, adsObj[ budKey ].length - length );
											
											if( ! update )
												adsObj[budKey].push( budget[ budKey ].agreeID );
											else 
												adsObj[budKey][indexKey] = budget[ budKey ].agreeID; 
											
										} else {
											for( let len = adsObj[ budKey ].length; len < length; len++ ){
												adsObj[ budKey ].push( "" );
											}
											adsObj[ budKey ].splice( length, adsObj[ budKey ].length - length );
											
											if( ! update )
												adsObj[budKey].push( budget[ budKey ].agreeID );
											else 
												adsObj[budKey][indexKey] = budget[ budKey ].agreeID; 
											
										}
										
									} else {
										adsObj[ budKey ] = [];
										for( let len = adsObj[ budKey ].length; len < length; len++ ){
											adsObj[ budKey ].push( "" );
										}
										adsObj[ budKey ].splice( length, adsObj[ budKey ].length - length );
										
										if( ! update )
											adsObj[budKey].push( budget[ budKey ].agreeID );
										else 
											adsObj[budKey][indexKey] = budget[ budKey ].agreeID; 
									}
								}
								//saving the mapping
								adsText			= JSON.stringify( adsObj );
								write 		= await adsMap.createWritable();
								await write.write( adsText );
								await write.close();
								//saving the adverts.
								
								saveFile = await adverts.getFileHandle( budget.advertID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true});
								saveFile.createWritable().then( async write =>{
									await write.write( JSON.stringify( budget ) );
									await write.close();
								});
								
								lastIndex.pop();
								indexKey 	= lastIndex[ lastIndex.length - 1 ];
								
								if( indexKey >= 0 )
									update 	= true;
								else
									update 	= false;
								
								length = 0;							
								if( transObj.blockID && transObj.blockID.length )
									length 		= transObj.blockID.length;			
														
								if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
									for( let len = transObj[ key ].length; len < length; len++ ){
										transObj[ key ].push( "" );
									}
									transObj[ key ].splice( length, transObj[ key ].length - length );
									
									if( ! update )
										transObj[ key ].push( budget.advertID );
									else 
										transObj[ key ][ indexKey ] = budget.advertID;
								} else {
									transObj[ key ] = [];
									for( let len = transObj[ key ].length; len < length; len++ ){
										transObj[ key ].push( "" );
									}
									transObj[ key ].splice( length, transObj[ key ].length - length );
									
									if( ! update )
										transObj[ key ].push( budget.advertID );
									else 
										transObj[ key ][ indexKey ] = budget.advertID;
								}
							}
						}
						//this shows that the agreement is a product agreement.
						else if( response.transType == "CREATEPRODUCT" || response.transType == "UPDATEPRODUCT" ){					
							
							if( typeof budget == "object" && budget.productID ){
								response[ key ] 	= budget.productID;
								
								if( ! prodObj.productID )
									prodObj.productID = [];
								
								length 			= prodObj.productID.length;
								lastIndex[ lastIndex.length ]		= indexKey;
								indexKey 		= prodObj.productID.indexOf( budget.productID );
								
								if( indexKey >= 0 )
									update 			= true;
								
								else 
									update 			= false;
								
								for( budKey in budget ){
									if( prodObj[ budKey ] && typeof prodObj[ budKey ] == 'object' ){
										if( budKey == "agreement" && typeof budget[ budKey ] == 'object' && budget[ budKey ].agreeID ){
											
											if( ! agreeObj.agreeID  )
												agreeObj.agreeID = [];
												
											length 		= agreeObj.agreeID.length;
											lastIndex[ lastIndex.length ]		= indexKey;
											indexKey 		= agreeObj.agreeID.indexOf( budget[ budKey ].agreeID );
											
											if( indexKey >= 0 )
												update 			= true;
											
											else 
												update 			= false;
											
											for( agreeKey in budget[ budKey ] ){
												if( agreeObj[ agreeKey ] && typeof agreeObj[ agreeKey ] == 'object' ){
													for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
														agreeObj[ agreeKey ].push( "" );
													}
													
													if( agreeObj[ agreeKey ].length > length ){
														agreeObj[ agreeKey ].splice(length, ( agreeObj[ agreeKey ].length - length ) );
													}
													
													if( ! update )
														agreeObj[ agreeKey ][length] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
													else 
														agreeObj[ agreeKey ][indexKey] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
												} else {
													agreeObj[ agreeKey ] = [];
													for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
														agreeObj[ agreeKey ].push( "" );
													}
													if( ! update )
														agreeObj[ agreeKey ][length] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
													else 
														agreeObj[ agreeKey ][indexKey] = budget[ budKey ][ agreeKey ] ? budget[ budKey ][ agreeKey ] : "";
												}
											}
											
											length = 0;							
											if( prodObj.productID && prodObj.productID.length )
												length 		= prodObj.productID.length;
															//saving the mapping 
											agreeText 		= JSON.stringify( agreeObj );
											write 		= await agreeMap.createWritable();
											await write.write( agreeText );
											await write.close();
											//saving the agreement
											
											saveFile = await agreements.getFileHandle( budget[ budKey ].agreeID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true});
											saveFile.createWritable().then( async write =>{
												await write.write( JSON.stringify( budget[ budKey ] ) );
												await write.close();
											});
											lastIndex.pop();
											indexKey 	= lastIndex[ lastIndex.length - 1 ];
											
											if( indexKey >= 0 )
												update 	= true;
											else
												update 	= false;
											
											for( let len = prodObj[ budKey ].length; len < length; len++ ){
												prodObj[ budKey ].push( "" );
											}
											prodObj[ budKey ].splice( length, prodObj[ budKey ].length - length );
											
											if( ! update )
												prodObj[budKey].push( budget[ budKey ].agreeID );
											else 
												prodObj[budKey][indexKey] = budget[ budKey ].agreeID;
										} else {
											for( let len = prodObj[ budKey ].length; len < length; len++ ){
												prodObj[ budKey ].push( "" );
											}
											prodObj[ budKey ].splice( length, prodObj[ budKey ].length - length );
											
											if( ! update )
												prodObj[budKey].push( budget[ budKey ].agreeID );
											else 
												prodObj[budKey][indexKey] = budget[ budKey ].agreeID;
										}
									} else {
										prodObj[ budKey ] = [];
										for( let len = prodObj[ budKey ].length; len < length; len++ ){
											prodObj[ budKey ].push( "" );
										}
										prodObj[ budKey ].splice( length, prodObj[ budKey ].length - length );
										
										if( ! update )
											prodObj[budKey].push( budget[ budKey ].agreeID );
										else 
											prodObj[budKey][indexKey] = budget[ budKey ].agreeID;
									}
								}
								//saving the mapping
								prodText			= JSON.stringify( prodObj );
								write 				= await productMap.createWritable();
								await write.write( prodText );
								await write.close();
								//saving the products
								
								saveFile = await products.getFileHandle( budget.productID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
								saveFile.createWritable().then( async write =>{
									await write.write( JSON.stringify( budget ) );
									await write.close();
								});
								
								lastIndex.pop();
								indexKey 	= lastIndex[ lastIndex.length - 1 ];
								
								if( indexKey >= 0 )
									update 	= true;
								else
									update 	= false;
								
								length = 0;							
								if( transObj.blockID && transObj.blockID.length )
									length 		= transObj.blockID.length;			
														
								if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
									for( let len = transObj[ key ].length; len < length; len++ ){
										transObj[ key ].push( "" );
									}
									transObj[ key ].splice( length, transObj[ key ].length - length );
									
									if( ! update )
										transObj[ key ].push( budget.productID );
									else 
										transObj[ key ][ indexKey ] = budget.productID;
								} else {
									transObj[ key ] = [];
									for( let len = transObj[ key ].length; len < length; len++ ){
										transObj[ key ].push( "" );
									}
									transObj[ key ].splice( length, transObj[ key ].length - length );
									
									if( ! update )
										transObj[ key ].push( budget.productID );
									else 
										transObj[ key ][ indexKey ] = budget.productID;
								}
							}
						}
						//ordinary agreement to be saved as one.
						else if( typeof budget == "object" && budget.agreeID ){
														
							if( ! agreeObj.agreeID )
								agreeObj.agreeID 	= [];
							
							length 		= agreeObj.agreeID.length;
							lastIndex[ lastIndex.length ]		= indexKey;
							indexKey 		= agreeObj.agreeID.indexOf( budget.agreeID );
							
							if( indexKey >= 0 )
								update 			= true;
							
							else 
								update 			= false;
							
							for( agreeKey in budget ){
								if( agreeObj[ agreeKey ] && typeof agreeObj[ agreeKey ] == 'object' ){
									for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
										agreeObj[ agreeKey ].push( "" );
									}
									
									if( agreeObj[ agreeKey ].length > length ){
										agreeObj[ agreeKey ].splice(length, ( agreeObj[ agreeKey ].length - length ) );
									}
									
									if( ! update )
										agreeObj[ agreeKey ][length] = budget[ agreeKey ] ? budget[ agreeKey ] : "";
									else 
										agreeObj[ agreeKey ][indexKey] = budget[ agreeKey ] ? budget[ agreeKey ] : "";
								} else {
									agreeObj[ agreeKey ] = [];
									for( let len = agreeObj[ agreeKey ].length; len < length; len++ ){
										agreeObj[ agreeKey ].push( "" );
									}
									if( ! update )
										agreeObj[ agreeKey ][length] = budget[ agreeKey ] ? budget[ agreeKey ] : "";
									else 
										agreeObj[ agreeKey ][indexKey] = budget[ agreeKey ] ? budget[ agreeKey ] : "";
								}
							}
							//saving the mapping
							agreeText 		= JSON.stringify( agreeObj );
							write 			= await agreeMap.createWritable();
							await write.write( agreeText );
							await write.close();
							//saving the agreement
							
							saveFile = await agreements.getFileHandle( budget.agreeID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true} );
							saveFile.createWritable().then( async write =>{
								await write.write( JSON.stringify( budget ) );
								await write.close();
							});
							
							/* if( typeof budget == "object" && budget.agreeID ){
								response[ key ] = budget.agreeID;
							} */
							length = 0;							
							if( transObj.blockID && transObj.blockID.length )
								length 		= transObj.blockID.length;
							
							lastIndex.pop();
							indexKey 	= lastIndex[ lastIndex.length - 1 ];
							
							if( indexKey >= 0 )
								update 	= true;
							else
								update 	= false;
							
													
							if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
								for( let len = transObj[ key ].length; len < length; len++ ){
									transObj[ key ].push( "" );
								}
								transObj[ key ].splice( length, transObj[ key ].length - length );
								
								if( ! update )
									transObj[ key ].push( budget.agreeID );
								else 
									transObj[ key ][indexKey] =  budget.agreeID;
							} else {
								transObj[ key ] = [];
								for( let len = transObj[ key ].length; len < length; len++ ){
									transObj[ key ].push( "" );
								}
								transObj[ key ].splice( length, transObj[ key ].length - length );
								
								if( ! update )
									transObj[ key ].push( budget.agreeID );
								else 
									transObj[ key ][indexKey] =  budget.agreeID;
							}
						}					
						
					} else if( key == "exchangeNote" || key == "productNote" ){
						
						if( typeof response[ key ] == "object" ){
							budget 		= response[ key ];
						}
						else if( typeof response[ key ] == "string" && this.isJsonable( response[ key ] ) ){
							budget 		= JSON.parse( response[ key ] );
						}
						
						if( typeof budget == "object" && budget.exchangeID ){
							
							length = 0;							
							if( ! exObj.exchangeID  )
								exObj.exchangeID 	= [];
							
							length 		= exObj.exchangeID.length;
							lastIndex[ lastIndex.length ]		= indexKey;
							indexKey 		= exObj.exchangeID.indexOf( budget.exchangeID );
							
							if( indexKey >= 0 )
								update 			= true;
							
							else 
								update 			= false;
						
							for( budKey in budget ){
								if( exObj[ budKey ] && typeof exObj[ budKey ] == 'object' ){
									for( let len = exObj[ budKey ].length; len < length; len++ ){
										exObj[ budKey ].push( "" );
									}
									exObj[ budKey ].splice( length, exObj[ budKey ].length - length );
									
									if( ! update )
										exObj[ budKey ].push( budget[ budKey ] ? budget[ budKey ] : "" );
									else 
										exObj[ budKey ][indexKey] =  budget[ budKey ] ? budget[ budKey ] : "";
								} else {
									exObj[ budKey ] = [];
									for( let len = exObj[ budKey ].length; len < length; len++ ){
										exObj[ budKey ].push( "" );
									}
									exObj[ budKey ].splice( length, exObj[ budKey ].length - length );
									
									if( ! update )
										exObj[ budKey ].push( budget[ budKey ] ? budget[ budKey ] : "" );
									else 
										exObj[ budKey ][indexKey] =  budget[ budKey ] ? budget[ budKey ] : "";
								}
							}
							exchangeText 		= JSON.stringify( exObj );
							write 			= await agreeMap.createWritable();
							await write.write( exchangeText );
							await write.close();
							
							saveFile = await exchanges.getFileHandle( budget.exchangeID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
							saveFile.createWritable().then( async write =>{
								await write.write( JSON.stringify( budget ) );
								await write.close();
							});
						}
						length = 0;							
						if( transObj.blockID && transObj.blockID.length )
							length 		= transObj.blockID.length;
						
						lastIndex.pop();
						indexKey 	= lastIndex[ lastIndex.length - 1 ];
						
						if( indexKey >= 0 )
							update 	= true;
						else
							update 	= false;
						
												
						if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
							for( let len = transObj[ key ].length; len < length; len++ ){
								transObj[ key ].push( "" );
							}
							transObj[ key ].splice( length, transObj[ key ].length - length );
							
							if( ! update )
								transObj[ key ].push( budget.exchangeID );
							
							else 
								transObj[ key ][indexKey] =  budget.exchangeID;
						} else {
							transObj[ key ] = [];
							for( let len = transObj[ key ].length; len < length; len++ ){
								transObj[ key ].push( "" );
							}
							transObj[ key ].splice( length, transObj[ key ].length - length );
							
							if( ! update )
								transObj[ key ].push( budget.exchangeID );
							
							else 
								transObj[ key ][indexKey] =  budget.exchangeID;
						}
					} else {
						length = 0;							
						if( transObj.blockID && transObj.blockID.length )
							length 		= transObj.blockID.length;
						
												
						if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
							for( let len = transObj[ key ].length; len < length; len++ ){
								transObj[ key ].push( "" );
							}
							transObj[ key ].splice( length, transObj[ key ].length - length );
							
							if( ! update )
								transObj[ key ].push( response[ key ] ? response[ key ] : "" );
							else 
								transObj[ key ][indexKey] =  response[ key ] ? response[ key ] : "" ;
						} else {
							transObj[ key ] = [];
							for( let len = transObj[ key ].length; len < length; len++ ){
								transObj[ key ].push( "" );
							}
							transObj[ key ].splice( length, transObj[ key ].length - length );
							
							if( ! update )
								transObj[ key ].push( response[ key ] ? response[ key ] : "" );
							else 
								transObj[ key ][indexKey] =  response[ key ] ? response[ key ] : "" ;
						}
					}
					
					//console.log( "key saved: ", key, "value: ", response[ key ], "index to be saved: ", indexKey );
					
				} else {
					length = 0;							
					if( transObj.blockID && transObj.blockID.length )
						length 		= transObj.blockID.length;
					
											
					if( transObj[ key ] && typeof transObj[ key ] == 'object' ){
						for( let len = transObj[ key ].length; len < length; len++ ){
							transObj[ key ].push( "" );
						}
						transObj[ key ].splice( length, transObj[ key ].length - length );
						
						if( ! update )
							transObj[ key ].push( "" );
						else 
							transObj[ key ][indexKey] =  "";
					} else {
						transObj[ key ] = [];
						for( let len = transObj[ key ].length; len < length; len++ ){
							transObj[ key ].push( "" );
						}
						transObj[ key ].splice( length, transObj[ key ].length - length );
						
						if( ! update )
							transObj[ key ].push( "" );
						else 
							transObj[ key ][indexKey] =  "";
					}					
				}				
			}
			//console.log( "Checking block ref ", transObj.blockRef.includes( response.blockRef ), "Index: ", transObj.blockRef.indexOf( response.blockRef ) );
			transText 			= JSON.stringify( transObj );
			write 				= await transMap.createWritable();
			await write.write( transText );
			await write.close();
			
			saveFile = await transactions.getFileHandle( response.blockID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			saveFile.createWritable().then( async write =>{
				await write.write( JSON.stringify( response ) );
				await write.close();
			});
			return true;
		} catch(e) {
			//console.log("Couldn't Save Data Persistently", e);
			return false;
		}
	}
	
	static async deletePersistentData( dataID, directory = "transactions" ){
		try {
			let main 		= await window.navigator.storage.getDirectory("scriptStorage", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			
			if( ! main ){
				this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
				return false;
			}
			
			let access 		= await main.getDirectoryHandle(directory, {create: false}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			
			let map 		= await access.getFileHandle( directory + "Map.txt", {create:true} ).catch(error =>{this.errorMessage( error.toString() );  return false;});
			let data 		= await access.getFileHandle( dataID + ".txt", {create:false} ).catch(error =>{this.errorMessage( error.toString() );  return false;});
			//.replaceAll( /[^a-zA-Z0-9]/g, "_" )
			if( ! data && dataID ){
				data 		= await access.getFileHandle( dataID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:false} ).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
				if( ! data ){
					this.errorMessage("This data is not found on this storage " + dataID );
					return true;
				}
			}
			
			let file 		= await data.getFile();
			let text 		= await file.text();
			
			if( text && text.length && this.isJsonable( text ) ){
				let mapFile = await map.getFile();
				let mapText = await mapFile.text();
				let obj 	= JSON.parse( text );
				
				if( this.isJsonable( mapText ) ){
					let mapObj 		= JSON.parse( mapText );
					let index 		= mapObj['blockID'].indexOf( obj.blockID );
					for( let id in mapObj ){
						mapObj[id].splice( index );
					}
					
					let write 	= await map.createWritable();
					await write.write( JSON.stringify( mapObj ) );
					await write.close();
				}
			}
			
			await data.remove();
			//await main.close();
			return data;
			
		} catch(e){
			console.error( e );
			this.errorMessage(e.toString());
			return false;
		}
	}
	
	/*
		@returns data in persistent storage in string format.
	*/
	
	/* static async getNoteStatic(){
		if( ! this.s.currentNote ) return false;
		
		this.#note = await this.#getCurrentNote();
		
		return this.#note;
	} */
	
	static async resolvePersistentData( dataID, value = "", directory = "transactions", command = "equals", time = 1000 ){
		return new Promise( async (resolve, reject)=>{
			let data = await this.getDataPersistently( dataID, value, directory, command );
			setTimeout( ()=>{
				resolve( data );
			}, time );
		});
	}
	
	static async resolveRemoteData( key, data, url = "", type = "GET", time = 1000 ){
		return new Promise( async ( resolve, reject )=>{
			let result 	= await this.getData( key, data, url, type );
			
			setTimeout( ()=>{
				resolve( result );
			}, time );
		});
	}
	
	static async getDataPersistently( dataID, value = "", directory = "transactions",  command = "equals" ){
		
		try {
			//console.log("e getting");
			let main 		= await window.navigator.storage.getDirectory("scriptStorage", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
			
			if( ! main ){
				this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
				return false;
			}
			
			let access 		= false;
			
			if( directory )
				access 		= await main.getDirectoryHandle(directory, {create: false}).catch(error =>{this.errorMessage(error.toString() + " " + directory); return false;});
			
			let file 		= false, text 	= "";
			
			var ID 			= "blockID";
			
			if( directory == "exchanges" )
				ID 			= "exchangeID";
			
			else if( directory == "agreements" )
				ID 			= "agreeID";
			
			else if( directory == "budgets" )
				ID 			= "budgetID";
			
			else if( directory == "products" )
				ID 			= "productID";
			
			else if( directory == "adverts" )
				ID 			= "advertID";
			
			else if( ! directory && value ){
				//console.log("getting data");
				access = await main.getDirectoryHandle(value, {create: false}).catch(error =>{this.errorMessage(error.toString() + " " + value);return false;});
				
				if( access ){
					//console.log("accessed " + value );
					let uploads 		= await access.getFileHandle(dataID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});				
					
					if( uploads ){
						//console.log("Gotten the uploads file");
						let data 		= await uploads.getFile().then( file =>{
							return file.text();
						}).catch( error =>{
							//console.log( error, value );
							return false;
						});
						//console.log("returned data ", data );
						return data;
					} else {
						//console.log("Could not get the uploads file");
						return false;
					}
				} else {
					//console.log("Could not access");
					return false;
				}
			}
			
			//console.log( 'access: ' + access );
			if( value && access ){
				//console.log( 'value & access: ' );
				let map 	= await access.getFileHandle( directory + "Map.txt", {create:true} ).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
				
				if( map && dataID != "ALL"){
					//console.log( 'map gotten ' + dataID );
					file 	= await map.getFile();
					text 	= await file.text();
					
					if( text && this.isJsonable( text ) ){
						//console.log( 'text found and is jsonable ' );
						let mappings 	= JSON.parse( text );
						let parentArr 	= mappings[ ID ];
						
						if( ! parentArr ){							
							return false;
						}
						
						if( mappings && mappings[ dataID ] ){
							//console.log( 'ID found ' + dataID);
							let mother 		= mappings[ dataID ];
							if( typeof mother == "string" && this.isJsonable( mother ) )
								mother 		= JSON.parse( mother );
							
							let indexes = [];
							
							//console.log( 'Mother found ' + mother, typeof mother);
							
							let arr		= mother.filter( ( val, index )=>{
								let equals = false;
									if( command == "equals" )
										equals = val == value;
									
									if( command == "greater" )
										equals = val < value;
									
									if( command == "greater-equals" )
										equals = val <= value;
									
									if( command == "lesser" )
										equals = val > value;
									
									if( command == "lesser-equals" )
										equals = val >= value;
									
									if( command == "like" )
										equals = val.toString().includes( value );
									
									if( command == "not-like" )
										equals = ! val.toString().includes( value );
									
									if( equals ){
										indexes.push( index );
									}
									
									return equals;
							});
							//console.log("checking index " + parentArr[mother.indexOf( arr[0] )]);
							let blockID, blockData;
							const checkData = async ( index )=>{					
									
									try {
										//console.log( "index running " + index );
										blockID 	= parentArr[index];
										
										blockData = await access.getFileHandle( blockID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true} ).catch( error =>{ this.errorMessage( error.toString()); return false; });
										
										if( blockData ){
											file 	= await blockData.getFile();
											text 	= await file.text();
											//console.log('retData: ' + text );
											if( text && this.isJsonable( text ) ){
												retData 	= JSON.parse( text );
											} else {
												retData 	= text;
											}
										}
										//console.log('retData: ' + retData );
										return retData;
									} catch( e ){
										//console.log(e);
									}
								}
								//console.log( 'array total found ' + arr.length);
								//console.log( 'indexes total found ' + indexes.length);
							 let mop = [];
							arr 	= indexes.map(  async ( index )=>{				
									
									try {
										let retData;
										blockID 	= parentArr[index];
										
										if( ! blockID ) return;
										
										blockData 	= await access.getFileHandle( blockID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true} ).catch( error =>{ this.errorMessage( error.toString()); return false; });
										
										if( blockData ){
											//console.log( 'block data found ' + blockID);
											file 	= await blockData.getFile();
											//console.log('getting retData... ' );
											text 	= await file.text();
											//console.log('retData: ' + text );
											if( text && this.isJsonable( text ) ){
												retData 	= JSON.parse( text );
											} else {
												retData 	= text;
											}
											//console.log( 'retData data found ' + retData );
										}
										
										if( retData && retData.blockID  ){
											if( retData.exchangeNote && typeof retData.exchangeNote == "string" && ! this.isJsonable( retData.exchangeNote ) ){
												let exchanges 		= await main.getDirectoryHandle('exchanges', {create: false}).catch(error =>{/*//console.log(error, 'exchanges');*/ return false;});
												let exchangeNote 	= await access.getFileHandle( retData.exchangeNote.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true} ).catch( error =>{ this.errorMessage( error.toString()); return false; });
														
												file 		= await exchangeNote.getFile();
												text 		= await file.text();
												
												if( this.isJsonable( text )){
													retData.exchangeNote 	= JSON.parse( text );
												}
											}	
											
											if( retData.agreement && typeof retData.agreement == "string" && ! this.isJsonable( retData.agreement ) ){
												let agreements 		= await main.getDirectoryHandle('agreements', {create: false}).catch(error =>{/*//console.log(error, 'agreements');*/ return false;});
												let agreementData 	= await access.getFileHandle( retData.agreement.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:true} ).catch( error =>{ this.errorMessage( error.toString()); return false; });
												
												file 		= await agreementData.getFile();
												text 		= await file.text();
												
												if( this.isJsonable( text )){
													retData.agreement 	= JSON.parse( text );
												}
											}
										}
										//console.log( 'retData data found ' + retData );
										retData 		= await retData;
										
										if( retData )
											mop.push( retData );
										//console.log('retData: ' + retData );
										return retData;
									} catch( e ){
										//console.log(e);
									}
								}); 
							
							return mop;
								
						} else {
							return false;
						}
					} else {
						return false;
					}
				} else if( dataID == "ALL" ){
					if( value )//value should contain the limit the loop should go
						value = parseInt( value );
					
					if( isNaN( value ))
						value = 10;//as the default limit;
					
					let data = [];
					if( directory == "transaction" ){
						let file, text, blocky, block;
						for await( const val of access.values()){
							//console.log('value: ' + val );
							if( value == 0 ) break;
							try {
								file 		= await val.getFile();
								text 		= await file.text();
								block 		= this.isJsonable( text ) ? JSON.parse( text ) : {};
								
								if(  block.agreement && typeof block.agreement == "string" && ! this.isJsonable( block.agreement ) ){
									if( ( block.transType == "CREATEBUDGET" || block.transType == "UPDATEBUDGET" ) ){
										blocky = await this.resolvePersistentData( block.agreement, "", "budgets" );									
									} else if( block.transType == "CREATEPRODUCT" || block.transType == "BUYPRODUCT" || block.transType == "PRODUCTSUB" ){
										blocky = await this.resolvePersistentData( block.agreement, "", "products" );
									} else if( block.transType == "ADVERT" ){
										blocky = await this.resolvePersistentData( block.agreement, "", "adverts" );
									} else{
										blocky = await this.resolvePersistentData( block.agreement, "", "agreements" );
									} 
									if( blocky && typeof blocky == "object" ){
										block.agreement = JSON.parse( JSON.stringify( blocky ) );
									}
								}
								
								if( block.agreements && typeof block.agreements == "object" && block.agreements.length ){
									let agreeID, x, agrees = [];
									for( x = 0; x < block.agreements.length; x++ ){
										agreeID 	= block.agreements[x];
										
										if( typeof agreeID != "string" ) continue;
										
										blocky = await this.resolvePersistentData( agreeID, "", "agreements" );

										if( blocky && typeof blocky == "object" ){
											agrees.push( blocky );
										}
									}
									
									block.agreements = agrees;
								}
								
								if( block.exchangeNote && typeof block.exchangeNote == "string" && ! this.isJsonable( block.exchangeNote ) ){
									blocky = await this.resolvePersistentData( block.exchangeNote, "", "exchanges" );
									
									block.exchangeNote = JSON.parse( JSON.stringify( blocky ));
								}
								
								if( block && block.blockID && typeof block.blockID == "string" )
									data.push( block );
								/* if( local[ local.length - 1 ] && local[ local.length - 1 ].transTime < block.transTime ) 
									local.push( block );
								
								else {
									for( let x = local.length - 1; x >= 0; x-- ){
										if( local[ x ] && local[ x ].transTime < block.transTime ){
											local.splice( x, 0, block );				
										} else {
											local.push( block );
										}
									}
								} */
								value--;
							} catch( e ){
								//console.log('couldn\'t fetch data error: ', e);
							}
						}
					} else {
						let file, text, blocky, block;
						for await( const val of access.values()){
							if( value == 0 ) break;
							try {
								file 		= await val.getFile();
								text 		= await file.text();
								block 		= this.isJsonable( text ) ? JSON.parse( text ) : {};
								data.push( block );
								value--;
							} catch(e){
								console.error(e);
							}
						}
					}
					return data;
				}/* else if( config && typeof config == "object" ){
					let value, data, arr = [];
					for( dataID in config ){
						 value 		= config[dataID];
						 data 		= await getDataPersistently( dataID, value );
						 arr.push( data );
					}
					
					
				} */ else{
					//console.log( 'map note gotten ' + map );
					return false;
				}
				
			} else if( access && dataID ) {
				
				let data 	= await access.getFileHandle( dataID.replaceAll( /[^a-zA-Z0-9]/g, "_" ) + ".txt", {create:false} ).catch(error =>{this.errorMessage( error.toString() );  return false;});
				
				if( data ){
					file 		= await data.getFile();
					text 		= await file.text();
					
					if( this.isJsonable( text ) ){
						text = JSON.parse( text );
					}
				}
				
				return text;
			} else {
				return false;
			}
			
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
		
		
	}

	static hashed(string = "", algo = ''){
		//console.log("hashed running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "hashed";
		
		let algoKeys = ["A", "D", "E", "H", "M", "P", "R", "R2", "R3", "RL", "S1", "S3", "S22", "S25", "S38", "S51", "T"];
		try {
			if( ! string )
				string = Date.now().toString();
			
			if( algo == '' ){
				if( CryptoJS && CryptoJS.SHA256 && string && typeof string == 'string' )
					return CryptoJS.SHA256( string ).toString(CryptoJS.enc.Base64);
				else
					return false;
			}
			
			algo = algo.split("-");
			
			if( algo.length > 3 ) {
				this.errorMessage("note algo not properly configured");
				return false;
			}
			
			let notConf = false;
			let x, hash, data, key;
			
			if( ! CryptoJS ){
				this.errorMessage("Can't hash without hashing functions installed");
				return false;
			}
			
			hash 		= string;
			
			for( x = 0; x < algo.length; x++ ){
				if( algoKeys.indexOf( algo[x] ) == -1 )
					notConf = true;
				
				switch( algo[x] ){
					case "A" :
						if( CryptoJS.AES ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.AES.encrypt( data, key );
						}
					break;
					
					case "D" :
						if( CryptoJS.DES ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.DES.encrypt( data, key );
						}
					break;
					
					case "E":
						if( CryptoJS.EvpKDF ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.EvpKDF.encrypt( data, key );
						}
					break;
					case "H":
						if( CryptoJS.HMAC ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.HMAC( data, key );
						}
					break;
					
					case "M":
						if( CryptoJS.MD5 ){
							hash = CryptoJS.MD5( hash );
						}
					break;
					case "P":
						if( CryptoJS.PBKDF2 ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.PBKDF2.encrypt( data, key );
						}
					break;
					case "R":
					if( CryptoJS.RC4 ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.EvpKDF.encrypt( data, key );
						}
					break;
					case "R2":
					if( CryptoJS.RC4Drop ){
							data = hash.slice(0, Math.round( hash.length / 2 ) );
							key  = hash.slice( Math.round( hash.length / 2 ), hash.length );
							hash = CryptoJS.EvpKDF.encrypt( data, key );
						}
					break;
				}
			}
			
			if( notConf ){
				this.errorMessage("note algo not properly configured");
				return false;
			}
			
			return hash;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
		
	}
	static async requireLogin(){
		//console.log("requireLogin running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "requireLogin";
		let walletID;
		//console.log( "Inside requireLogin" );
		if( ! this.walletID && this.alertDetails )
			walletID = await this.createPrompt("please enter your walvar id, leave empty to create a new wallet","SCRIPTBILLWALLET");
		
		let password = '';
		
		if( walletID && walletID != 'SCRIPTBILLWALLET' ) {
			
			if( ! this.#password )			
				this.#password = await this.#getPassword();
	

			if( this.#password  ){
				this.walletID = walletID;
				await this.loginUserDetails();
			}
			else {
				let recreate = await this.createConfirm("Password Cannot Be Empty, Do You Want To Re-login?");
				
				if( recreate ){
					this.requireLogin();
				}
				else {
					let createWallet = await this.createConfirm("OK! Do you want to create new wallet");
					
					if( createWallet ){
						this.createNewScriptbillWallet();
					}
				}
			}
		}
		else {
			this.createNewScriptbillWallet();
		}
	}
	
	
	static calculateTime( time ){
		//console.log("calculateTime running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "calculateTime";
		//the time must be in string format for the function to run correctly.
		if( typeof time != 'string' ) return;
		
		let timeSp = time.split(' ');
		
		if( timeSp.length != 2 ) return;
		
		let timeNo = parseInt( timeSp[0] );
		let timeStr = timeSp[1].toLowerCase();
		let timeObj = {
			'seconds' : function(no){
				no = parseInt( no );
				if( no ){
					return 1000 * no;
				}
				else {
					return 1000;
				}
			},
			'minutes' : function(no){
				no = this.seconds( no );
				if( no ){
					return 60 * no;
				}
				else {
					return 60 * this.seconds(1);
				}
			},
			'hours'	: function(no){
				let min = this.minutes( 60 );
				no = parseInt( no );
				if( no ){
					return min * no;
				}
				else {
					return min;
				}
			},
			'days'	: function(no){
				let hrs = this.hours(24);
				no = parseInt( no );
				if( no ){
					return hrs * no;
				}
				else {
					return hrs;
				}
			},
			'weeks'	: function(no){
				let dys = this.days(7);
				no = parseInt( no );
				if( no ){
					return dys * no;
				}
				else {
					return dys;
				}
			},
			'months'	: function(no){
				let wks = this.days(30);
				no = parseInt( no );
				if( no ){
					return wks * no;
				}
				else {
					return wks;
				}
			},
			'years'	: function(no){
				let mnts = this.days(365);
				no = parseInt( no );
				if( no ){
					return mnts * no;
				}
				else {
					return mnts;
				}
			}
		};
		let keys = Object.keys( timeObj );
		
		if( keys.includes( timeStr ) && timeNo ){
			let value = timeObj[ timeStr ]( timeNo );
			return value;
		}
		else {
			return timeNo;
		}
	}
	
	//this function is meant to look into the current note's agreement and check if any
	//interest is there to be paid. For credit note's the function looks for any LOAN 
	//type agreement to remove the interest to pay the benefactor. For Bond Notes the 
	//function looks into the agreement to check for unpaid interest and for stock it
	//checks for unpaid dividends.
	static async payInterest(){
		//first check if there is a note currently running on the instance.
		if( ! this.s.currentNote ) return;
		
		try {
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
			
			if( ! this.#note || ! this.#note.blockID ) return;
			
			this.blockID 		= this.#note.blockID;
			this.getTransBlock(1, {blockID:this.blockID}).then(async block =>{
				block 				= block[0];
				let privKey;
			
				if( ! block || ! block.blockID ) return;
				
				let agreements = block.agreements;
				let exNote 		= block.exchangeNote;
				
				if( typeof agreements == "string" && this.isJsonable( agreements ) )
					agreements 		= JSON.parse( agreements );
				if( typeof exNote == "string" && this.isJsonable( exNote ) )
					exNote 		= JSON.parse( exNote );
				
				if( Object.keys( agreements ).length == 0 ) return;
				
				if( ! exNote || ! exNote.exchangeID ){
					let motherKeys = await this.#generateMotherKeys();
					if( motherKeys[ this.#note.noteType ] ){
						exNote 		= JSON.parse( JSON.stringify( this.defaultScriptbill ));
						delete exNote.noteAddress;
						delete exNote.noteSecret;
						exNote.exchangeKey 		= motherKeys.noteAddresses[ this.#note.noteType ];
						var id 					= await this.generateKey(10);
						await this.setPrivateKey( exNote.exchangeKey, id );
						exNote.exchangeID 		= await this.getPublicKey(id);
					}
				}
				
				let agreeID, agreement, value, interest, principal, total, paySpread, spread;
				let noteTime = this.#note.transTime;
				let time 	 = this.currentTime();
				let timeDiff = parseInt(time) - parseInt( noteTime ), times, blk;
				
				for( agreeID in agreements ){
					blk 			= await this.getTransBlock(1, {blockID:agreements[agreeID]});
					
					if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )
						agreement 	= JSON.parse( JSON.stringify( blk[0].agreement ));
					
					else 
						agreement 	= {};
					
					if( ! agreement.isPeriodic ) continue;
					
					
					this.response	= JSON.parse( JSON.stringify( blk ));
					
					if( await this.testNoteType("CRD", this.#note ) ) {
						
						if( agreement.agreeType == "LOAN" ){		
						
						
							value 		= parseFloat( agreement.value );						
							principal 	= ( value / agreement.times );
							interest 	= principal * parseFloat( agreement.interestRate? agreement.interestRate: this.interestRate );
							total 		= interest + principal;
							paySpread 	= this.calculateTime( agreement.payPeriod );
							spread 		= time - parseInt( agreement.timeStamp );
							
							//time reached to pay the interest indicated by subracting the current 
							//time from the last payment time.
							if( spread > paySpread ){
								this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ) );
								this.details.transType 	= "INTERESTPAY";
								this.details.recipient 	= exNote.exchangeID;
								//check if the note has the ability to pay the principal.
								if( this.#note.noteValue > total ){
									this.details.transValue 	= total;
									agreement.times 			-= 1;
								} else {
									//pay the interest alone.
									this.details.transValue 	= interest;
								}
								this.details.agreement 			= JSON.parse( JSON.stringify( agreement ));
								this.details.agreement.agreeID 	= agreeID;
								//await this.createAlert("Interest paying " + this.details.transValue );
								this.generateScriptbillTransactionBlock(this.#note, this.details, this.response ).then( block =>{
									//console.log("interest: " + JSON.stringify(block));
									//await this.createAlert("check interest " );
									if( block && block.transType == "INTERESTPAY" ){
										this.successMessage("Loan Interest Payment Successful; Transaction ID: " + block.blockID + " | Transaction Value: " + block.transValue + " | Credit Type: " + block.noteType.slice(0, block.noteType.lastIndexOf("CRD")));
									}
								});
							}
						}
						else {
							
							this.#agreeBlock 		= JSON.parse( JSON.stringify( block ));
							time = this.currentTime();
								
							//before doing anything, check if the agreement is signed by both the sender and the reciever.
							if( ! agreement.senderSign || ! agreement.recieverSign )
								continue;
							
							//next we have to verify the signatures of the reciever and the sender.
							//verifying sender.
							this.VerifyKey 	= agreement.senderKey;
							this.VerifyText	= agreement.senderID;
							this.signature 	= agreement.senderSign;
							sendVerify 		= await this.Verify(agreement.senderSign, agreement.senderKey, agreement.senderID);
							recVerify		= await this.Verify(agreement.recieverSign, agreement.recieverKey, agreement.recieverID);
							
							//if the agreement is not verified to be signed by either the sender or the reciever, we cancel and will not habndle the agreement
							if( ! sendVerify && ! recVerify )
								continue;
							
							//if the agreement is ready but the agreement is not ready to be paid based on periodicity.
							if( agreement.isPeriodic && time <= agreement.payTime )
								continue;
							
							//checking if the agreement is ready to be executed.
							if( time <= agreement.ExecTime )
								continue;			
							
							//next let'this.s check the value of the holder of Scriptbill agreement, whether or not the note can fulfil the agreement set.
							if( this.#transSend.includes( this.block.transType )  )
								noteValue = this.block.noteValue - this.block.transValue;
							
							else if( this.#transRecieve.includes( this.block.transType ) )
								noteValue = this.block.noteValue + this.block.transValue;
							
							else
								noteValue = this.block.noteValue;
							
							//before determining if the note could pay the agreement, we check the if the agreement is a periodic one, to determine the actual payment value.
							if( agreement.isPeriodic ) {
								value = agreement.value / agreement.times;
							}
							else {
								value = agreement.value;
							}
							
							//Scriptbill means the note can't pay up the agreement, so we abort and wait till the note can pay the agreement.
							if( noteValue < value )
								continue;
							
							//if it is a periodic agreement, then the agreement must be rewired back to the sender to update his own block to the agreement state.
							if( agreement.isPeriodic ) {
								this.defaultAgree = JSON.parse( JSON.stringify( agreement ) );
								this.defaultAgree.times -= 1;
								this.defaultAgree.payTime = parseInt( this.currentTime() ) + parseInt(this.calculateTime( this.defaultAgree.payPeriod ) );
								//testing the interest.				
								if( this.defaultAgree.interestType == 'SIMPLE' ) {
									//Scriptbill will give us the number of time the interst should be calculated.
									spread 		= Math.round( this.calculateTime( this.defaultAgree.payPeriod ) / this.calculateTime( this.defaultAgree.interestSpread ) );
									interest 	= ( value * this.defaultAgree.interestRate ) * spread;
									value 		= value + interest;
								}
								else if( this.defaultAgree.interestType == 'COMPOUND' ){
									//Scriptbill will give us the number of time the interst should be calculated.
									spread 		= Math.round( this.calculateTime( this.defaultAgree.payPeriod ) / this.calculateTime( this.defaultAgree.interestSpread ) );					
									
									for( x = 0; x < spread; x++ ){
										interest 	= ( value * this.defaultAgree.interestRate );
										value 		+= interest;
									}
								}
							}
							
							//if the note can pay the agreement, we use the sender'this.s public key to create a transaction for the note to pay up the agreement.
							//the user of the note do not need to trigger Scriptbill transaction, any node within the network can trigger Scriptbill transaction.
							//when the recipient of the agreement finds Scriptbill block, the note quickly updates itself to the latest value based on Scriptbill transaction.
							//if the sender finds Scriptbill block, the sender would recieve the note and lose the private key of the agreement in the process.
							//Scriptbill way, the note would not be able to recieve anymore transaction coming from Scriptbill same agreement
							//however, a periodic transaction will always have the same key but the agreement hash will be the filtering mechanism for the note.
							//if the agreement have the same hashes, the note must not recieve such transaction else the note would be invalid in the network.
							this.details 						= JSON.parse( JSON.stringify( this.defaultBlock ) );
							this.details.transValue 			= value;
							this.details.transType 				= 'AGREESEND';
							this.details.noteValue 				= noteValue;
							
							//the creator of the agreement will hold the private key of the public key stored in the agreeID handler.
							this.details.recipient 				= agreement.agreeID;
							this.details.agreement 				= agreement;
							this.autoExecute 					= true;
							
							
							if( agreement.agreeType.toUpperCase() == "SENDTO" ){
								if( typeof agreement.sendAddress == "string" ){
									this.details.recipient 		= agreement.sendAddress;
									return await this.generateScriptbillTransactionBlock();
								}
								
								if( typeof agreement.sendAddress == "object" && agreement.sendAddress.length ){
									agreement.sendAddress.forEach( async (address)=>{
										this.details.recipient 		= address.address;
										this.details.transValue 	= address.value;
										
										if( ! this.details.recipient || ! this.details.value ) return;
										
										let curTime 		= this.currentTime();
										
										if( address.time && address.time > curTime ) return;
										
										return await this.generateScriptbillTransactionBlock();
									});
								}
							}
							else if( agreement.agreeType.toUpperCase() == "CONTRACT" ){
								this.blockID 			= agreement.quoteID;
								let block 				= await this.getTransBlock();
								
								if( block && block.length && block[0].blockID ){
									block 			= JSON.parse( JSON.stringify( block[0] ));
									
									if( ! block.agreement || ! block.agreement.agreeID ) return;
									
									let contract 	= JSON.parse( JSON.stringify( block.agreement ));
									
									if( ! contract.contractItems || ! contract.contractItems.length || ! typeof contract.contractItems == "object" ) return;
									
									let fee 		= contract.execFee;
									
									if( ! fee || fee >= 1 )
										fee 		= 0.2;
									
									let stages 		= JSON.parse( contract.stages && this.isJsonable( contract.stages ) ? contract.stages : "{}" );
									
									let execTime 	= contract.execTime;
									let curTime 	= this.currentTime();
									
									//contract not yet time to execute.
									if( execTime > curTime ) return;
									
									let calTime = 0, stage;
									
									contract.contractItems.forEach((item, index)=>{
										if( item.stage ){
											stage 	= stages[ item.stage ];
											calTime = execTime;
											if( stage ){
												//come back for this.
											}
										}
									});
								}
							}
							else if( agreement.agreeType.toUpperCase() == "PRODUCT" ){
								this.details.recipient 		= this.#note.noteAddress;
								value 						= parseFloat( blk.transValue );
								let rate 					= agreement.productConfig.sharingRate ? agreement.productConfig.sharingRate:0.2;
								let realValue 				= value - ( value * parseFloat( rate ) );
								
								if( agreement.value <= realValue ){
									this.details.transValue 	= agreement.value;
								} else {
									this.details.transValue 	= realValue;
								}							
							}
							//the recipient of the transaction holds the private key to the block key of this transaction
							/* await this.setPublicKey( agreement.blockKey );
							this.details.blockRef 				= await this.#encrypt( JSON.stringify( agreement ) ); */
							
							blk = await this.generateScriptbillTransactionBlock();
							
							if( agreement.agreeType.toUpperCase() == "PRODUCT" ){
								this.details.transType 		= "RECIEVE";
								this.response 				= JSON.parse( JSON.stringify( blk ));
								this.details.transValue 	= this.response.transValue;
								await this.generateScriptbillTransactionBlock(this.details, this.#note );
							}
						}
						
						
					} else if( await this.testNoteType("STK", this.#note ) ){
						
						if( agreement.agreeType != "STOCK" ) continue;
						
						paySpread 	= this.calculateTime( agreement.payPeriod );
						spread 		= time - parseInt( agreement.payTime );
						
						if( paySpread < spread ){
							this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
							this.details.transType = "STOCKPAY";
							//the note value tells the network the value of the stock held by
							//the note.
							this.details.transValue = this.#note.noteValue;
							this.details.Pay		= this.#note.Pay;
							this.details.agreement 	= agreement;
							this.generateScriptbillTransactionBlock().then( block =>{
								if( block && block.transType == "STOCKPAY" ){
									this.successMessage("Dividend Payment Request Transaction Was Successfully Executed; Transaction ID: " + block.blockID);
								}
							});
						}
						
					} else if( await this.testNoteType("BND", this.#note ) ) {
						
						if( agreement.agreeType != "BOND" ) continue;
						
						//next check if the agreement has been signed by the issuer.
						if( ! agreement.senderSign ){
							this.errorMessage("Bond Hasn't Been Signed. Please Send an Agreement Request To the Signer, to get your agreement signed!!");
							continue;
						}
						
						//if signed we verify the signature.
						this.VerifyText   = agreement.senderID;
						this.VerifyKey		= agreement.senderKey;
						this.signature 		= agreement.senderSign;
						
						if( ! await this.Verify(agreement.senderSign, agreement.senderKey, agreement.senderID) ) continue;
						
						//testing the key.
						this.blockID 	= agreement.senderID;
						senderBlock 	= await this.getTransBlock(1);
						
						if( ! sendBlock.length || ! sendBlock[0].blockID || ! block.exchangeNote.agreement ){					
							this.errorMessage("Could Not Verify The Autencity of Your Bond Note");
							continue;
						}
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( block.exchangeNote.agreement, id );
						
						if( ! await this.getPublicKey( id, true ) != agreement.senderKey ){
							this.errorMessage("Could Not Verify The Autencity of Your Bond Note");
							continue;
						}
						
						principal	= agreement.value;
						interest 	= principal * parseFloat( agreement.interestRate );			
						paySpread 	= this.calculateTime( agreement.payPeriod );
						spread 		= time - parseInt( agreement.payTime );
						
						if( paySpread < spread ){
							times 	= Math.round( parseInt( spread ) / parseInt( paySpread ) );
							total 	= interest * times;
							this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
							this.details.transType = "BONDPAY";
							this.details.transValue = total;
							this.details.agreement 	= agreement;
							privKey 				= await this.generateKey( 40, true );
							var id 					= await this.generateKey(10);
							await this.setPrivateKey( privKey, id );
							this.details.recipient 	= await this.getPublicKey(id);
							this.generateScriptbillTransactionBlock(this.details).then( async block =>{
								if( block && block.transType == "BONDPAY" ){
									this.successMessage("Bond Interest Payment Request Transaction Was Successfully Executed. Transaction ID: " + block.blockID );
									await this.setPrivateKey( privKey, id );
									agreement 		= await this.#decrypt( block.recipient, id );
									
									if( agreement && this.isJsonable( agreement ) ) {
										agreement 		= JSON.parse( agreement );
										if( ! agreement.isColdDeposit ) return;
										
										this.details.transType 	= "BONDRECIEVE";
										this.details.agreement 	= agreement;
										this.response 			= block;
										this.details.transValue = block.transValue;
										this.#privKey 			= privKey;
										this.generateScriptbillTransactionBlock(this.details).then( block =>{
											if( block && block.transType == "BONDRECIEVE" ){
												this.successMessage("Bond Interest Payment Was Successfully Recieved. Transaction ID " + block.blockID );
											}
										});
									}
								}
							});
						}
						
					}
				}
			});
			
			
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	//Scriptbill function is designed to handle the agreement on a block.
	static async handleAgreement( realBlock ){
		//console.log("handleAgreement running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "handleAgreement";
		//a Scriptbill agreement is always altomatically handled.
		//all blocks in the Scriptbill network holds and stores agreement in their block.
		//because they recieve transactions.
		//a product and budget block has their agreement fixed, because it can be queried using the productID or the
		//budgetID. Once a sender buys a product or a stock, he will store the agreement in his own agreement handler
		//once the agreement executes, the agreement sends back the money to the sender, the reciever will update his
		//transactional block by decrypting the agreement handler in the transaction. which will be encrypted using the
		//agreement ID.
		try {
			if( ! realBlock || ! realBlock.blockID || ! realBlock.agreements || Object.keys( realBlock.agreements ).length <= 0 || ! realBlock.noteType.lastIndexOf("CRD") == 3 || realBlock.referenceID ) return;
			
			let block 			= await this.getTransBlock(1, {blockID: realBlock.nextBlockID});
			
			//this function only runs with the latest block in a particular BLOCK
			//chain.
			if( block.length && block[0].blockID && block[0].blockID == realBlock.nextBlockID ){
				realBlock 		= JSON.parse( JSON.stringify( block ));
				return await this.handleAgreement( realBlock );
			}
			
			this.referenceID 			= realBlock.nextBlockID;
			block 						= await this.getTransBlock(10, {referenceID: realBlock.nextBlockID});
			
			if( ! realBlock.agreements || ! this.isJsonable( realBlock.agreements ) ) return;
			
			let agreement, agreements = JSON.parse( JSON.stringify( realBlock.agreements)), time, currentBlock, lastTime;
			let noteValue, agreeValue, value, recVerify, sendVerify, spread, interest, x;
			let db, store, trans, check, index;
			//the agreement must be an array.
			
			let execTime	= Math.round( Math.random() * 600000 );
			
			let blocks 		= [], blk;
			for( x in agreements ){
				if( typeof agreements[x] != "object" || ! this.isJsonable( agreements[x] ) ){
					this.blockID  	= agreements[x];
					blk 			= await this.getTransBlock(1);
					
					if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )
						agreement 		= JSON.parse( JSON.stringify( blk[0].agreement ));
					
					else agreement = false;
				} else {
					if( this.isJsonable( agreements[x] ) ){
						agreement 		= JSON.parse( agreements[x] );
					} else {
						agreement 		= JSON.parse( JSON.stringify( agreements[x] ));
					}
				}
				
				if( ! agreement ) 
					continue;
				
				if( typeof agreement == "object" && ! agreement.agreeID)
					continue;				
			
				
				this.#note 			= await this.#getCurrentNote();
				
				if( ! this.#note )
					break;
				
				currentBlock 			= await this.getTransBlock(1, {blockID: this.#note.blockID});
				
				time 					= this.currentTime();
				lastTime				= parseInt( this.l.lastAgreementTime );
				
				if( isNaN( lastTime )){
					this.l.lastAgreementTime	= parseInt( time ) + parseInt( this.calculateTime( "1 hours" ));
					lastTime				= parseInt( this.l.lastAgreementTime );
				}
				
				//this checks if the note has already auto executed a transaction
				//in the past.
				if( currentBlock.length && currentBlock[0].referenceID && currentBlock[0].referenceKey && currentBlock[0].transType == "AGREESEND" && lastTime > time )	break;
				
				//this shows that the last time he executed an agreement is elapse.
				//so the next step is to update his block chain not to have the 
				//agree send transaction anymore, so that his block chain can remain
				//relevant
				if( currentBlock[0] && currentBlock[0].transType == "AGREESEND" ){
					this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ));
					this.details.transType 	= "UPDATE";
					this.details.transValue = 0;
					await this.generateScriptbillTransactionBlock( this.details, this.#note );
					continue;
				}
					
				//before doing anything, check if the agreement is signed by both the sender and the reciever.
				if( ! agreement.senderSign || ! agreement.recieverSign )
					continue;
				
				//next we have to verify the signatures of the reciever and the sender.
				//verifying sender.
				sendVerify 		= await this.Verify(agreement.senderSign, agreement.senderKey, agreement.senderID);
				recVerify		= await this.Verify(agreement.recieverSign, agreement.recieverKey, agreement.recieverID);
				
				//if the agreement is not verified to be signed by either the sender or the reciever, we cancel and will not habndle the agreement
				if( ! sendVerify && ! recVerify )
					continue;
				
				//if the agreement is ready but the agreement is not ready to be paid based on periodicity.
				if( agreement.isPeriodic && time <= agreement.payTime )
					continue;
				
				//checking if the agreement is ready to be executed.
				if( time <= agreement.ExecTime )
					continue;

				block 			= await this.getTransBlock(100, {referenceID: realBlock.nextBlockID, referenceKey: agreement.agreeID});
				
				//this shows we have found an already executed agreement transaction
				if( block.length || block[0].blockID || block[0].referenceID == realBlock.nextBlockID )
					continue;
				
				//next let'this.s check the value of the holder of Scriptbill agreement, whether or not the note can fulfil the agreement set.
				if( this.#transSend.includes( realBlock.transType )  )
					noteValue = realBlock.noteValue - realBlock.transValue;
				
				else if( this.#transRecieve.includes( realBlock.transType ) )
					noteValue = realBlock.noteValue + realBlock.transValue;
				
				else
					noteValue = realBlock.noteValue;
				
				//before determining if the note could pay the agreement, we check the if the agreement is a periodic one, to determine the actual payment value.
				if( agreement.isPeriodic ) {
					value = agreement.value / agreement.times;
				}
				else {
					value = agreement.value;
				}
				
				//Scriptbill means the note can't pay up the agreement, so we abort and wait till the note can pay the agreement.
				if( noteValue < value )
					continue;
				
				//this ensure that the transaction will be executed in random times
				//across the network.
				setTimeout( async ( agreement, blocks, value, noteValue )=>{
					//if it is a periodic agreement, then the agreement must be rewired back to the sender to update his own block to the agreement state.
					if( agreement.isPeriodic ) {
						this.defaultAgree = JSON.parse( JSON.stringify( agreement ) );
						this.defaultAgree.times -= 1;
						this.defaultAgree.payTime = parseInt( this.currentTime() ) + parseInt(this.calculateTime( this.defaultAgree.payPeriod ) );
						//testing the interest.				
						if( this.defaultAgree.interestType == 'SIMPLE' ) {
							//Scriptbill will give us the number of time the interst should be calculated.
							spread 		= Math.round( this.calculateTime( this.defaultAgree.payPeriod ) / this.calculateTime( this.defaultAgree.interestSpread ) );
							interest 	= ( value * this.defaultAgree.interestRate ) * spread;
							value 		= value + interest;
						}
						else if( this.defaultAgree.interestType == 'COMPOUND' ){
							//Scriptbill will give us the number of time the interst should be calculated.
							spread 		= Math.round( this.calculateTime( this.defaultAgree.payPeriod ) / this.calculateTime( this.defaultAgree.interestSpread ) );					
							
							for( x = 0; x < spread; x++ ){
								interest 	= ( value * this.defaultAgree.interestRate );
								value 		+= interest;
							}
						}
					}
					
					//if the note can pay the agreement, we use the sender'this.s public key to create a transaction for the note to pay up the agreement.
					//the user of the note do not need to trigger Scriptbill transaction, any node within the network can trigger Scriptbill transaction.
					//when the recipient of the agreement finds Scriptbill block, the note quickly updates itself to the latest value based on Scriptbill transaction.
					//if the sender finds Scriptbill block, the sender would recieve the note and lose the private key of the agreement in the process.
					//Scriptbill way, the note would not be able to recieve anymore transaction coming from Scriptbill same agreement
					//however, a periodic transaction will always have the same key but the agreement hash will be the filtering mechanism for the note.
					//if the agreement have the same hashes, the note must not recieve such transaction else the note would be invalid in the network.
					this.#agreeBlock 					= JSON.parse( JSON.stringify( realBlock ));
					this.details 						= JSON.parse( JSON.stringify( this.defaultBlock ) );
					this.details.transValue 			= value;
					this.details.transType 				= 'AGREESEND';
					this.details.noteValue 				= noteValue;
					
					//the creator of the agreement will hold the private key of the public key stored in the agreeID handler.
					this.details.recipient 				= agreement.agreeKey;
					this.details.agreement 				= agreement;				
					//this.autoExecute 					= true;
					if( agreement.agreeType.toUpperCase() == "SENDTO" ){
						if( typeof agreement.sendAddress == "string" ){
							this.details.recipient 		= agreement.sendAddress;
							this.response 				= JSON.parse( JSON.stringify( realBlock ));
							blk 						= await this.generateScriptbillTransactionBlock(this.details, this.#note );
							blocks.push( blk );
						}
						
						if( typeof agreement.sendAddress == "object" && agreement.sendAddress.length ){
							blocks = agreement.sendAddress.map( async (address)=>{
								this.details.recipient 		= address.address;
								this.details.transValue 	= address.value;
								
								if( ! this.details.recipient || ! this.details.value ) return;
								
								let curTime 		= this.currentTime();
								
								if( address.time && address.time > curTime ) return;
								this.response 				= JSON.parse( JSON.stringify( realBlock ));
								return await this.generateScriptbillTransactionBlock( this.details );
							});
						}
						return;
					}
					else if( agreement.agreeType.toUpperCase() == "CONTRACT" ){
						this.blockID 			= agreement.quoteID;
						let block 				= await this.getTransBlock();
						
						if( block && block.length && block[0].blockID ){
							block 			= JSON.parse( JSON.stringify( block[0] ));
							
							if( ! block.agreement || ! block.agreement.agreeID ) return;
							
							let contract 	= JSON.parse( JSON.stringify( block.agreement ));
							
							if( ! contract.contractItems || ! contract.contractItems.length || ! typeof contract.contractItems == "object" ) return;
							
							let fee 		= contract.execFee;
							
							if( ! fee || fee >= 1 )
								fee 		= 0.2;
							
							let stages 		= JSON.parse( contract.stages && this.isJsonable( contract.stages ) ? contract.stages : "{}" );
							
							execTime 		= contract.execTime;
							let curTime 	= this.currentTime();
							
							//contract not yet time to execute.
							if( execTime > curTime ) return;
							
							let calTime = 0, stage;
							
							let blecks = contract.contractItems.map((item, index)=>{
								this.response 				= JSON.parse( JSON.stringify( realBlock ));
								if( item.stage ){
									stage 	= stages[ item.stage ];
									calTime = execTime;
									if( stage ){
										//come back for this.
									}
								}
							});
							
							blocks 			= blocks.concat( blecks );
							return;
						}
					}
					
					//the recipient of the transaction holds the private key to the block key of this transaction
					/* await this.setPublicKey( agreement.blockKey );
					this.details.blockRef 				= await this.#encrypt( JSON.stringify( agreement ) ); */
					
					blocks.push( await this.generateScriptbillTransactionBlock( this.details ) );
				}, execTime, agreement, blocks, value, noteValue );
									
			}
			
			return blocks;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static #runAgreements(){
		this.checkAgreements();
		setInterval( ()=>{
			this.checkAgreements();
		}, 600000 );
	}
	
	static async checkAgreements(){
		
		try {
			if( ! this.#note )
				this.#note = await this.#getCurrentNote();
			
			this.blockID 	= this.#note.blockID;
			let block 		= await this.getTransBlock();
			
			if( ! block.length )
				return false;
				
			block 			= block[0];
			
			if( ! block.agreements || typeof block.agreements != "object" || Object.keys( block.agreements ).length  )
				return false;
			
			let agrees 			= JSON.parse( JSON.stringify( block.agreements ) );
			let agreement 		= false, time = this.currentTime(), value = 0, calc, spread, rounds = 0, interest, blk;
			
			for( agreeID in agrees ){
				this.blockID  	= agrees[agreeID];
				blk 			= await this.getTransBlock(1);
				
				if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )
					agreement 		= JSON.parse( JSON.stringify( blk[0].agreement ));
				
				else 
					agreement 		= {};
				
				//this is an indication that the agreement has expired
				if( time < agreement.ExecTime )
					continue;
				
				if( agreement.periodic ){
					//this indicate that the periodic payment is not ready yet. 
					if( time < agreement.payTime )
						continue;			
					
					value 	= agreement.value / agreement.times;							
				} else {
					value 	= agreement.value;
				}		
				//check if the agreement contains interest.
				if( agreement.interestRate > 0 ){
					calc 	= this.calculateTime( agreement.interestSpread );
					if( agreement.isPeriodic )
						spread 	= time - agreement.payTime;
					
					else 
						spread 	= time - agreement.ExecTime;
						
					if( spread > calc ){
						rounds 		= Math.floor( spread / calc );
						interest 	= rounds * agreement.interestRate;
						value 		*= interest;
					}
				}
				this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
				this.details.agreement = JSON.parse( JSON.stringify( agreement ));
				this.details.transType = "AUTOEXECUTE";
				this.details.transValue = value;
				await this.generateScriptbillTransactionBlock();			
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async createNewScriptbillWallet(){		
		//console.log("createNewScriptbillWallet running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "createNewScriptbillWallet";
		//console.log("check password: " + this.password);
		try {
			if( this.password )
				this.#password 		=  await this.#generatePassword( this.password );
			
			//console.log("check generated password: " + this.#password );
			//await this.createAlert("Check Password! ");
			
			//for those entering default key, use the default key handler.
			if( this.key )
				this.#passwordKey 	= this.key;
			
			if( this.defaultScriptbill.walletID )
				this.walletID 		= this.defaultScriptbill.walletID;		
			
			if( ( ! this.l.user_pass || this.l.user_pass != this.password ) && this.password )
				this.l.user_pass = this.password;
			
			//console.log("Password generated: " + this.#password);
			//ensuring no other note is logged in when creating a new note.
			/* if( this.s.currentNote ){
				delete this.s.currentNote;
			} */
			
			//if the personal database have been created
			if( ( ! this.walletID || this.walletID == 'SCRIPTBILLWALLET' ) && this.l.personal ){
				this.successMessage("No Wallet id but will be gotten from Personal");
				let personal = JSON.parse( this.isJsonable( this.l.personal ) ? this.l.personal: '{}' );
				
				if( personal.walletID )
					this.walletID = personal.walletID;
			}
			
			else if( ! this.l.personal )		
				this.walletID = this.hashed( string );//using the current time as seed makes the new walvar id being created very unique.
			
			this.walletID 		= this.walletID.replaceAll("/","").replaceAll("+","");
			
			this.successMessage( "this.walletID: " + this.walletID );
			
			//for the wallet to stand, we need to create a note for it.
			//the default block should contain default details about the Scriptbill exchange market
			let details = JSON.parse( JSON.stringify( this.defaultBlock ) );
			let note 	= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
			
			let exchangeNote = false;
			//console.log( "creating note, note type: ", note.noteType );
			//trying to set the current note.
			if( note.noteType && ( note.noteType.length - note.noteType.lastIndexOf("CRD") ) == 3 ) {
				//console.log("running creating the current note");
				let privKey, pubKey;			
				let testType 		= note.noteType.slice( 0, note.noteType.lastIndexOf("CRD") );
				this.noteTypeS 		= note.noteType;
				this.noteTypeD 		= note.noteType;
				//getting random block from the database with this note type.
				let transBlock 		= await this.resolvePersistentData('noteType', note.noteType );
			
				exchangeNote	= await this.getCurrentExchangeNote( note.noteType );
				
				
				if( ! exchangeNote && transBlock.length && transBlock[0].exchangeNote && transBlock[0].exchangeNote.noteType && transBlock[0].exchangeNote.noteType == note.noteType ){
					exchangeNote 			= JSON.parse( JSON.stringify( transBlock[0].exchangeNote ) );
				}
								
				//console.log( "exchange note: " + JSON.stringify( exchangeNote ) );
				//await this.createAlert( "Check Exchange Note" );
							
				if( exchangeNote && exchangeNote.exchangeID && exchangeNote.exchangeID != this.defaultBlock.exchangeNote.exchangeID && transBlock[0] && exchangeNote.budgetID ) {
					this.#currentNote 				= JSON.parse( JSON.stringify( exchangeNote ) );				
					//console.log("Exchange Note is true " + JSON.stringify( exchangeNote ) );
					this.#currentNote.noteAddress 	= this.#currentNote.exchangeID;
					this.#currentNote.noteSecret 	= this.#currentNote.exchangeKey;
					
					if( this.#currentNote.noteType != note.noteType )
						this.#currentNote.noteType =  note.noteType;
					
					if( this.#fiatCurrencies[ testType ] ){
						var string = "SCRIPTBANKFIATEXCHANGEWALLET";
						
						if( ! this.#currentNote.walletID || this.#currentNote.walletID != this.hashed( string ) ){
							this.#currentNote.walletID = this.hashed( string );
						}//ftp://ftp.hp.com/pub/caps-softpaq/CASLSetup.exe				
					}
				}
				else if( note.noteType == "SBCRD" ){
					this.#currentNote 				= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ) );
					this.#currentNote.creditType 	= "scriptbill";
					//console.log("Block is not true, but default type is created");
					this.#currentNote.noteAddress 	= this.#currentNote.exchangeID;
					this.#currentNote.noteSecret 	= this.#currentNote.exchangeKey;
					this.#currentNote.withdrawAccount 	= {accountType: "BTC", accountDetails: this.#ScriptbankAccounts[ Math.round( Math.random() * this.#ScriptbankAccounts.length ) ]};
				}			
				//for users who want to create custom credits
				//their notes must be in the currentNote handler
				else if( this.currentNote && ! this.#fiatCurrencies[ testType ] ){
					this.#currentNote 				= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ) );
					this.#currentNote.motherKey 	= this.currentNote.noteAddress;
					this.#currentNote.creditType 	= "scriptbill";
					//console.log("Exchange Note is not true but a Current note exists");
					//generating the exchange IDs
					privKey 			= await this.generateKey(40, true);
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					pubKey 				= await this.getPublicKey(id);
					this.#currentNote.exchangeID	= pubKey;
					this.#currentNote.exchangeKey  	= privKey;
					this.#currentNote.noteAddress 	= pubKey;
					this.#currentNote.noteSecret 	= privKey;
					this.#currentNote.noteType 		=  this.currentNote.noteType;
					this.#currentNote.creditType 	= this.currentNote.creditType;
					this.#currentNote.noteValue 	= this.currentNote.noteValue;
					this.#currentNote.walletID 		= await this.generateKey(30);
					this.#currentNote.noteServer 	= this.currentNote.noteServer;
					
					//checking the note server if it is a Scriptbill server
					let checkServer 				= await this.getData('scriptbillPing', 'true', this.#currentNote.noteServer );
					
					if( ! checkServer || ! checkServer.isScriptbillServer ){
						let message 		= "Can't Create an Exchange Market without an Exchange Server!";
						if( this.alertDetails )
							await this.createAlert( message );
						
						else
							this.errorMessage( message );
						
						return false;
					}
					
					if( this.withdrawAccount )
						this.#currentNote.withdrawAccount = this.withdrawAccount;
				}
				else if( this.#fiatCurrencies[ testType ] ){
					this.#currentNote					= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ) );
					this.#currentNote.noteType 			= note.noteType;
					this.#currentNote.withdrawAccount 	= {accountType: "BTC", accountDetails: this.#ScriptbankAccounts[ Math.round( Math.random() * this.#ScriptbankAccounts.length ) ]};
					let motherKeys 		= await this.#generateMotherKeys();
					//console.log( motherKeys );
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( motherKeys[ note.noteType ], id );
					this.#currentNote.motherKey 		= await this.getPublicKey(id);
					this.#currentNote.creditType 		= "fiat";
					//console.log("Block is not true, reverting back to Scriptbank default fiat");
					//await this.createAlert("checn");
					//calculating the exchange IDs
					privKey 			= motherKeys.noteAddresses[ note.noteType ];
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					pubKey 				= await this.getPublicKey(id);
					this.#currentNote.exchangeID 	= pubKey;
					this.#currentNote.noteSecret  	= privKey;
					this.#currentNote.exchangeKey	= privKey;
					this.#currentNote.noteAddress 	= pubKey;
					var string = "SCRIPTBANKFIATEXCHANGEWALLET";
					this.#currentNote.walletID 		= this.hashed( string );
					privKey 		= motherKeys.budgetIDS[ note.noteType ];
					await this.setPrivateKey( privKey, id );
					this.#currentNote.budgetID 		= await this.getPublicKey(id);
					exchangeNote 					= JSON.parse( JSON.stringify( this.#currentNote ));
					
				}
				//no responsibility was found
				else if( ! this.currentNote ){
					note.noteType 				= "SBCRD";
					this.#currentNote 			= this.defaultBlock.exchangeNote;//keys already set by default.
					//console.log("Block is not true, no current note");
					this.#currentNote.noteAddress 	= this.#currentNote.exchangeID;
					this.#currentNote.noteSecret 	= this.#currentNote.exchangeKey;
				}
				
				/* //console.log( " the current note after all " + JSON.stringify( this.#currentNote ));
				await this.createAlert("Check Current Note" ); */
				//if we couldn't get the exchange note we create the exchange note budget
				//the creator should be able to set the default budget patterns at the 
				//budget config handler
				if( ! exchangeNote || ! exchangeNote.exchangeID || ! exchangeNote.budgetID  ){
					//await this.createAlert("Creating Budget");
					let agreement 				=  this.budgetConfig;
					
					if( this.#fiatCurrencies[ testType ] ){
						agreement.name 			= this.#fiatCurrencies[ testType ] + " Scriptbill Credit";
					}
					//expected to be preset by the creator of the exchange market
					else if( agreement.name == "Scriptbank Budget" ){
						agreement.name 			= "Scriptbill Credit ID: " + await this.generateKey( 10 );
					}
					
					//the bond units should be preset but can be updated anytime the
					//creator wishes.
					if( ! agreement.value && this.#fiatCurrencies[ testType ] ){//units of bonds to be sold
						agreement.value 		= parseFloat( Math.round( Math.random() * 10000000000 ) );
					}
					else if( this.#currentNote.noteType == "SBCRD" )
						agreement.value 		= 1000000000;
					
					//other details of the agreement must be set.
					//the exchange note remains at the this.#currentNote global variable.
					agreement.budgetCredit 		= note.noteType;
					agreement.max_exec			= "none";
					agreement.budgetType 		= "governmental";
					agreement.stockID 			= note.noteType.slice( 0, note.noteType.lastIndexOf("CRD") ) + "BND";
					let privKey;
					//generating the budget ID
					//generated only if the currency is not part of the fiat
					//currency that Scriptbank depends on.
					//fiat currencies are for Scriptbank.
					/* if( ! this.#fiatCurrencies[testType] ){
						privKey 						= await this.generateKey( 50, true );	
						this.#currentNote.walletID 		= await this.generateKey(24);
						this.defaultScriptbill.budgetID = privKey;
					}
					else {
						privKey 					= motherKeys.budgetIDS[ note.noteType ];
						var string 				= "SCRIPTBANKFIATEXCHANGEWALLET";
						this.#currentNote.walletID 	= this.hashed( string );
					} */
					
					//await this.setPrivateKey( privKey );
					//agreement.budgetID 			= await this.getPublicKey();
					//the current note inherits the budget id.
					//the instantiated note will be the mother key of the exchange note.
					//this.#currentNote.budgetID 	= privKey;
					//note 						= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
					/* //console.log("check current note: " + JSON.stringify( note ) );
					await this.createAlert( "check current note secret: " + note.noteSecret ); */
					privKey 						= await this.generateKey( 50, true );
					var id 							= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					note.noteSecret 				= privKey;
					note.noteAddress 				= await this.getPublicKey(id);
					if( ! note.noteBudgets )
						note.noteBudgets = [];
					
					this.#isExchangeMarketMining 	= true;
					this.#note 						= JSON.parse( JSON.stringify( note ));
					
					let budget  					= await this.createScriptbillBudget( agreement, note );
					//console.log( budget, JSON.stringify( budget ));
					//await this.createAlert("Check Budget");
					this.#isExchangeMarketMining 	= false;
					
					/* //console.log( "budget block: " + budget, " type: " + typeof budget, "stringified: " + JSON.stringify( budget ) );
					await this.createAlert( "check Budget" ); */
					this.response 					= JSON.parse( JSON.stringify( budget ) );
					this.#currentNote 				= JSON.parse( JSON.stringify( note ) );
					
					if( budget && budget.blockID && budget.transType && budget.transType == "CREATEBUDGET" ){
						this.defaultBlock.exBlockID 		= budget.blockID;
						this.defaultBlock.exFormerBlockID 	= budget.formerBlockID;
						this.defaultBlock.exNextBlockID 	= budget.nextBlockID;
						this.defaultBlock.budgetID 			= budget.budgetID;
					} else {
						this.errorMessage("budget block for " + note.noteType + " Exchange Market Was Not Successfully Created!!!");
						return false;
					}
					note 					= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
					
				}
			}
			
			this.defaultBlock.exchangeNote 	= JSON.parse( JSON.stringify( exchangeNote ));
			this.defaultBlock.budgetID 		= exchangeNote.budgetID;
			
			//getting the note Account Data if Stored on Local 
			//Storage
			var string 	= note.walletID;
			let trivKey 	= this.hashed( string );
			let accountData = await this.getAccountData();
			
			if( accountData.loanValue )
				note.loanValue 	= accountData.loanValue;
			
			if( accountData.value )
				note.rankValue 	= accountData.value;
							
			this.s.defaultNote 		= JSON.stringify( note );
			details.transType 	= "CREATE";
			details.transValue = 0;
			this.#note 			= JSON.parse( JSON.stringify( note ));
			this.details 		= JSON.parse( JSON.stringify( details ));
			
			if( ! this.#note.referee || ! typeof this.#note.referee == "string" || this.#note.referee.length < 10 ){
				if( this.referee && this.referee.length > 10 && typeof this.referee == "string" ){
					this.#note.referee 		= this.referee; 
					if( this.referee == "SCRIPTBANKBUSINESSMANAGERCOMPANY" ){
						this.#note.rankPref = "businessManager";
					}
				} else {
					this.errorMessage("Please enter a referee code! Or ask from the user that refered you");
					return false;
				}
			}
			
			this.#note.referer 		= await this.generateKey(20);
			this.#note.referer 		= this.#note.referer.replaceAll(/[^a-zA-Z0-9]/g, "");
			
			//console.log("note type before generate Scriptbill", this.#note.noteType );
			
			let newBlock = await this.generateScriptbillTransactionBlock( details, this.#note );
			
			if( this.returnNote && newBlock && newBlock.blockID )
				newBlock.note 	= JSON.parse( JSON.stringify( this.#note ));
			
			return newBlock;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async verifyScriptbillTransactionBlock( block = null ){
		//console.log("verifyScriptbillTransactionBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "verifyScriptbillTransactionBlock";
		//console.log("Start Of verifyScriptbillTransactionBlock", "The Block " + JSON.stringify( this.block ) );
		try {
			
			if( ! block && this.block )
				block 	= JSON.parse( JSON.stringify( this.block ));
			//escape CREATE transactions.
			if( block.transType == "CREATE" )
				return block;
			
			if( ! block || ! block.blockID ) return block;
			
			//verify block iss not for new block
			if( block.blockKey != '' && block.transType != 'CREATE' && this.#note.blockKey != '') {
				
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( this.#note.blockKey, id );
				let blockKey = await this.getPublicKey(id, true);
				
				if( blockKey != block.blockKey ){
					this.errorMessage('Note Block With Block ID: '+ block.blockID + ' Was Not Verified To Be Signed By Current Note With Address: ' + this.#note.noteAddress + ' Current Transaction Will Now Be Aborted!!!');
					return false;
				}
				
				if( ! await this.Verify(block.blockSign, block.blockKey, block.blockID) ) {
					this.errorMessage('Note Block With Block ID: '+ block.blockID + ' Was Not Verified To Be Signed By Current Note With Address: ' + this.#note.noteAddress + ' Current Transaction Will Now Be Aborted!!!');
					return false;
				}
				
			}
			
			//testing the note ID of the block.
			if( block.noteID != '' ){
				var string 	=  this.#note.noteKey;
				let noteID 		= this.encrypt( block.noteID, this.hashed( string ) );
				
				if( this.#note.noteID != noteID ) {
					this.errorMessage( 'Note Block with Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Note Address: ' + this.#note.noteAddress + '; The Note ID From the Block Didn\'t Match The Note\'this.s. Transaction Will Now Be Aborted!!!' );
					return false;
				}
			}
			
			//checking the agreements.
			//first let'this.s check the current block.
			if( block.transType == "AGREEMENTREQUEST" ) {
				blockRef 		= block.blockRef;
				let blocks 			= await this.getTransBlock();
				let x, block;
				
				/* for( x = 0; x < blocks.length && x < 10; x++ ){
					block 			= blocks[x];
					if( block && block.transType == "AGREEMENTSIGN" ){
						//verify the signature and then delete the agreement from the blocks database.
						this.VerifyText = block.signRef;
						this.VerifyKey 	= block.blockRef;
						this.signature  = block.signRef;
						
						if( await this.Verify(this.signature, this.VerifyKey, this.VerifyText) ) {
							let agreement 		= block.agreement;
							
							if( block.agreements && Object.keys( block.agreement ).length > 0 ){
								delete block.agreements[ agreement.agreeID ];
							}
						}
					}
				} */
			}
			if( block.transType == 'RECIEVE' && typeof block.recipient == 'object' && typeof block.agreements == 'object' ){
				block.agreement 							= block.recipient;
				block.agreements[ block.recipient.agreeID ] = block.blockID;
			}
			
			//testing of transaction block hashes before continuing the block generation.
			let formerHash 	= block.realHash;
			let halfHash	= block.noteHash;
			let halfTrans 	= block.transHash;
			let noteHash 	= this.#note.noteHash;
			//Scriptbill is the remaining half of the hash		
			//get the total hash of the note by removing the noteHash calculation from the note.
			let transHash 	= this.#note.transHash;
			let totalHASH	= block.totalHASH;
			
			//attempting to get correct hash value of the note.
			this.#note.noteHash 	= "";
			this.#note.transHash	= "";
			let stringNote = JSON.stringify( this.#note );
			var string    = stringNote;
			let realHash = this.hashed( string );//hash
			
			//attempting to get the correct hash value of the former transaction block.
			block.noteHash		= "";
			block.transHash	= "";
			block.totalHASH	= "";
			block.realHash		= "";
			let stringTrans 	= JSON.stringify( block );
			var string 		= stringTrans;
			let transBlockHash 	= this.hashed( string );
			
			this.#note.noteHash = noteHash;
			this.#note.transHash = transHash;
			
			//comparing the two hashes gotten.
			let concatHash = halfHash + noteHash;
			//console.log(concatHash, realHash);
			
			//fake note detected.
			if( realHash != concatHash && this.#note.noteAddress != '' && this.#note.noteID != '0000' ) {
			
				this.errorMessage('The Note Block Gotten With Block ID: ' + this.block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + ' Current Transaction Now Aborting...');
				return false;
			}
			
			//let'this.s add the two hashes gotten both from the note and the block.
			concatHash = halfTrans + transHash;
			
			//console.log(concatHash, transBlockHash);
			
			//fake block detected.
			if( transBlockHash != concatHash && this.#note.noteAddress != '' && this.#note.noteID != '0000' ) {
				this.errorMessage('The Note Block Gotten With Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + ' Current Transaction Now Aborting...');
				return false;
			}
			
			//restoring the variable.
			block.transHash 		= transBlockHash;
			block.noteHash			= halfHash;
			
			
			//before continuing the transaction, we test to verify the transaction block hash that has been kept.
			let testHASH 	= block.transHash + this.#note.transHash;
			var string 	= testHASH;
			let reHash 		= this.hashed( string );
			let blockHash 	= this.#note.blockHash;
			
			if( reHash != blockHash && this.#note.noteAddress != '' && this.#note.noteID != '0000' ) {
				this.errorMessage('The Note Block Gotten With Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + '. The Block Hashes Stored On This Note is Fake; Current Transaction Now Aborting...');			
				return false;
			}
			
					
			//testing the note'this.s nonce
			let nonce 		= this.#note.noteID;
			var string 	= block.noteID;
			let hashedNonce = this.hashed( string );
			
			//fake note detected
			if( nonce != hashedNonce && block.noteID != '0000' ) {
				this.errorMessage('The Note Block Gotten With Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + '. The Block Couldn\'t Identify The Note...');
				return false;
			}
			
			//testing the note values.
			let blockValue 	= block.noteValue;
			let noteValue  	= this.#note.noteValue;
			let transValue 	= block.transValue;
			let transType	= block.transType;
			let totalValue 	= this.#transSend.includes( transType )  ? blockValue + transValue : blockValue - transValue;
			
			totalValue 		= this.#otherTrans.includes( transType ) ? blockValue : totalValue;
			
			//fake note detected.
			if( totalValue != noteValue ) {
				this.errorMessage('The Note Block Gotten With Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + '. The Block Couldn\'t Verify The Note\'s Value...');
				return false;
			}
			
			//restoring the hashes.
			/*var string			= formerHash + realHash;
			block.realHash = this.hashed( string );
			
			//checking the hashes.
			if( ! block.realHash.includes( block.nextHash ) && block.realHash.indexOf( block.nextHash ) !== 0 ) {
				this.errorMessage('The Note Block Gotten With Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + '. The Block Couldn\'t Verify The Note\'this.s Integrity...');
				return false;
			}
			
			//restoring the hashes for the block.
			var string 			= totalHash + transBlockHash;
			block.totalHASH	= this.hashed( string );
			
			//checking the hashes.
			if( ! block.totalHASH.includes( block.nextBlockHash ) && block.totalHASH.indexOf( block.nextBlockHash ) !== 0 ) {
				this.errorMessage('The Note Block Gotten With Block ID: ' + block.blockID + ' Was Not Verified To Be Created By The Current Note With Address: ' + this.#note.noteAddress + '. The Block Couldn\'t Verify The Note\'this.s Integrity...');
				return false;
			}
			
			//testing note budgets.
			//to store a budget, we create a key for the budget and create a transaction
			//block to allow the network interact with the budget.
			
			if( this.#note.noteBudgets.length > 0 ) {
				let budgets = this.#note.noteBudgets;
				let block, budgetValue = 0;
				for( budgetKey in budgets ){
					await this.setPrivateKey( budgetKey );
					blockID 	= await this.getPublicKey();
					block 			= await this.getTransBlock();
					budgetValue 	+= block.transValue;
				}
				
				let ranks = this.#scriptbillRanks;
				await this.setPrivateKey( this.#note.rankKey );
				let rankCode = await this.#decrypt( block.rankCode );
				let rank	= ranks[ rankCode.split("|")[0] ];
				let creditLevel = 0;
				if( rank ){
					creditLevel = rank.credit_level;
					
					if( this.#note.noteType != 'SBCRD'){
						creditLevel = creditLevel * await this.getExchangeValue( 'SBCRD', this.#note.noteType )[1];
					}
				}
				
				if( this.details.transType == 'SEND' && budgetValue >= this.#note.noteValue ){
					let newValue = this.#note.noteValue + creditLevel;
					if( budgetValue >= newValue ){
						this.errorMessage('The Current Note with Note Address: ' + this.#note.noteAddress + ' Cannot Run The Current Transaction Because of An Unexecuted Budget');
						return false;
					}
				}
			}
			*/
			await this.successMessage('Transaction Block Successfully Verified. Scriptbill Note Will Continue the Transaction!');
			//console.log("End of verifyScriptbillTransactionBlock");
			
			return block;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}//local pass OdMIg6QrO4A/qk8TvVeJxQ==
	
	static async fulfillAgreement( agreeID ){
		//console.log("fulfillAgreement running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "fulfillAgreement";
		
		//initializing storage.
		
		try {
		
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
			
			if( ! this.#note ) { 
				this.errorMessage( "No current note logged in to fulfil this request. Login a Scriptbill Note and Try again!!!" );
				return false;
			}
			
					
			let block 		= await this.getTransBlock();
			block 			= block[0];
			let agreements 	= block.agreements, x, agreement, blk;
			
			for( x in agreements ){
				this.blockID 		= agreement[x];
				blk 				= await this.getTransBlock(1);
				
				if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )
					agreement 			= JSON.parse( JSON.stringify( blk[0].agreement ));
				
				else 
					agreement 			= {};
				
				if( agreement.agreeID != agreeID ) continue;
				
				this.details = block;
				this.details.transType = "AGREEMENTREQUEST";
				this.details.recipient = agreeID;
				this.details.agreement = agreement;
				this.details.transValue = 0;
				await this.generateScriptbillTransactionBlock();
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
		
	}
	
	static async getCurrentProductBlock( productID = "", productBlock = null ){
		//console.log("getCurrentProductBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getCurrentProductBlock";
		
		if( productID ){
			
			if( ! this.#note && this.s.currentNote ){
				this.#note 		= await this.#getCurrentNote();		
			}
			let transTime 		= this.currentTime + " >=";
			if( this.#note && this.#note.transTime ){
				transTime 	= this.#note.transTime + " >=";
			}
			
			let productBlocks = await this.getTransBlock(100, { productID, transTime });
			
			if( productBlocks.length < 0 ){
				return productBlock;
			}
			
			
			let x, block;
			
			for(  x = 0; x < productBlocks.length ; x++ ){
				block = productBlocks[x];
				
				if( ! productBlock || productBlock.transTime < block.transTime )
					productBlock = JSON.parse( JSON.stringify( block ) );
			}
			
			return productBlock;
		}
		
		if( ! productBlock || ! productBlock.productNextBlockID ) return productBlock;
		
		let block = await this.getTransBlock(1, {"productBlockID": productBlock.productNextBlockID});
		
		if( block && block.length && block[0].blockID ){
			return await this.getCurrentProductBlock( "", block );
		}
		
		return productBlock;		
	}
	
	static async testNoteType(prefix, note = false ){
		//console.log("testNoteType running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "testNoteType";
		
		//initializing storage.
		
		try {
		
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
				
			if( ! this.#note && ! note  ) return false;
			
			if( this.#note )
				note 		= JSON.parse( JSON.stringify( this.#note ));
			
			let length 	= 	note.noteType.length;
			let index 	= 	note.noteType.lastIndexOf( prefix );
			let sub 	= length - index;
			
			return sub == 3; 
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async getAccountData(){
		if( ! Scriptbill.s.currentNote ) return {};
		
		try {
			if( ! this.#note )
				this.#note 	= await this.#getCurrentNote();
		
			let note 		= JSON.parse( this.isJsonable( Scriptbill.s.currentNote ) ? Scriptbill.s.currentNote: '{}' );
			var string 	= note.walletID;
			let trivKey 	= this.hashed( string );
			
			let accountData = {}; 	
			
			if( this.l[ trivKey ] )
				accountData  = JSON.parse( this.isJsonable( this.l[trivKey] ) ? this.l[trivKey]: '{}' );
			
			
			
			if( ! accountData.rank ){
				accountData.rank = "IFVSSKJBHKSBUD";
			}
			if( ! accountData.rankValue ){
				accountData.rankValue = 200;
			}if( ! accountData.loanValue ){
				accountData.loanValue = 0;
			}
			
			if( this.#note && this.#note.accountData ){
				
				if( this.#note.accountData[ this.#note.noteAddress ] )
					accountData[ this.#note.noteAddress ] = this.isJsonable( this.#note.accountData[ this.#note.noteAddress ] ) ? JSON.parse( this.#note.accountData[ this.#note.noteAddress ] ) : this.#note.accountData[ this.#note.noteAddress ];
				
				else 
					accountData[ this.#note.noteAddress ] = this.isJsonable( this.#note.accountData ) ? JSON.parse( this.#note.accountData ) : this.#note.accountData;
				
				if( accountData.loanValue < this.#note.accountData.loanValue )
					accountData.loanValue	= this.#note.accountData.loanValue;
				if( accountData.rankValue < this.#note.accountData.rankValue )
					accountData.rankValue	= this.#note.accountData.rankValue;
				if( accountData.rank != this.#note.accountData.rank )
					accountData.rank	= this.#note.accountData.rank;
					
			}
			
			this.getData(['account', 'note', 'data'], [this.#note.walletID, this.#note.noteAddress, Scriptbill.Base64.encode( JSON.stringify( accountData ) ) ], this.#default_scriptbill_server);
			
			return accountData;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return {};
		}
	}
	
	static async setAccountData( accountData ){
		
		try {
			if( ! this.#note )
				this.#note = await this.#getCurrentNote();
			
			if( ! this.#note ) {
				//await this.createAlert( "returning false");
				return false;
			}
		
			var string 	= this.#note.walletID;
			let trivKey 	= this.hashed( string );
			
			
			if( localStorage ){
				localStorage[trivKey] = JSON.stringify( accountData );
			}
			
			this.accountData = JSON.parse( typeof accountData == 'string' ? accountData : JSON.stringify( accountData ) );
			
			if( this.accountData[ this.#note.noteAddress ] ){
				this.accountData 	= this.accountData[ this.#note.noteAddress ];
			}
			
			//adding the details
			this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ) );
			//setting the transaction type to UPDATE.
			this.details.transType 	= 'UPDATE';
			this.details.transValue = 0;
			this.details.noteType 	= this.#note.noteType;
			return await this.generateScriptbillTransactionBlock();
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	//Scriptbill is the legal function for generating transaction blocks in the network.
	//to test if a block is not generated using the function the Scriptbill verify block function filter that out.
	//Scriptbill funnction will do the following: first updates all document based on the current transactional data.
	//then the function will protect the block from tampering by setting security algorithm and signatures around the blocks
	//the function is where all Scriptbill transaction types are handled.
	
	static async letEncrypt( data, id = "" ){
		return await this.#encrypt( data, id );
	}
	static async letDecrypt( data, id = "" ){
		return await this.#decrypt( data, id );
	}
	
	static async #storeConnectedBlock(response){
		//this.l[ note.noteAddress + "_current_block" ] = JSON.stringify( response );
		if( ! this.s.currentNote ) return false;
		
		let note 				= JSON.parse( this.s.currentNote );
		let dir 				= await window.navigator.storage.getDirectory("scriptStorage", {create:true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		
		if( ! dir ){
			this.errorMessage("Couldn't Initialize Local Storage. You May Want to Change Browser Where Your Scriptbill is Installed");
			return false;
		}
		
		let userDirectory 		= await dir.getDirectoryHandle(note.noteAddress.replaceAll(/[^a-zA-Z0-9]/g, "_") + "_connected_block", {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		
		if( ! userDirectory ) {
			this.errorMessage("Couldn't create or initialize connected block directory ");
			return false; 
		}
			
		let file 				= await userDirectory.getFileHandle( response.blockID.replaceAll(/[^a-zA-Z0-9]/g, "_"), {create: true}).catch(error =>{this.errorMessage( error.toString() );  return false;});
		let write 				= await file.createWritable();
		await write.write( JSON.stringify( response ) );
		await write.close();
	}
	
	static async getCurrentBudgetBlock( budgetID, all = false ){
		let config 			= {};
		config.budgetID 	= budgetID;
		config.transType 	= "UPDATEBUDGET";
		let budgetBlock 	= await this.getTransBlock(100, config);//returns an array.
		config.budgetID 	= budgetID;
		config.transType 	= "ADDITEM";
		let blocks 			= await this.getTransBlock(100, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		config.budgetID 	= budgetID;
		config.transType 	= "UPDATEITEM";
		blocks 				= await this.getTransBlock(100, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		config.budgetID 	= budgetID;
		config.transType 	= "CANCELITEM";
		blocks 				= await this.getTransBlock(100, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		config.budgetID 	= budgetID;
		config.transType 	= "SUGGESTITEM";
		blocks 				= await this.getTransBlock(100, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		config.budgetID 	= budgetID;
		config.transType 	= "SUGGESTBUDGET";
		blocks 				= await this.getTransBlock(100, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		config.budgetID 	= budgetID;
		config.transType 	= "CREATEBUDGET";
		blocks 				= await this.getTransBlock(1, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		//console.log( "check budget block ", budgetBlock );
		config.budgetID 	= budgetID;
		config.transType 	= "BUSINESS";
		blocks 				= await this.getTransBlock(1, config);
		budgetBlock			= budgetBlock.concat( blocks );//returns an array.
		
		if( ! budgetBlock.length ){
			return false;
		}
		if( ! all )
			budgetBlock 		= await this.getCurrentBlock( budgetBlock );
		
		return budgetBlock;
	}
	
	static async generateScriptbillTransactionBlock(details = false, note = false, response = false ){
		//console.log("generateScriptbillTransactionBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "generateScriptbillTransactionBlock";
		
		try {
		//getting the current note if available. If not the system would not generate
		//any block except you are creating a note.
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ) )
			this.#note = await this.#getCurrentNote();
				
		//console.log("Start Of generateScriptbillTransactionBlock ", "WalletID: " + this.walletID, "Details: " + JSON.stringify( this.details ), "note: " + JSON.stringify( this.#note ) );
		
		
		//the current walvar id should be stored in a global variable.
		if( ( typeof this.walletID == "object" || ! this.walletID ) && this.#note && this.#note.walletID ){
			this.walletID 		= this.#note.walletID;
		}		
		//await this.createAlert("running transaction!!!");		
		// the current note id not running, the function won't run.
		if( ! this.#note ){
			this.errorMessage("Scriptbill cannot generate a transaction block without a valid Scriptbill note data!");
			//await this.createAlert("running transaction!!!");
			try {
				this.#note = JSON.parse( JSON.stringify( note ));
			} catch( e ){
				console.error(e);
				return false;
			}
		}

		
		
		//localizing the note and details variable.
		note 		= JSON.parse( JSON.stringify( note ? note : this.#note ));
		details 	= JSON.parse( JSON.stringify( details ? details:this.details ));
		this.#note 	= JSON.parse( JSON.stringify( note ));
		
		
		//console.log("generate block running " + details.transType + " Transaction Value Connected: " + details.transValue, "note type during the sequence:", note.noteType );
		//checking the walvar id.
		if( note && ( ! this.walletID || this.walletID != note.walletID ) && note.transType != "CREATE" ){
			this.walletID 	= note.walletID;
		}		
		
		//without the details handler set, Scriptbill cannot generate a transaction block.
		if( ! details || ! this.walletID ) {
			this.errorMessage("Scriptbill cannot generate a transaction block without a valid user detail input!");
			//await this.createAlert("running transaction!!!3");
			return false;
		}
		
		//await this.createAlert( "checking details " + details.transType );
		
		//checking the current note. the current note stands for the exchange notes
		//that should run along side the note running this function.
		//the purpose is to create automatic changes to the exchange note based 
		//on certain transaction.
		if( ( ! this.#currentNote || this.#currentNote.noteType != note.noteType ) && ! this.#isExchangeMarketMining ){
			this.#currentNote 		= await this.getCurrentExchangeNote( note.noteType );
		}
			
		
		//await this.createAlert( "trans type: " + details.transType );
		
		//we need to check for a response object running along side the function.
		//it may be needed to santify some transaction.
		
		if( this.response && this.response.blockID && ! response )
			response 	= JSON.parse( JSON.stringify( this.response ) );
		
		if( this.walletID )
			this.s.walletID = this.walletID;
		
		//await this.createAlert("before trans type: " + details.transType );
		
		//await this.createAlert("rep: " + details.recipient );
		//what if there is no recipient in the details handler.
		//we change the transaction to an update transaction and allow the user to 
		//re run the transaction with a recipient by alerting him in the errors 
		//handler.
		if( ( ! details.recipient || details.recipient == note.noteAddress ) && ! this.#otherTrans.includes( details.transType ) && details.transType != "WITHDRAW" && details.transType != "MERGE" ) {	
			this.errorMessage("Transaction resetted to update because we didn't find a recipient the " + details.transType + " Transaction.");		
			details.recipient = note.noteAddress;
			//we change the transaction type to update.
			details.transType = "UPDATE";
			//the transaction value must be zero.
			details.transValue = 0;
		}
		//await this.createAlert("trans type: " + details.transType );
		//await this.createAlert("After Update!!!");
		
		
		//await this.createAlert( "checking details 2 " + details.transType );	
		
		let testType 			= note.noteType.slice( 0, note.noteType.lastIndexOf("CRD") );
		let motherKeys 			= await this.#generateMotherKeys();
		
		//the script key is the key giving to a worker in an exchange note Server
		//it is used to verify deposits and other financial deals that connects
		//to the exchange market. the key is queried from the exchange market 
		//server for authencity. the exchange market has the right to secure this key
		if( this.scriptKey ){
			var string 		=  this.scriptKey;
			var string 		= this.hashed( string );
		}
		
		let scriptKey 			= this.hashed( string );
		
		//getting the note block as a tool to create the new 
		//block with
		this.blockID 				= note.blockID;
		//console.log("before resolving data");
		let formerBlock 			= await this.resolvePersistentData( note.blockID );
		//console.log("after resolving data");
		if( ! formerBlock ) {
			//console.log("before getting trans block data");
			formerBlock 			= await this.getTransBlock(1, {blockID:note.blockID});
			formerBlock 			= formerBlock[0];
			//console.log("after getting trans block data");
		}
		//console.log( this.formerBlock );
		if( this.formerBlock && this.formerBlock.blockID && this.formerBlock.blockID == note.blockID )
			formerBlock 		= JSON.parse( JSON.stringify( this.formerBlock ));
		//console.log("former block: " + JSON.stringify( formerBlock ) );
		//await this.createAlert("Check Former Block");
		
		//getting the referenceID
		
		if( ! formerBlock && this.formerBlock )
			formerBlock 		= JSON.parse( JSON.stringify( this.formerBlock ));
		
		if( formerBlock && formerBlock.nextBlockID ){
			//console.log("before getting reference block data");
			let referenceBlock			= await this.getTransBlock(1, {referenceID:formerBlock.nextBlockID});
			//console.log("after getting reference block data", "length", referenceBlock.length );
			if( referenceBlock && referenceBlock.length ){
				let processedKeys 		= [], block, value = 0, agree, blk;
				for( let v = 0; v < referenceBlock.length; v++ ){
					block 		= referenceBlock[v];
					value 		= block.transValue;
					if( block.referenceKey && ! processedKeys.includes( block.referenceKey ) ){
						//console.log("before getting agrreement block data");
						blk 				= await this.getTransBlock(1,{ blockID:formerBlock.agreements[ block.referenceKey ] } );
						
						if( ! blk[0] ) continue;
						
						agree 				= blk[0].agreement;
						
						if( agree && agree.value && ! agree.isPeriodic ){
							value 		= agree.value;
						}
						else if( agree && agree.isPeriodic ){
							value 		= parseFloat( agree.value ) / parseInt( agree.times );
						} else if( ! agree )
							value 		= 0;
						
						processedKeys.push( block.referenceKey );
						note.noteValue 		= parseFloat( note.noteValue ) - parseFloat( value );
						//console.log("after getting agreement block data");
					}
					
				}
			}
		}

		if(details.recipient){
			this.#Reipient = details.recipient;
		}
		
		//console.log("fully processed block data");
		
		let transType 		= details.transType;
		let transValue 		= details.transValue;
		const noteType 		= note.noteType;
		const noteValue 	= note.noteValue;
		
		
		//test the former block to be sure it is set
		if( (formerBlock == undefined || ! formerBlock || ! formerBlock.blockID ) && ! this.#isExchangeMarketMining ){
			
			if( this.l[note.noteAddress + "_current_block" ] )
				formerBlock 		= JSON.parse( this.l[note.noteAddress + "_current_block" ] );
			
			else if( details.transType == "CREATE" || details.transType == "CREATEBUDGET" )
				formerBlock = JSON.parse( JSON.stringify( this.defaultBlock ));
			
			else {
				this.errorMessage("No Former Block was found on Your Note While Running The Transaction. Please ensure your internet connection is good so as to fetch your block from the network.");
				//await this.createAlert("Error Keys 3");
				if( note.noteValue == 0 ){
					details.transType 	= "CREATE";
					transType 			= "CREATE";
					details.recipient	= "";
					details.transValue = 0;
					transType 				= details.transType;
					transValue 				= details.transValue;
					formerBlock = JSON.parse( JSON.stringify( this.defaultBlock ));
				} else return false;
			}
		}
		
		if( formerBlock && formerBlock.blockID && formerBlock.nextBlockID )
			this.formerBlock 		= JSON.parse( JSON.stringify( formerBlock ));
		
		//retesting the exchange note
		//if the transaction type is related to a product transaction the exchange Note
		//should be preset by the product.
		if( ! this.#currentNote ){
			this.#currentNote 	= await this.getCurrentExchangeNote( note.noteType );
		}
		
		//the current note's law
		if( (! this.#currentNote || typeof this.#currentNote != "object" ) && ! this.#isExchangeMarketMining ){
			this.errorMessage( "No Current Note in Your Transaction rendering it invalid" );
			return false;
		}
		
		let currentNote = JSON.parse( JSON.stringify( this.#currentNote ))
		
		
		//setting the client interest Rate handler to be useful in calculating interest payment when recieving funds.
		if( formerBlock && ! this.#isExchangeMarketMining && formerBlock.interestRate ){
			this.interestRate = formerBlock.interestRate;
			if( formerBlock.interestType ){
				this.interestType = formerBlock.interestType;
			}
		}
		//await this.createAlert( "checking details 3 " + details.transType );
		
		//before we continue, let's verify that the note actually created Scriptbill block by verifying the signature.
		let block 			= JSON.parse( JSON.stringify( formerBlock ));
		
		if( ! block ){
			block 		= JSON.parse( JSON.stringify( this.defaultBlock ) );
		}
		
		if( currentNote && typeof currentNote == "object" && ! currentNote.length && currentNote.exchangeID )
			block.exchangeNote = currentNote;
		
		let privKey, secret;		
		//console.log("former block: " + JSON.stringify( block ));
		
		//checking the verifying ID.
		if( note.verifyID ) {
			this.verifyID 	= note.verifyID;
			delete 	note.verifyID;
		}
		let realNote 	= JSON.parse( JSON.stringify( note ));
		
		delete realNote.noteSign;
		delete realNote.noteHash;
		delete realNote.transHash;
		
		var string 	= JSON.stringify( realNote );
		let formerHash 	= this.hashed( string );
		
		if( this.#noteHASH && this.#noteHASH != formerHash )
			formerHash 	= this.#noteHASH;
		
		let newBlock 		= JSON.parse( JSON.stringify( block ));
		
		//calculatin the hash for the former block.
		//variables to be excluded from the hash.		
		delete block.exchangeNote;
		delete block.data;
		delete block.productNote;
		delete block.exBlockID;
		delete block.exFormerBlockID;
		delete block.exNextBlockID;
		delete block.productBlockID;
		delete block.productFormerBlockID;
		delete block.productNextBlockID;
		delete block.transHash;
		delete block.blockHash;
		delete block.blockSign;
		delete block.witnesses;
		delete block.blockHash;
		delete block.noteSign;
		
		let KEYS 	= Object.keys( this.defaultBlock );
		
		for( let blockID in block ){
			if( ! KEYS.includes( blockID ) ){
				delete block[blockID];
			}
		}
		
		var string 	= JSON.stringify( block );
		let formerHashB = this.hashed( string );
		//next is to use information on the former block to configure the new block,
		//if the information on the former block does not match that of the new block, then the note has become invalid
		this.block 		= JSON.parse( JSON.stringify( newBlock ));
		newBlock 		= await this.verifyScriptbillTransactionBlock();
		newBlock 		= JSON.parse( JSON.stringify( this.block ) );	
		
		//console.log("new Block: " + newBlock, JSON.stringify( newBlock ));
		
		//the block was not successfully verified.
		if( newBlock === false ) {
			this.errorMessage("Note's Transaction Block Was Not Successfully Verified!!!");
			return false;
		}
		
		
		//all this three ids can only be set below when the transactio type is SPLIT
		//or AGREESEND transaction or any related transaction type.
		newBlock.referenceID 	= "";
		newBlock.referenceKey 	= "";
		newBlock.splitID 		= "";
		
		//other data that must be removed before the processing point
		newBlock.agreement 		= "";//will be set by appropraite transaction type.
		newBlock.productBlockID = "";//not needed if the transaction is a PRODUCT
		//type. If so, the product block ID will be generated by the transaction.
		newBlock.productNextBlockID = "";
		newBlock.productFormerBlockID = "";
		newBlock.productID 		= "";
		
		//also, the product note need not to be in a block that doesn't directly.
		//concern it, if it concerns it the function below will get the product 
		//note and set it to the product note handler.
		newBlock.productNote 	= "";
		
		
		const BLOCKKEY 		= newBlock.blockKey;
		
		if( response && ( this.#transRecieve.includes( details.transType ) || details.transType == "MERGE" ) && ( this.#transSend.includes( response.transType ) || response.transType == "SPLIT" ) ){
			let blockIN 	= response.blockID.slice( 0, 5);
				
			if( newBlock.recievedIDs && newBlock.recievedIDs.indexOf( blockIN ) >= 0 ){
				this.errorMessage( "Block Already Recieved!!! Transaction Now Aborting" );
				return false;
			}
			else if( ! newBlock.recievedIDs || typeof newBlock.recievedIDs != "object" ){
				newBlock.recievedIDs = [];
			}
			let transTime 	= response.transTime;
			let blockID 	= response.blockID;
				
			if( transTime == note.recievedTime ) {
					this.errorMessage( "Block Already Recieved!!! Transaction Now Aborting" );
					return false;
			}
			else if( blockID == note.recievedBlockID ){
				this.errorMessage( "Block Already Recieved!!! Transaction Now Aborting" );
				return false;
			}
			
			this.blockRef 		= response.blockRef;
			let resp 			= await this.getTransBlock(100, {blockRef: response.blockRef});
			
			if( resp.length > 1 ){
				let recieversID 	= resp[1].blockID;
				
				if( recieversID == response.blockID )
					recieversID 	= resp[0].blockID;
				
				this.errorMessage("Block already recieved by another Scriptbill user with block ID: " + recieversID );
				return false;
			}
		}
		
		if( ! newBlock.agreements )
			newBlock.agreements = {};
		
		var string 		= JSON.stringify( newBlock.agreements );		
		let formerAgreeHash	= this.hashed( string );
		
		if( currentNote && ! this.#isExchangeMarketMining ){
			if( currentNote.budgetID )
				newBlock.budgetID 		= currentNote.budgetID;
		
			/* if(  currentNote.noteType == note.noteType && currentNote.exchangeID )
				newBlock.exchangeNote = JSON.parse( JSON.stringify( currentNote )); */
		}
		
		
		/* if( ! this.#passwordKey && ! this.#isExchangeMarketMining && this.alertDetails && ! this.passwordKey && ( ! this.transactionKey && ! this.s[ this.transactionKey ] && ! this.#transSend.includes( details.transType ) )  ) {
			this.#passwordKey 		= await this.createPrompt("Please enter Your note's Key with Address "+ note.noteAddress +". This is required to validated your " + details.transType + " transaction and must be at least a four digit numbers. Value Associated With This Transaction Is: " + parseFloat( details.transValue ).toFixed(2), "1234");
			this.transactionKey 	= await this.generateKey(24);
			this.transactionKey 	= this.transactionKey.replaceAll(/[^a-zA-Z0-9]/g, "_");
			this.s[ this.transactionKey ] = this.#passwordKey;		
		}
		else if( this.transactionKey && this.s[ this.transactionKey ] && ! this.#transSend.includes( details.transType ) ){
			this.#passwordKey 	= this.s[ this.transactionKey ];
			delete this.s[ this.transactionKey ];
			this.transactionKey 	= await this.generateKey(24);
			this.transactionKey 	= this.transactionKey.replaceAll(/[^a-zA-Z0-9]/g, "_");
			this.s[ this.transactionKey ] = this.#passwordKey;
		}
		//useful for those who set the password key without using window alerting system#.
		else if( this.passwordKey ){
			this.#passwordKey = this.passwordKey;
			
			delete this.passwordKey;
		}
		
		let isNew = false;
		
		
		
		//useful for note that are just being created.
		if( ! note.transKey ){
			note.transKey 		= await this.generateKey(20);
			isNew = true;		
		}
		let transKey 		= note.transKey;
		let noteSecret 		= note.noteSecret;
		let d, key, trans1, trans2;
		if( this.#passwordKey ) {
			for( d = 0; d < this.#passwordKey.length; d++ ){
				key 		= this.#passwordKey[ d ];
				trans1		= transKey.slice( 0, key );
				trans2 		= transKey.slice( key, transKey.length );
				transKey 	= trans2 + trans1;
			}
		}
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( note.noteSecret, id );
		let address 		= await this.getPublicKey(id);
		
		/* await this.createAlert("Mining Status: " + ( this.#isExchangeMarketMining ) );
		await this.createAlert("Secret Status: " + note.noteSecret );
		await this.createAlert("Adress Status: " + ( note.noteAddress == address ) ); */
			
		/* if( ! isNew && address != note.noteAddress ){
			var string 		=  transKey;
			if( ! this.noteSecret )
				this.noteSecret 				= note.noteSecret;
			
			else if( this.noteSecret != note.noteSecret )
				note.noteSecret 		= this.noteSecret;
			
			string 						= this.hashed( string );
			//console.log( "note secret before decrypt", noteSecret, "key: ", string );
			note.noteSecret 			= this.decrypt( noteSecret, string );
		} 
		
		await this.createAlert( "Note Secret Length 2: " + note.noteSecret.length );	
		await this.createAlert( "Note Secret: " + note.noteSecret );	
		
		
		if( ( ! note.noteSecret || note.noteSecret.length != 772 ) && ! isNew ){
			this.errorMessage("A Wrong Trans Key Was Entered. Please Enter a Right Key and Try Again.");
			if( this.alertDetails ){
				if( ! this.keyCounter ){
					this.keyCounter = 1;
				}
				if( this.keyCounter < 4 ){
					this.#passwordKey = await this.createPrompt("The Key Entered For " + note.noteAddress + " Was Wrong. Please Enter The Right Trans Key to Continue Transaction. If you Continue Transactions Without The Right Trans Key, Your Block Will Not Be Verified in The Network");
					this.keyCounter++;
					note.noteSecret = noteSecret;
					return await this.generateScriptbillTransactionBlock(details, note);
				} else {
					await this.createAlert( "Trans Key Error. Note Invalid!!!");
					return false;
				}
			}
		}
		noteSecret 		= note.noteSecret;
		
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( motherKeys[testType], id );
		//console.log( 'Mother Keys: ' + JSON.stringify( motherKeys ) );
		
		if( note.noteSecret != "" && ( ( Object.values(motherKeys).includes( note.noteSecret ) && this.#scriptbankKey != scriptKey ) || (  await this.getPublicKey(id) == note.motherKey && formerBlock && formerBlock.exchangeNote && formerBlock.exchangeNote.exchangeID != note.noteAddress ) ) ){
			this.errorMessage("Cannot Run a Transaction with Keys Registered Under Scriptbank");
			//await this.createAlert("Error Keys");
			return false;
		}		 */
		
				
		var trivKey;
		//await this.createAlert( "checking details 5 " + details.transType );
		//next we try to configure the block IDs of the note
		if( newBlock.blockID && details.transType != "CREATE" && ( newBlock.blockID == note.blockID || block.splitID == note.blockID ) ) {
			//await this.createAlert( details.transType == "MERGE" && note.noteAddress == "" );
			if( details.transType == "MERGE" && note.noteAddress == "" ){
				note.noteSecret 		= await this.generateKey(0, true );
				var id 					= await this.generateKey(10);
				await this.setPrivateKey( note.noteSecret, id );
				note.noteAddress 		= await this.getPublicKey(id);
			}
			
			//await this.createAlert( "is block: " + this.block.blockID );
			//for auto executed block, the next block ID won't be certain because the node executing the block
			//do not have access to the note secret to 
			this.#note 				= JSON.parse( JSON.stringify( note ));
			if( ! this.autoExecute ) {
				//first of all, the new block ids will have to change.
				newBlock.formerBlockID = block.blockID;
				if( block.nextBlockID != "AUTOEXECUTE" ) {
					if( ! block.splitID || note.blockID != block.splitID ){
						newBlock.blockID 		= block.nextBlockID;
						newBlock.nextBlockID 	= await this.calculateNextBlockID(note);
					} else {
						newBlock.formerBlockID 	= block.splitID;
						newBlock.blockID 		= await this.calculateNextBlockID( note, block.splitID );
						newBlock.nextBlockID 	= await this.calculateNextBlockID(note, newBlock.blockID );
					}
				}
				else {
					this.sit 				= "Calculating for " + details.transType;
					newBlock.blockID 		= await this.calculateNextBlockID(note, block.blockID );
					newBlock.nextBlockID 	= await this.calculateNextBlockID(note,  newBlock.blockID);
				}				
			}
			else {
				newBlock.blockID 		= details.nextBlockID;
				newBlock.formerBlockID = details.blockID;
				newBlock.nextBlockID	= "AUTOEXECUTE";
			}
			
			//calculating the wallet hashes.
			var string 					= note.walletID;
			trivKey 					= this.hashed( string );/* 
			secret 						= note.noteSecret;
			note.noteSecret 			= trivKey; */
			var string 					= trivKey;
			trivKey 					= this.hashed( string );
			let walletBlock 			= await this.getCurrentWalletBlock( newBlock );
			newBlock.formerWalletHASH  	= walletBlock.walletHASH;
			newBlock.walletHASH 		= walletBlock.nextWalletHASH;
			newBlock.nextWalletHASH		= await this.calculateNextBlockID( note, newBlock.walletHASH, 1, true );
			
			newBlock.transTime 			= this.currentTime();
			
			/* var string 					= newBlock.exchangeNote.exchangeID;
			trivKey      					= this.hashed( string );
			
			this.sit 						= "Calculating Exchange Note ID";
			let trivTime 					= this.l[trivKey + "_triv_time"];
			
			if( this.l[trivKey] && trivTime && trivTime > newBlock.transTime )
				newBlock.exFormerBlockID 	= this.l[trivKey];
			
			else
				newBlock.exFormerBlockID 	= newBlock.exBlockID;
			
			
			var string 				= newBlock.noteType + newBlock.transTime + newBlock.exchangeNote.exchangeKey;
			newBlock.exBlockID 			= this.hashed( string );	
			//this.seed 					= newBlock.exBlockID;
			//to be set by verifiers.
			newBlock.exNextBlockID 			= "";
			newBlock.exchangeNote.transTime	= newBlock.transTime;
			note.transTime 					= newBlock.transTime;
			//note.noteSecret 				= secret;

			//save the trivkey.
			this.l[trivKey + "_triv_time"] 	= newBlock.transTime;
			this.l[trivKey]					= newBlock.exBlockID; */
			let currentBlock 				= await this.getCurrentExchangeBlock( newBlock );
			
			newBlock.exFormerBlockID 	= currentBlock.exBlockID;
			newBlock.exBlockID 			= currentBlock.exNextBlockID;
			newBlock.exNextBlockID 		= await this.calculateNextBlockID( currentBlock.exchangeNote, newBlock.exBlockID );			
			
			/* if( this.l[trivKey] )
				newBlock.walletHASH 	= this.l[trivKey];
			
			else {
				var string 					= newBlock.walletHASH + note.noteSecret;
				newBlock.walletHASH 			= this.hashed( string );
				this.l[trivKey]					= newBlock.walletHASH;
			} 
			
			var string							= newBlock.walletHASH + note.noteSecret;
			newBlock.nextWalletHASH 		= this.hashed( string );*/
			
			//generating the exBlockIDs
			//note.noteSecret 			= this.block.exchangeNote.exchangeKey;
			//newBlock.exFormerBlockID 		= newBlock.exBlockID;
			//this.seed 						= newBlock.exBlockID;	
			
			//trying to get the current rank code.
			let rankStore;
			var string 			= note.walletID;
			trivKey 			= this.hashed( string );
			
			if( this.l[ trivKey ] )
				rankStore 	= JSON.parse( this.isJsonable( this.l[trivKey] ) ? this.l[trivKey]: '{}' );
				
			else {
				rankStore 	= {};
				rankStore[ note.noteAddress ] = {};
				rankStore[ note.noteAddress ].value = note.noteValue;
				rankStore.value 		= note.noteValue;
			}
			
			
			//await this.createAlert( rankStore.value );
			if( typeof rankStore.loanValue != "number" ){
				rankStore.loanValue = 0;
			}
			if( typeof rankStore.value != "number" ){
				rankStore.value = 0;
			}
			
			
			let rankCodes 	= Object.keys( this.#scriptbillRanks );
			let rank 		= rankCodes[0];
			let value 		= parseFloat( note.noteValue );
			
			if( rankStore ){
				value 		= rankStore.value ? rankStore.value : value;
				
				if( ! rankStore[ note.noteAddress ] )
					rankStore[ note.noteAddress ] = {};
				
				if( rankStore[ note.noteAddress ].value && rankStore[ note.noteAddress ].value < note.noteValue ){
					value 	+= ( note.noteValue - rankStore[ note.noteAddress ].value );
					rankStore[ note.noteAddress ].value = note.noteValue;
					rankStore.value 		= value;
					
				} else if( rankStore[ note.noteAddress ].value && rankStore[ note.noteAddress ].value > note.noteValue ) {
					value 	-= ( rankStore[ note.noteAddress ].value - note.noteValue );					
					rankStore[ note.noteAddress ].value = note.noteValue;
					rankStore.value 		= value;
				} else if( ! rankStore[ note.noteAddress ].value ) {
					rankStore[ note.noteAddress ].value = note.noteValue;
					
					if( rankStore.value ) {
						rankStore.value 	+= parseFloat( note.noteValue );
						value 				= rankStore.value;
					}
				}
			} 
			
			if( ! rankStore.value ) {
				rankStore.value 	= note.noteValue;
				value 				= rankStore.value;
			}
			//await this.createAlert( rankStore.value );
			
			if( rankStore.loanValue  && parseFloat( rankStore.loanValue ) != parseFloat( note.loanValue )){
				note.loanValue = rankStore.loanValue;
				
			} else if( ! rankStore.loanValue && note.loanValue ){
				rankStore.loanValue 	= note.loanValue;
			}
			
			if( this.block.loanValue && this.block.loanValue< rankStore.loanValue )
				rankStore.loanValue 	= this.block.loanValue;
			
			value = parseFloat( value ) - parseFloat( rankStore.loanValue );
			
			if( note.noteType != "SBCRD" ){
				let ex = await this.getExchangeValue( "SBCRD", note.noteType );
				value 	= value / ex[0];			
			}
			
			
			//await this.createAlert( value + " gotten" );
			//check the value to see if the rank has increased.
			if( this.#scriptbillRanks[ rank ].max < value ) {
				//we search for the rank it has increased to.
				let index   = rankCodes.indexOf( rank );
				let rnk;
				
				for( rnk = index; rnk < rankCodes.length; rnk++ ){
					rank 		= rankCodes[rnk];
					
					if( this.#scriptbillRanks[ rank ].max > value ) break;
				}
			}
			//console.log("rank: " + rank, typeof rank);
			var string 			= note.walletRank;
			newBlock.rankCode  = this.encrypt( rank, this.hashed( string ));
			rankStore.rank 			= rank
			rankStore.rankCode 		= rank;
			this.l[ trivKey ]		= JSON.stringify( rankStore );
			//await this.createAlert( rankStore.value + " checking " );
			
		} else {
			//await this.createAlert( "checking details 4 " + details.transType );
			//await this.createAlert( this.#isExchangeMarketMining);
			if( ! this.#isExchangeMarketMining && note.noteValue > 0 ){
				this.errorMessage("The current note is not properly configured to run transactions on the Scriptbill network. We'll be resetting the note to run transactions on the Scriptbill network with a CREATE transaction type. ");
				note.noteValue 			= 0;
				note.transType 			= "CREATE";
				details.transType 		= "CREATE";
				details.transValue 		= 0;
				details.recipient 		= "";
				note.noteAddress 		= "";
				note.noteKey 			= "";
				note.transKey 			= "";
			}
			if( ! this.#isExchangeMarketMining && note.noteValue == 0 ){
				if( note.noteAddress == "" ){
					
					//await this.createAlert("generating note addresses")
					privKey 			= await this.generateKey(50, true );
					//console.log( 'Setting Note\'this.s Private Key: ' + privKey );
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					note.noteAddress = await this.getPublicKey(id);
					note.noteSecret = await this.getPrivateKey(id);
					newBlock.transValue 	= 0;
					newBlock.transType 	= "CREATE";
					this.s.noteSecret = note.noteSecret;
				}
				
				//console.log( "response: " + JSON.stringify( response ) );
				//return false;
				
				//getting the governmental budget ID.
				if( ( ! response || ( response.transType != "CREATEBUDGET" && response.transType != "UPDATEBUDGET" ) || ! response.budgetID ) ){
					this.noteTypeS 	= note.noteType;
					let data 		= await this.getTransBlock();
					
					if( data.length && data[0].budgetID ){
						newBlock.budgetID 	= data[0].budgetID;
						response 				= data[0];
					}
				} else {
					newBlock.budgetID 	= response.budgetID;
				}
				
				
				
				if( ! newBlock.budgetID && currentNote && currentNote.budgetID )
					newBlock.budgetID = currentNote.budgetID;
				
				//console.log(newBlock.budgetID, response.budgetID);
				//await this.createAlert(details.transType);				
							
				if( ( ! newBlock.budgetID || ( response && newBlock.budgetID != response.budgetID ) ) && details.transType != "CREATEBUDGET" && details.transType != "UPDATEBUDGET" ){
					this.errorMessage("No Governmental Budget Available to Create Your Scriptbill Note On.");
					if( ! this.countError )
						this.countError = 1;
					else 
						this.countError++;
					
					if( this.countError > 3 ){
						return false;
					}
					
					if( this.#fiatCurrencies[testType] ){
						this.successMessage("Recreating Your Scriptbill Note Appropraitely");
						let budgetNote = await this.getData(['note', 'type'], ['true', testType], this.#default_scriptbill_server);
						
						if( budgetNote && budgetNote.noteAddress && budgetNote.budget){
							this.budgetConfig 	= JSON.parse( JSON.stringify( budgetNote.budget ) );
							delete budgetNote.budget;
							let note 			= JSON.parse( JSON.stringify( note ) );
							note 			= JSON.parse( JSON.stringify( budgetNote ) );
							
							newBlock		= await this.createScriptbillBudget(this.budgetConfig, note );
							//console.log( newBlock, JSON.stringify( newBlock ));
							//await this.createAlert("Check Budget 2");
							note 			= note;
							
							if( ! newBlock ){
								this.errorMessage("Budget Not Created");
								return false;
							}
						} else {
							this.budgetConfig.value = 1;
							this.budgetConfig.name 	= note.noteType + " Credit";
							newBlock			= await this.createScriptbillBudget(this.budgetConfig, note );
							//console.log( newBlock, JSON.stringify( newBlock ));
							//await this.createAlert("Check Budget 3");
							if( ! newBlock ){
								this.errorMessage("Budget Not Created");
								return false;
							}
						} 						
					} else if( newBlock.exchangeNote && newBlock.exchangeNote.budgetID ){
						newBlock.budgetID 		= newBlock.exchangeNote.budgetID;
					} else {
						//await this.createAlert("Budget Error");
						return false;
					}
				}
				
				if( ! note.noteKey )
					note.noteKey = await this.generateKey(15);
				
				if( ! note.walletRank ) {
					note.walletRank = await this.generateKey( 30 );//30 bytes
					
					//trying to get the current rank code.
					var string 		= note.walletID;
					trivKey 			= this.hashed( string );
					let rank 		= Object.keys( this.#scriptbillRanks )[0];
					let rankStore;
					//checking this key.
					if( this.l[ trivKey ] ){
						rankStore	= JSON.parse( this.isJsonable( this.l[trivKey] ) ? this.l[trivKey]: '{}' );
						rank 		= rankStore.rank;
					} else {
						rankStore = {};
						rankStore.rank 	= rank;
						rankStore.value = 0;
						rankStore.loanValue = 0;
						this.l[ trivKey ] = JSON.stringify( rankStore );
					}
					//console.log("rank: " + rank, typeof rank );
					var string 			= note.walletRank;
					newBlock.rankCode  = this.encrypt( rank, this.hashed( string ) );
					
					if( rankStore.loanValue ){
						note.loanValue 	= rankStore.loanValue;
					}
					
					if( rankStore.value ){
						note.rankValue 	= rankStore.value;
					}
				}
			}
			
			//console.log("current note type: " + note.noteType );
			//if creating a new note, the note type should be pre set by the requester, however to avoid user error we 
			//check for errors in the note type and correct them here.			
			if( ! await this.testNoteType("CRD", note) && ! await this.testNoteType("STK", note) && ! await this.testNoteType("BND", note) ){
				//console.log("changing note type...");
				note.noteType = "SBCRD";
			}
			
			
			//if the note type is not a Scriptbill Credit or Bond, we charge a gas fee for creating new credit within the 
			//system. The gas fee is used to guarantee the running of the Scriptbill Credit within the network, and used to
			//tie relationships of the credit with Scriptbills. It increases as the Credit is being used in the network.
			//the remaining gas fee will be charged during exchange.
			else if( note.noteType != "SBCRD" && note.noteType != "SBBND" && note.noteType != "SBSTK" && ! this.#fiatCurrencies[ note.noteType.slice( 0, note.noteType.lastIndexOf("CRD") ) ] && ! this.#fiatCurrencies[ note.noteType.slice( 0, note.noteType.lastIndexOf("BND") ) ]) {
				//console.log("charging gas>>>>");
				//let'this.s see if the credit has gas.
				this.noteTypeS = note.noteType;
				let transBlocks = await this.getTransBlock(), block = {};
				
				/* //console.log("transBlocks ", transBlocks, JSON.stringify( transBlocks ) );
				await this.createAlert( transBlocks.length ); */
				
				if( transBlocks && transBlocks.length > 0 ){
					block = transBlocks[ transBlocks.length - 1 ];
					newBlock 			= JSON.parse( JSON.stringify( block ) );
					newBlock.formerBlockID = newBlock.blockID;
					this.sit 				= "Calculating Block ID For new Block When Type Block Is Found";
					newBlock.blockID 		= await this.calculateNextBlockID(note, newBlock.blockID);
					newBlock.nextBlockID	= await this.calculateNextBlockID(note, newBlock.blockID);
					newBlock.transType     = "CREATE";
					newBlock.transValue 	= 0;
					newBlock.noteValue 	= 0;
				}
				else if( transBlocks.length <= 0 && ( details.transType == "CREATEBUDGET" && details.agreement && details.agreement.budgetType != "governmental" ) ) {
					//we create an exchange note for the note.
					if( note.creditType == "fiat" || note.creditType == "scriptbill" ){	
						
						newBlock.exchangeNote	= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
						if( note.creditType == "scriptbill" && ! this.#fiatCurrencies[ testType ] )
							privKey 				= await this.generateKey( 50, true );
						else if( note.creditType == "fiat" && this.#fiatCurrencies[ testType ] )
							privKey 				= motherKeys.noteAddresses[note.noteType];
						
						newBlock.exchangeNote.exchangeKey = privKey;
						var id 					= await this.generateKey(10);
						await this.setPrivateKey( privKey, id );
						newBlock.exchangeNote.exchangeID 	= await this.getPublicKey(id);
						delete newBlock.exchangeNote.noteAddress;
						delete newBlock.exchangeNote.noteSecret;
						newBlock.exchangeNote.noteType = note.noteType;
						newBlock.exchangeNote.walletID 	= await this.generateKey(40);
						
						//configuring the budget
						if( this.#fiatCurrencies[ testType ] )
							this.budgetConfig.name = this.#fiatCurrencies[ testType ] + "Scriptbill Credit";
						
						else
							this.budgetConfig.name 	= "Scriptbill " + testType;
						
						this.budgetConfig.value 		= Infinity;
						this.budgetConfig.max_exec 		= "Anytime";
						this.budgetConfig.budgetType 	= "governmental";
						this.budgetConfig.orientation 	= "recursive";
						this.budgetConfig.budgetCredit 	= testType;
						this.budgetConfig.stockID 		= note.noteType;
						
						newBlock.transType 		= "CREATEBUDGET";						
						note.transType 			= "CREATEBUDGET";
						details.transType 		= "CREATEBUDGET";
						transType 				= "CREATEBUDGET";
						
						
						if( note.creditType == "fiat" || this.#fiatCurrencies[ testType ] || motherKeys[ testType ] ){
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( motherKeys[ testType ], id );
							newBlock.exchangeNote.motherKey = await this.getPublicKey(id);
						}
						else
							newBlock.exchangeNote.motherKey = note.noteAddress;
						
						this.budgetConfig.agreement 	= JSON.parse( JSON.stringify( details.agreement ) );
						details.agreement 			= JSON.parse( JSON.stringify( this.budgetConfig ) );
						
					}
					let secret = note.noteSecret;
					note.noteSecret	= note.walletID;
					newBlock.formerWalletHASH = newBlock.blockID;
					this.sit 			= "Calculating Wallet Hashes ";
					newBlock.walletHASH = await this.calculateNextBlockID(note, newBlock.blockID);
					newBlock.nextWalletHASH = await this.calculateNextBlockID(note, newBlock.walletHASH);
				}
				
				//custom credit blocks must have a GAS handler from which their network is being gassed
				//the gas will be deducted per transaction byte space in the network from each transaction.
				//once the gas is exhusted, no transaction from the credit will be made.
				if( ! block.GAS )
					block.GAS = 0;
				
				//console.log( "current note: " + currentNote, "stringified: " + JSON.stringify( currentNote ) );
				
				//to create a new note, the GAS level must be upto 1
				if( ( ! currentNote || ( currentNote.noteType != "SBCRD" && currentNote.noteValue < 1 && block.GAS < 1 ) ) && ( currentNote && currentNote.creditType == "scriptbill" ) ){
					this.errorMessage("You Need at Least 1 Scriptbills to Gas Your Credit Network. Please Purchase now");
					return false;
				}	

								
				//gas are only charged from a scriptbill account type not fiat, which is managed by Scriptbank.
				if( currentNote.creditType == "scriptbill" ) {
					//we can charge the said current note, if the GAS level is not equal to 1 to bump up the credit GAS.
					if( block.GAS < 1 ) {
						if( currentNote && currentNote.noteValue >= 1 ) {							
							note 	= currentNote;
							this.details		=  JSON.parse( JSON.stringify( details ));
							this.details.transType = "GAS";
							this.details.transValue = 1;
							//no recipient, the credit is burned of.
							this.newBlock = JSON.parse( JSON.stringify( newBlock ));
							this.generateScriptbillTransactionBlock(this.details);
							newBlock.GAS = block.GAS + 1;
						}
						else if( block.GAS > 0 ){
							//scriptbill charges 0.0000001 Scriptbill per Byte a Transaction Block contains an average of 
							//500Bytes of Data so total fee must be equal to 0.00005 Scriptbills to run this function.
							if( block.GAS < 0.00005 ){
								this.errorMessage("Your Custom credit GAS is not enough to GAS your transaction, please purchase a Scriptbill now to try again!!!");
								return false;
							}
						} else {
							this.errorMessage("Your Custom credit GAS is not enough to GAS your transaction, please purchase a Scriptbill now to try again!!!");
							return false;
						}
					}
					else {
						newBlock.GAS = block.GAS;
					}
				}
				
			}
			
			//console.log("current note type 2: " + note.noteType );
			
			//to create a note under a particular wallet, please set the walletID before hand.
			if( this.walletID == "" ){
				this.walletID = await this.generateKey(20);
			}
			
			note.walletID 			= this.walletID;
			
			//no former block found. the transaction will be turned into a create note transaction sorry.
			var string 					= this.currentTime();
			this.seed						= this.hashed( string );
			newBlock.formerBlockID 	= this.seed;
			this.sit 					= "Calculating Next Block ID For New Block ";
			newBlock.blockID 			= await this.calculateNextBlockID(note, newBlock.formerBlockID);
			newBlock.nextBlockID		= await this.calculateNextBlockID(note, newBlock.blockID);
			
			//console.log( "the block IDs: ", "blockID: " + newBlock.blockID, "former: " +newBlock.formerBlockID, "next: " + newBlock.nextBlockID);
			
			//these are transaction types that don't require a former block.
			//the are called the auto confirmed transaction.
			//a DEPOSIT transaction is auto confirmed because Scriptbill network is not
			//directly involve with it. The value involved is to be confirmed by the 
			//withdrawer not Scriptbills.
			
			if( ( details.transType != "DEPOSIT" && ( details.transType == "CREATEBUDGET" && details.agreement && details.agreement.budgetID && details.agreement.budgetType != "governmental" ) ) && this.l[note.noteAddress] == undefined ) {
				//await this.createAlert("something cr");
				let formerTrans 				= details.transType;
				let formerValue 				= details.transValue;
				details.transType 			= "CREATE";
				transType 					= "CREATE";
				details.transValue			= 0;
				details.noteValue 			= 0;
				this.errorMessage("Transaction now forced to be a CREATE transaction type because no former block found, You will have to reinitiate your previous transaction after this. Your Former Transaction Type is: " + formerTrans + " and Former Trans Value " + formerValue +". This may also affect the value of your current note.");
			} else if( this.l[note.noteAddress] ){
				//await this.createAlert("something tr");
				let blocks = await  this.getNoteTransactions();
				formerBlock = blocks[ blocks.length - 1 ];
			}
			
			//await this.createAlert("something");
				
			//console.log("current note type 3: " + note.noteType );
			
			//the server used to create the note remains the orginal server but it must be a Scriptbill Server.
			let server = window.location.origin;
			server = server.toString();
			
			//for now, Scriptbill runs on an http server.
			if( ! server.includes('https') )
				note.noteServer = this.#default_scriptbill_server + note.noteAddress.slice(0,24).replaceAll('/', '' );
			
			else {
				let resp = await this.getData('scriptbillPing', 'TRUE', server );
						
				if( resp && resp.isScriptbillServer && resp.isScriptbillServer == 'TRUE' ) {
					note.noteServer = server + "/" + note.noteAddress.slice(0,24).replaceAll('/', '' );
				}
				else {
					note.noteServer = this.#default_scriptbill_server + note.noteAddress.slice(0,24).replaceAll('/', '' );
				}
			}
			
			newBlock.noteServer = note.noteServer;
		}
		
		
		//before doing anything, let'this.s add verification values to the current block
		//adding the current note value to the noteBlock
		newBlock.noteValue			= note.noteValue;
		newBlock.noteID				= note.noteID;
		
		

		//calculate the next note ID.
		note.noteID 				= CryptoJS.MD5( note.noteID + note.noteKey ).toString( CryptoJS.enc.Base64 );
		
		//the agreement must be in the required format for it to work, else we revert to the default agreement.
		if( ( ! details.agreement || typeof details.agreement != 'object' || details.agreement.isPeriodic == undefined || details.agreement.times == undefined || details.agreement.payTime == undefined || details.agreement.payPeriod == undefined || details.agreement.delayInterest == undefined ) && this.#transSend.includes( details.transType ) && ! details.transType == "ADVERT" ){
			details.agreement = await this.createAgreement("", newBlock );
			note.agreements.push( {agreeID: details.agreement.agreeID, key: details.agreement.privateKey, signKey: details.agreement.senderSignKey } );
			delete details.agreement.privateKey;
			delete details.agreement.senderSignKey;
			this.isCreatedID 		= details.agreement.agreeID;
		}
		
		
		
		//now testing the former block to see if it was a send block to see if the block's private key must be 
		//kept until agreement connected to it is fulfilled before forgoing the blockKey connected to it.
		if( this.#transSend.includes( newBlock.transType ) || newBlock.transType == "WITHDRAW" || newBlock.transType == "SPLIT"|| newBlock.transType == "AGREEMENTREQUEST" ) {
			let agreementKey 		= note.blockKey;
			var id 					= await this.generateKey(10);
			await this.setPrivateKey( agreementKey, id );
			let publicKey 			= await this.getPublicKey(id,true);
			
			if( publicKey == newBlock.blockKey ){
				//check if the agreement connected to this block is fulfilled.
				if( ! note.unfulfilled || typeof note.unfulfilled != "object" )
					note.unfulfilled = {};
				
				if( ! Object.values( note.unfulfilled ).includes( agreementKey ) ){
					if( newBlock.transType != "AGREEMENTREQUEST" )
						note.unfulfilled[ note.blockID ] =  agreementKey;
					else
						note.unfulfilled[ newBlock.agreement.agreeID ] =  agreementKey;
				}
			}
		}
		
		//treating each note based on type and transaction type.
		//this treats tranasction that can only be handled by a credit note type.
		if( await this.testNoteType("CRD", note) ){
			//credit note types have send transactions
			//recieve transaction based on Investment will be handled differently.
			if( this.#transSend.includes( details.transType ) && details.transType != "INVESTRECIEVE" && details.transType != "PENDING" && ( details.transType != "AGREESEND" || ( details.transType == "AGREESEND" && this.#agreeBlock && this.#agreeBlock.blockID == block.blockID ) ) ){		
				
				//since some transaction will have a lot to do with the exchange note
				//we get the exchange note on ground.
				currentNote				= await this.getCurrentExchangeNote( note.noteType );
				
				//first we check the agreement on the details.
				//the user should have a pre configured agreement on the details.agreement handler
				//this will help the transaction structure itself the way the suer wants it.
				if( details.agreement && details.transType != "INTERESTPAY" ){
					//signing the timeStamp of the agreement.
					/* let currentTime = this.currentTime();
					this.signTxt 	= currentTime;
					this.signKey  	= await this.generateKey(10, true, true );			
					details.agreement.agreeSign = await this.Sign();
					details.agreement.agreeID = await this.getPublicKey(true); */
					
					let agreeID 				= "";
					
					if( details.agreement.agreeID )
						agreeID 				= details.agreement.agreeID;
					
					if( ! this.isCreatedID ){
						details.agreement 			= await this.createAgreement( agreeID, newBlock );
						
						if( ! note.agreements || typeof note.agreements != "object" )
							note.agreements = [];
						
						note.agreements.push( {agreeID:details.agreement.agreeID, key:details.agreement.privateKey, signKey: details.agreement.senderSignKey } );
						delete details.agreement.privateKey;
						delete details.agreement.senderSignKey;
					}
				} else if( ! details.agreement ){
					details.agreement 		= await this.createAgreement("", newBlock);
					
					if( ! note.agreements || typeof note.agreements != "object" )
							note.agreements = [];
						
					note.agreements.push( {agreeID:details.agreement.agreeID, key:details.agreement.privateKey, signKey: details.agreement.senderSignKey } );
					delete details.agreement.privateKey;
					delete details.agreement.senderSignKey;
				}		
				
				let agreement 	= JSON.parse( JSON.stringify( details.agreement));
				
				/* //console.log( "send agreement" + JSON.stringify( agreement ) );
				await this.createAlert( "check send agreement" ); */
				
				
				//ensuring that a non product transaction does not contain the product details
				if( newBlock.productID && ( details.transType != "BUYPRODUCT" || details.transType != "PRODUCTSUB" ) ){
					delete newBlock.productID;
					delete newBlock.productBlockID;
					delete newBlock.productNextBlockID;
					delete newBlock.productFormerBlockID;
					delete newBlock.agreement;
				}
				
				//ensuring a non exchange transaction does not contain budget details.
				/* if( newBlock.budgetID && ( details.transType != "BUYSTOCK" || details.transType != "BUYBOND"  || details.transType != "STOCKPAY" || details.transType != "BONDPAY" ) ){
					delete newBlock.budgetID;
					//the agreement of a send block is always 
					//hidden in the recipient handler.
					//transactions whose agreement must be seen
					//should not be a send transaction but in 
					//the otherTrans handler. The WITHDRAW 
					//transaction not directed to a recipient 
					//should be handled in the otherTrans 
					//handler.
					delete newBlock.agreement;
				} */
				
				if( details.transType == "SEND" && note.loanValue > note.noteValue ){
					this.errorMessage("Your Note is not eligible to send money but you can still particpate in a product puchase transaction.");
					return false;
				} 
				
				//this is what happens when the transaction value is greater than the note value.
				//we use this to impletment the crediting principle in Scriptbills
				//so Scriptbills user don't need to apply to get credit, they simply run their transactions and credit
				//is approved for them.
				/* //console.log( details.transValue );
				alert( "Check Trans Value" );
				//console.log( note.noteValue );
				//console.log(details.transValue > note.noteValue, ! this.#isExchangeMarketMining, !( this.#agreeBlock && details.transType == "AGREESEND" ));
				alert( "Check Note Value" ); */
				if( details.transValue > note.noteValue && ! this.#isExchangeMarketMining && !( this.#agreeBlock && details.transType == "AGREESEND" )) {
					//console.log("Trans Greater");
					let productBlock;
					let noteVal		= parseFloat( note.noteValue );
					if( details.productID && ( details.transType == "BUYPRODUCT" || details.transType == "PRODUCTSUB" ) ){
						
						if( details.productBlockID ){
							this.productBlockID 	= details.productBlockID;
							productBlock 			= await this.getTransBlock();
							productBlock 			= productBlock[0];
						} else {
							productBlock 	= await this.getTransBlock(10, {productID: details.productID});
							this.noRequest 	= true;
							productBlock 	= await this.getCurrentBlock( productBlock );
						}
						
						//credit transactions are only valid for product based transactions.
						if( productBlock && productBlock.productID ){
							//get the user ranking
							let userRank = newBlock.rankCode;
							let rankCredit = 100;
							let rank;
							
							if( note.walletRank ) {
								var string 		= note.walletRank;
								userRank 			= this.decrypt( userRank, this.hashed( string ) );
								rank				= this.#scriptbillRanks[ userRank ];
								
								if( rank && rank.code == userRank ) {
									rankCredit 	= rank.credit_level;
								}
							}
							
							//arrange to set up the loan balance of the recipient
							this.account = await this.getAccountData();
				
							if( ! this.account )
								this.account = {};
							
							if( ! this.account.loanValue ){
								if( this.account[ note.noteAddress ].loanValue )
									this.account.loanValue 	= parseFloat( this.account[ note.noteAddress ].loanValue );
								
								else if( note.loanValue )
									this.account.loanValue = parseFloat( note.loanValue );
								
								else
									this.account.loanValue = 0;
							}
							
							let remCredit 		= noteVal - parseFloat( details.transValue );
							noteVal          	+= rankCredit;
							noteVal 			-= this.account.loanValue;
							
							if( noteVal <= 0 ){								
								this.errorMessage("Your Transaction Could Not Be Completed Because Your Note Value Is Not enough and You Have Reached Your Maximum Credit Level. Buy more Scriptbill Bonds To Get A Higher Credit Level.");
								return false;
							} else {
								
								if( details.transValue > noteVal ){
									details.transValue 	= noteVal;
									details.transType 	= "PRODUCTSUB";
									transType 			= "PRODUCTSUB";
								}
								
								//if the transaction is true, then the user gets loan
								//automatically to settle his transaction. We may NOT
								//create a loan transaction but we will update the loan
								//value of the user on the remaining value.
								if( ! currrentNote && ! newBlock.exchangeNote ){
									this.errorMessage("We couldn't retrieve the exchange note to your note type!");
									return false;
								} 
								else if( ! currentNote && newBlock.exchangeNote )
									currentNote 		= JSON.parse( JSON.stringify( newBlock.exchangeNote ));
								
								if( ! currentNote.demandValue )
									currentNote.demandValue = 0;
								
								if( ! currentNote.exchangeValue )
									currentNote.exchangeValue = 0;
								
								if( currentNote.exchangeValue < remCredit )
									currentNote.demandValue 	= parseFloat( currrentNote.demandValue ) + parseFloat( remCredit );
								
								else
									currentNote.exchangeValue 	= parseFloat( currrentNote.exchangeValue ) - parseFloat( remCredit );
								
								newBlock.exchangeNote 		= JSON.parse( JSON.stringify( currentNote ));				
								
								
								if( ( this.account.loanID && this.account.loanID != "v/ylMo3bvINarUq89+AZBg==" ) || ( note.accountData && note.accountData.loanID ) ){
									this.blockID = this.account.loanID || note.accountData.loanID;
									let loanBlock = await this.getTransBlock();
									loanBlock 	= loanBlock[0];
									
									if( loanBlock && loanBlock.loanValue )
										this.account.loanValue = loanBlock.loanValue; 
									else {
										this.errorMessage("Fraudulent Loan Account Detected");
										return false;
									}
								}
								
								this.account.loanValue 		+= parseFloat( remCredit );
								this.account.loanID 		= newBlock.blockID;
								newBlock.loanValue 			= this.account.loanValue;
								note.accountData 		= this.account[ note.noteAddress ];
								note.accountData.loanID 			= this.account.loanID;
								note.accountData.loanValue 		= newBlock.loanValue;
								
								var string 	= note.walletID;
								trivKey 		= this.hashed( string );
								
								localStorage[trivKey] 		= JSON.stringify( this.account );
								
								
								if( ! note.loanValue )
									note.loanValue = 0;
								
								note.loanValue += parseFloat( details.transValue );
								
							}
							
							
						}
						else {
							this.errorMessage( "Transaction Can't Be Completed, Because Your Note Value is Too Low! Please Acquire More Scriptbills To Continue." );
							return false;
							
						}
					}
					else {
						
						if( details.transType == "ADVERT" && note.budgetID ){
							
							var id = await this.generateKey(10);
							await this.setPrivateKey( note.budgetID, id );
							let pubKeyd = await this.getPublicKey(id);
							let budgetBlock 	= await this.getCurrentBudgetBlock( pubKeyd );
							
							if( budgetBlock && budgetBlock.agreement && budgetBlock.agreement.stockID ){
								let productNote 	= await this.getCurrentExchangeNote( budgetBlock.agreement.stockID );
								
								if( productNote && productNote.exchangeValue > details.transValue ){
									this.#isExchangeMarketMining = true;
									this.productNote 			= JSON.parse( JSON.stringify( productNote ));
								} else {
									this.errorMessage( "Transaction Can't Be Completed, Because Your Note Value is Too Low! Please Acquire More Scriptbills To Continue." );
									return false;
								}
							} else {
								this.errorMessage( "Transaction Can't Be Completed, Because Your Note Value is Too Low! Please Acquire More Scriptbills To Continue." );
								return false;
							}
						
						} else {
							//console.log("No Product ID in the request...");
							this.errorMessage( "Transaction Can't Be Completed, Because Your Note Value is Too Low! Please Acquire More Scriptbills To Continue." );
							return false;
						}
					}
				}
				
				if( details.transType == "WITHDRAW" && ! details.withdrawAccount ){
					this.errorMessage("No withdraw account set in your withdrawal request");
					return false;
				}

				if( details.transType == "WITHDRAW" && details.withdrawAccount ){
					//checking the agreements on the note. Note can't withdraw if there
					//is loan on the agreement.
					let agreeID, run = parseFloat( details.transValue ), noteValue = parseFloat( note.noteValue );
					let agreements = newBlock.agreements, agrees, blk;
					//console.log("Withdrawing Credit" );
					
					
					for( agreeID in agreements ){
						blk 				= await this.getTransBlock(1, {blockID:agreements[agreeID]});
						
						if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )
							agrees 		= JSON.parse( JSON.stringify( blk[0].agreement ));
						
						else 
							agrees 		= {};
						
						if( ! agrees[agreeID] || agrees[agreeID].agreeType != "LOAN" || agrees[agreeID].agreeType != "DEPOSIT" ) continue;
						
						if( run == 0 ) break;
						
						run 	-= isNaN(parseFloat(agrees[agreeID].value))?0:parseFloat(agrees[agreeID].value);
					}
					
					if( note.noteValue < run || run == 0 ){
						this.errorMessage("Can't withdraw credit that your note didn't have.");
						return false;
					}
					else if( run < details.transValue ){
						await this.createAlert("You can't run the withdrawal of the requested amount " + details.transValue + " " + testType + ". But you will run this value as withdrawal: " + run + " " + testType + ". This is majorly as a result of outstanding loan in your account.");
					}
					details.transValue 	= run;
					transValue 			= run;
					note.noteValue 		=  parseFloat( note.noteValue ) - run;
				
					
					//must use the withdrawCredit method to achieve this.
					if( this.#isExchangeDeposit ){
					
						this.#currentNote 		= await this.getCurrentExchangeNote( note.noteType );
						
						if( ! this.#currentNote || parseFloat( this.#currentNote.noteValue ) < run ){
							this.errorMessage("Couldn't find an exchange market for this credit note or the exchange market is not ready to make deposits now.");
							newBlock.isExchangeMarketMining			= 0;
						} else {
						
							if( ! this.#currentNote.exchangeValue ){
								this.#currentNote.exchangeValue 	= 0;
							}
							
							this.#currentNote.exchangeValue 		= parseFloat( this.#currentNote.exchangeValue ) + run;
							this.#currentNote.noteValue 		= parseFloat( this.#currentNote.noteValue ) - run;
							newBlock.exchangeNote 					= JSON.parse( JSON.stringify( this.#currentNote ));
							newBlock.isExchangeMarketMining			= 1;
						}
				
					} else {
						newBlock.isExchangeMarketMining				= 0;
					}
					
					
					newBlock.withdrawAccount = JSON.parse( JSON.stringify( details.withdrawAccount ));
					newBlock.transValue 	 = run;
					newBlock.transType 	= details.transType;
					//any configuration in the agreement that will be different from the 
					//default should be configured using the defaultAgree handler.
					newBlock.agreement 	= await this.createAgreement("", newBlock, true );//the withdrawer must have set his agreement on this handler. 
					
					if( ( ! note.agreements || typeof note.agreements != "object" ) && ! this.#isExchangeDeposit )
						note.agreements = [];
					
					//we will save the key according to the depositors request
					//this will help Scriptbank attend to depositors according 
					//to their request. If the transaction is an auto confirmed
					//transaction, the note will run the agreement sign transaction
					//automatically.
										
					note.agreements.push( {agreeID: newBlock.agreement.agreeID, key: newBlock.agreement.privateKey, signKey: newBlock.agreement.senderSignKey });
					
					if( newBlock.isExchangeMarketMining ){
						newBlock.exchangeNote.agreement = newBlock.agreement.privateKey;
					}
					
					delete newBlock.agreement.privateKey;
					delete newBlock.agreement.senderSignKey;
					
					newBlock.agreement.value 		= parseFloat( details.transValue );
					newBlock.agreement.privateKey 	= await this.generateKey(30, true, true );
					var id 							= await this.generateKey(10);
					await this.setPrivateKey( newBlock.agreement.privateKey, id );			
					
					newBlock.blockRef 			= await this.getPublicKey(id,true);
					newBlock.signRef 			= await this.generateKey(20);
					
					//if the note has a mother key it shows it is a CREDIT
					//note, this means the note can only withdraw to the 
					//note that produced it as a credit.
					if( note.motherKey ){
						this.setPublicKey( note.motherKey );
						var string 				= JSON.stringify( newBlock.agreement );
						newBlock.recipient 	= await this.#encrypt( string );
						delete newBlock.agreement.privateKey;
						newBlock.agreement 	= this.hashed( string );						
					}
					
					if( note.referee ){
						let result = {};
						let accd 	= await this.getAccountData();
						result.loanValue = accd.loanValue;
						newBlock.referer 	= this.encrypt( JSON.stringify( result ), note.referee );			
					}
				}
				
				//we now believe the current note can handle the transaction we continue configuring the transaction block.
				//configuring the invest transaction types.
				 if( ( details.transType == "BUYSTOCK" || details.transType == "BUYBOND" || details.transType == "INTERESTPAY" ) && details.budgetID ){					
					
					let budgetBlock 	= await this.getCurrentBudgetBlock( details.budgetID );
					
					if( ! budgetBlock ){
						this.errorMessage("You " + this.walletID + " are Trying to Invest on a Budget That Does Not Exist. You Can As Well Contact The Company or Organization That Gave You This ID " + details.budgetID + " To Confirm And Try Again!!!");
						return false;
					}
					
					if( ! budgetBlock.agreement ) {
						this.errorMessage("You " + this.walletID + " are Trying to Invest on a Budget That Does Not Have a Valid Budget Data. You Can As Well Contact The Company That Gave You This ID " + details.budgetID + " To Confirm And Try Again!!!");
						return false;
					}
					
					let budget = budgetBlock.agreement;
					let pouch  = budget.investorsHub;					
					
					//testing the note credits.
					if( budget.budgetCredit != note.noteType ){
						//return false;
						let exValues 	= await this.getExchangeValue( budget.budgetCredit, note.noteType );
						details.transValue = parseFloat( details.transValue ) * parseFloat( exValues[1] );
					}
					
					//an investor cannot invest on a budget with a credit investment.
					//he must possess the value of the credit before investment
					if( note.noteValue >= details.transValue )
						newBlock.transValue = details.transValue;
										
					else {
						this.errorMessage("You " + this.walletID + " Do Not Have Sufficient Credit to Buy this Stock With ID: "+budget.stockID+".");
						return false;
					}
					
					if( ! currentNote || currentNote.noteType != note.noteType || ! currentNote.demandValue ){
						currentNote 			= await this.getCurrentExchangeNote( note.noteType );
					}
					
					if( ! currentNote ){
						this.errorMessage("Exchange Note not found while procssing the request");
						return false;
					}
					
					if( (( details.recipient && details.recipient != currentNote.exchangeID ) || ! details.recipient ) && details.transType == "INTERESTPAY" )
						details.recipient = currentNote.exchangeID;
					
					else if( details.transType == "BUYBOND" && ( ! response ||  response.transType != "SELLBOND" || details.recipient != response.blockKey  ) ){
						try{
							details.recipient 	= currentNote.budgetID;
						} catch(e){
							this.errorMessage( "Exchange Market Do Not Exist" );
							console.error(e);
							return false;
						}
					}
					else if( response && response.transType == "SELLBOND" && details.transType == "BUYBOND" && details.transValue == response.transValue && response.agreement && response.agreement.agreeKey ){
						details.recipient 			= response.agreement.agreeKey;
					}
					
					if( details.transType == "INTERESTPAY" ){					
						
						let agrees 					= await this.getNoteAgreements();
						let agreeKeys 				= Object.keys( agrees );				
						
						if( ! agreeKeys.includes( details.agreement.agreeID ) ) {
							this.errorMessage( "Agreement Not Found on Note's Block: " + this.block.blockID + ", Agreement ID: " + details.agreement.agreeID );
							//await this.createAlert( "checking transType: " + details.transType );
							return false;
						}
						agreement = JSON.parse( JSON.stringify( details.agreement ) );
						let accountData = await this.getAccountData();		
						
						if( accountData.loanID ){
							let tranBlock = await this.getTransBlock(1, {blockID:accountData.loanID});
							tranBlock 	= tranBlock[0];
							
							if( tranBlock && tranBlock.loanValue ){
								accountData.loanValue = tranBlock.loanValue;
							}
						}

						currentNote.agreement 		= await this.generateKey(10, true, true);
						var id 						= await this.generateKey(10);
						await this.setPrivateKey( currentNote.agreement, id );
						
						if( newBlock.agreements[ agreement.agreeID ] )
							delete newBlock.agreements[ agreement.agreeID ];
						
						agreement.agreeID 			= await this.getPublicKey(id, true);
						details.recipient 			= agreement.agreeID;
						
						accountData.loanValue  = parseFloat( accountData.loanValue ) - parseFloat( details.transValue );
						note.loanValue = accountData.loanValue;
						accountData.loanID 	= newBlock.blockID;
						newBlock.loanValue = parseFloat( accountData.loanValue ).toFixed(2);		
						note.accountData 	= accountData;
						agreement.payTime 	= parseInt( this.currentTime() ) + parseInt( this.calculateTime( agreement.payPeriod.lastIndexOf('s') == agreement.payPeriod.length ? agreement.payPeriod: "1 weeks"  ) );
						newBlock.agreement 						= JSON.parse( JSON.stringify( agreement ));
						newBlock.agreements[ agreement.agreeID ] = newBlock.blockID;

						//if the currentNote is active, we automatically add the
						//credit to the current exchange note account
						if( currentNote ){
							
							//when people are buying bonds the credit the exchange value of
							//the exchange market that stands for the credit supplied to 
							//the exchange market.
							if( ! currentNote.exchangeValue )
								currentNote.exchangeValue = 0;
							
							currentNote.exchangeValue = parseFloat( currentNote.exchangeValue ) + parseFloat( details.transValue );
							
							//ensuring the current note is the current exchange note for the wallet.
							if( motherKeys.noteAddresses[ testType ] && currentNote.exchangeKey && currentNote.exchangeKey != motherKeys.noteAddresses[ testType ] ){
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( motherKeys.noteAddresses[ testType ], id );
								currentNote.exchangeID 	= await this.getPublicKey(id);
								currentNote.exchangeKey 	= await this.getPrivateKey(id);
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( motherKeys.budgetIDS[ testType ], id );
								currentNote.budgetID 		= await this.getPublicKey(id);
							}
							
							newBlock.exchangeNote 		= JSON.parse( JSON.stringify( currentNote ));
						}
										
					}
					
										
					//updating the exchangeNote if the budget is a-z
					//givernmental budget.
					if( budget.agreement.budgetType == "governmental" && details.transType != "INTERESTPAY" ){
						//Forcing the transaction type since the budget 
						//is a governmental budget.
						newBlock.transType = "BUYBOND";
						
						if( ! newBlock.exchangeNote ) {
							newBlock.exchangeNote = JSON.parse( JSON.stringify( this.defaultScriptbill ) );
							newBlock.exchangeNote.noteType = note.noteType;
						}
						
						//checking the currentNote
						//ensuring the current note is the current exchange note for the wallet.
						if( motherKeys.noteAddresses[ testType ] && currentNote.exchangeKey && currentNote.exchangeKey != motherKeys.noteAddresses[ testType ] ){
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( motherKeys.noteAddresses[ testType ], id );
							currentNote.exchangeID 	= await this.getPublicKey(id);
							currentNote.exchangeKey 	= await this.getPrivateKey(id);
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( motherKeys.budgetIDS[ testType ], id );
							currentNote.budgetID 		= await this.getPublicKey(id);
						}
						
						if( ! response || response.transType != "SELLBOND" )						
							details.recipient = currentNote.noteAddress;
						else
							details.recipient 	= response.blockKey;
						
						budget.agreement 		= JSON.parse( JSON.stringify( budget.agreement ));
						
						newBlock.exchangeNote 	= JSON.parse( JSON.stringify( currentNote ));
						
						if( ! newBlock.exchangeNote.exchangeValue )
							newBlock.exchangeNote.exchangeValue = 0;
						
						newBlock.exchangeNote.exchangeValue 		= parseFloat( newBlock.exchangeNote.exchangeValue ) + parseFloat( details.transValue );
						
					} else if( budget.agreement.budgetType == "business" && details.transType != "INTERESTPAY" ){
						if( budgetBlock.productNote && ( ! currentNote || currentNote.noteAddress != budgetBlock.productNote.exchangeID ) ){
							currentNote = JSON.parse( JSON.stringify( budgetBlock.productNote ) );
							currentNote.noteAddress = budgetBlock.productNote.exchangeID;
							currentNote.noteSecret = budgetBlock.productNote.exchangeKey;
						}
						
						details.recipient 		= currentNote.noteAddress;
						budget.agreement 		= JSON.parse( JSON.stringify( budget.agreement ));
						newBlock.productNote 	= JSON.parse( JSON.stringify( currentNote ));
						
						if( ! newBlock.productNote.exchangeValue )
							newBlock.productNote.exchangeValue = 0;
						
						newBlock.productNote.exchangeValue 		= parseFloat( newBlock.productNote.exchangeValue ) + parseFloat( details.transValue );
					}
					
					 

					agreement 		= JSON.parse( JSON.stringify( budget ));
					
				}
				else if( details.productID && ( details.transType == "BUYPRODUCT" || details.transType == "PRODUCTSUB" ) ) {				
					
					//let'this.s be sure of the product blocks.
					/* this.productBlock		= this.getCurrentProductBlock( details.productID );
					
					//we check if any valid data was returned
					if( ! this.productBlock ) {
						this.errorMessage("Product you seek to buy was not found on the Transactional database of Scriptbill. Please check the Product ID and Try again!!!");
						return false;
					}
					
					agreement 			= this.productBlock.agreement; */					
					//agreement 			= this.getCurrentProductAgreement(details.productID);
					agreement 			= details.agreement;
					this.productID 		= details.productID;
					this.transTime 		= this.currentTime().toString() + " <=";
					let productBlock 	= await this.getTransBlock();
					let productNote		= false;
					
					if( productBlock.length && productBlock[0].agreement && (( productBlock[0].agreement.productConfig && productBlock[0].agreement.productConfig.stockID ) || productBlock[0].agreement.stockID ) ) {
						productBlock 	= await this.getCurrentBlock( productBlock );
						productNote  	= await this.getCurrentExchangeNote( productBlock.agreement.productConfig.stockID || productBlock.agreement.stockID );
						agreement 		= productBlock.agreement;
						
						if( ! productNote && productBlock.productNote )
							productNote 		= JSON.parse( JSON.stringify( productBlock.productNote ));
						
						else if( ! productNote ){
							this.errorMessage("Fraudulent Product Block or Product Identity Detected! Please try again with a different Product ID");
							return false;
						}
					}
					else {
						this.errorMessage("Product Does Not Exist in the Scriptbill Credit Network, You May As well Buy The Product Through Credit Invoices That May Be Issued By The Seller Using The Sell Product Tab on Your Scriptbank Dashboard.");
						return false;
					}
					
					if( ! newBlock.productID || newBlock.productID != details.productID ){
						newBlock.productID = details.productID;					
					}
					//encrypt the public key with the recipient provided.
					if( details.transType == 'BUYPRODUCT' && details.productID &&  agreement.productConfig.units > 0 ) {
						var id 				= await this.generateKey(10);
						await this.setPublicKey( details.productID, id );
						agreement.productConfig.units					-= 1;
						if( details.agreement && details.agreement.purchaseURL )
							agreement.purchaseURL = details.agreement.purchaseURL;
						
						let agreeKey 			= await this.generateKey(10, true );
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( agreeKey, id );
						agreement.agreeKey 		= await this.getPublicKey(id);
						note.agreements.push( {key:agreeKey, agreeID:agreement.agreeID} );
						newBlock.agreement 		= JSON.parse( JSON.stringify( agreement ));
						newBlock.agreements[ agreement.agreeID ] = newBlock.blockID;						
					}
					else if( details.transType == 'PRODUCTSUB' && details.productID && agreement.productConfig.units > 0 && ( ! note.noteSubs[ details.productID ] || ! note.noteSubs[ details.productID ].subUnit || note.noteSubs[ details.productID ].subUnit > 0 ) ) {
						var id 				= await this.generateKey(10);
						await this.setPublicKey( details.productID, id );
						
						//if the transaction is a new subscription, we deduct a unit from the original unit of the product
						//any one inheriting the product purchase will know that one unit of the product is already purchased
						/* if( !details.subConfig || ! details.subConfig.subUnit ){
								
							details.subConfig 	= JSON.parse( JSON.stringify( this.defaultSub ));
							details.subConfig.productID = details.productID;
							details.subConfig.subUnit 	= Math.round( parseFloat( productBlock.transValue ) / parseFloat( details.transValue ) );
							//to register this on the database we 
						} */					
												
						if( note.noteSubs[ details.productID ] ) {
							this.productBlockID 	= note.noteSubs[ details.productID ].subsID;
							productBlock			= await this.getTransBlock(1,{productBlockID: this.productBlockID });
							//a subscription product block returned
							//this block won't be deleted except the next subscription is triggered
							//the expiry date shpulg be set equal to or even greater than the nextSub time.						
							productBlock  		= productBlock[0];
							
							if( ! productBlock || ! productBlock.agreement ){
								this.errorMessage("no Product Block related to your current subscription. Subscription may be taken as new!");
							} else {							
								agreement 		=  productBlock.agreement;
							}
						}
						
						//add the subscription unit if not found.
						if( ! agreement.productConfig.subUnit ){
							agreement.productConfig.subUnit 					= Math.round( agreement.value / parseFloat( details.transValue ) );
							agreement.productConfig.units					-= 1;
							details.subConfig.value  		= details.transValue;
							let subTime 						= this.calculateTime( details.subConfig.subSpread );
							details.subConfig.nextSub 		= parseInt( this.currentTime() ) + subTime;
							details.subConfig.productID 	= details.productID;
							details.subConfig.lastSub		= agreement.value % parseFloat( details.transValue );
							
							//ensuring the sub unit is well configured.
							let lastSub 						= details.subConfig.lastSub / parseFloat( details.transValue );
							
							if( lastSub < 0.5 ){
								agreement.productConfig.subUnit 				+= 1;
							}
							
							if( details.subConfig.lastSub == 0 ){
								details.subConfig.lastSub 	= details.transValue;
							}
							
							details.subConfig.subUnit		=  agreement.subUnit;
							note.noteSubs[ details.subConfig.productID ] = JSON.stringify( details.subConfig );
							agreement.productConfig.subConfig 				= JSON.parse( JSON.stringify( details.subConfig ));
						}
						else {
							agreement.subUnit 				-= 1;
							let subTime 					= this.calculateTime( details.subConfig.subSpread );
							details.subConfig.nextSub 	= parseInt( this.currentTime() ) + parseInt( subTime );
							note.noteSubs[ details.subConfig.productID ] 	= details.subConfig;
							
							agreement.productConfig.subConfig				= details.subConfig;
						}				
					}
					//this is an helper block for note'this.s who triggered a subscription transaction when there
					else if( details.transType == 'PRODUCTSUB' && note.noteSubs[ details.productID ] && note.noteSubs[ details.productID ].subUnit && note.noteSubs[ details.productID ].subUnit <= 0 ){
						newBlock.transType 	= 'UPDATE';
						details.transType	= 'UPDATE';
						transType			= 'UPDATE';
						newBlock.transValue = 0;					
						delete note.noteSubs[details.productID ];
					}
					
					else if( agreement.productConfig.units <= 0 ){
						this.errorMessage("Product Not Available Right Now. You can Check Back a Little While to Purchase the Product Again.");
						return false;
					}
					
					if( details.transType == 'PRODUCTSUB' || details.transType == 'BUYPRODUCT' ) {
						//if we have the most current block, let'this.s calculate the productIDs
						//if our peoductIDs coincide with that of another block, the recipient note will help us 
						//adjust base on the transaction time.
						//var string  					= productBlock.productFormerBlockID + productBlock.productID;
						newBlock.productFormerBlockID 	= productBlock.productBlockID;
						var string 					= productBlock.productID;
						trivKey 						= this.hashed( string );
						newBlock.productID 				= productBlock.productID;
						
						//we get the ones that were saved by when saving the a product BLOCK
						//with the same product ID, if this exist, this may be the latest 
						//productID, else we use the current product block id we have.
						if( this.l[trivKey] )
							newBlock.productFormerBlockID 		= this.l[trivKey];
						
						
						//this will help us dtetect that this new block has runned a Product
						//transaction
						this.#productBlock 				= JSON.parse( JSON.stringify( productBlock ));						
						
						newBlock.agreement 			= JSON.parse( JSON.stringify( agreement ));
						
						//this will help us query the block that holds the last subscription.
						if( details.transType == "PRODUCTSUB" ){
							let nextTime 		= 0;
							if( note.noteSubs[ details.productID ] ) {
								note.noteSubs[ details.productID ].subsID 	= newBlock.productBlockID;
								//calculating the next subscription time.
								nextTime = parseInt( this.calculateTime( note.noteSubs[ details.productID ].nextSub ) );
								nextTime 		+= parseInt( this.currentTime() );
							}
							else {
								//create the subscription on the note
								//the subscription is expected to have been configured by the user before
								//running this function
								note.noteSubs[ details.productID ] = JSON.parse( JSON.stringify( this.subConfig ) );
								note.noteSubs[ details.productID ].subsID  = newBlock.productBlockID;
								note.noteSubs[ details.productID ].value 	= details.transValue;
								note.noteSubs[ details.productID ].productID = details.productID;
								
								if( details.nextSub ){
									nextTime = parseInt( this.calculateTime( details.nextSub ) );
									
									if( nextTime && nextTime > 3600 && ! isNaN( nextTime ) ){
										note.noteSubs[ details.productID ].nextSub 	= details.nextSub;
									} else {
										note.noteSubs[ details.productID ].nextSub 	= this.subConfig.nextSub;
										nextTime 	= parseInt( this.calculateTime( this.subConfig.nextSub ));
									}
									nextTime 		+= parseInt( this.currentTime() );
								} else {
									nextTime 	= parseInt( this.calculateTime( this.subConfig.nextSub ));
									nextTime 	+= parseInt( this.currentTime() );
								}
								
								
							}
							
							newBlock.expiry 	= nextTime;
							
						}
						else {
							if( productBlock.agreement && productBlock.agreement.max_exec && typeof productBlock.agreement.max_exec == "string" )
								newBlock.expiry 	= parseInt( this.currentTime() ) + parseInt( isNaN( await this.calculateTime( productBlock.agreement.max_exec ) ) ? await this.calculateTime( "2 weeks" ) : await this.calculateTime( productBlock.agreement.max_exec ) );
							
							else 
								newBlock.expiry 	= parseInt( this.currentTime() ) + parseInt( await this.calculateTime( "2 weeks" ) );
						}
						
						
						//setting the profit keys.
						let profitKey		= await this.generateKey(0, true);
						note.profitKeys.push( profitKey );
						
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( profitKey, id );
						newBlock.profitKey 	= await this.getPublicKey(id);
						
						if( productNote /* && ( ! currentNote || currentNote.noteAddress != productNote.exchangeID ) && productNote.noteType.split("-")[0] == "BN" && productNote.noteProducts && productNote.noteProducts.length > 0 */ && productNote.exhangeID ){
							
							//the exchange value note on the product note is the note that has all the credit supplied to the product note held.
							//the note value is only affected when the budget created by the user is executed. Once executed the note value of the associated product note increases
							//the demand value of the product note is the value of the total product created by the creator of the budget. so only crete and update product transaction affects the demand value of the Product note.
							if( ! productNote.exchangeValue )
								productNote.exchangeValue = 0;
							
							productNote.exchangeValue = parseFloat( productNote.exchangeValue ) + parseFloat( details.transValue );
							
							//the note value will be set in every execution of a budget.
							//if there are no budget yet on the note, we pass It
							if( productNote.noteValue )
								productNote.noteValue 		= parseFloat( productNote.noteValue ) - parseFloat( details.transValue );
							
							//the note's demand value drops at every sale of the product.
							if( productNote.demandValue )
								productNote.demandValue 		= parseFloat( productNote.demandValue ) - parseFloat( details.transValue );
							
							this.productNote 					= JSON.parse( JSON.stringify( productNote ));
							newBlock.productNote 				= JSON.parse( JSON.stringify( productNote ));
							
						}
					}
				}
				
				//a normal note can't run an invest transaction so we abort 
				//if the function is running in a mining mood
				if( details.transType == "INVEST" && ! this.#isExchangeMarketMining ){
					this.errorMessage("Can't run an INVEST transaction type without being in a mining mood!");
					return false;
				}
				
				
				//if the transaction type was agree send, and it was a product 
				//agreement, we bill the product note and credit the current 
				//note
				
				if( this.#agreeBlock && details.transType == "AGREESEND" && details.agreement && details.agreement.agreeType.toUpperCase() == "PRODUCT" && response && this.#productTrans.includes( response.transType ) && response.productNote && response.productNote.exchangeID ){
					note.noteValue 		= parseFloat( note.noteValue ) + parseFloat( details.transValue );
					let productNote 	= await this.getCurrentExchangeNote( response.productNote.stockID );
					
					if( ! productNote ){
						this.exchangeID 	= response.productNote.exchangeID;
						productNote 		= await this.getCurrentExchangeNote();
					}
					
					if( ! productNote && response.productID ){
						let productBlock		= await this.getCurrentProductBlock( response.productID );
						productNote 			= productBlock.productNote;
					}
					
					if( ! productNote ){
						productNote 		= JSON.parse( JSON.stringify( response.productNote ));
					}
					
					productNote.exchangeValue 	= parseFloat( productNote.exchangeValue ) - parseFloat( details.transValue );
					newBlock.transType 			= details.transType;
					newBlock.transValue 		= details.transValue;
					newBlock.productID 			= response.productID;
					newBlock.productNote 		= JSON.parse( JSON.stringify( productNote ));
					newBlock.agreement 			= details.agreement;
				}
				
				if( details.transType == "ADVERT" && details.agreement && details.agreement.advertID ){
					newBlock.agreement 			= JSON.parse( JSON.stringify( details.agreement ));
					newBlock.transType 			= details.transType;
					newBlock.transValue 		= details.transValue;
					newBlock.agreement.privateKey 	= await this.generateKey(10, true );//used to decrypt the recipient when publishing  or viewing the advert.
					var id 						= await this.generateKey(10);
					await this.setPrivateKey( newBlock.agreement.privateKey, id );		
					details.recipient 			= await this.getPublicKey(id);
					
					
				}
				//billing the note that initiated this transaction
				//this typ of send transaction cannot be billed from the Current
				//note
				else if( details.transType != "CONFIRM" || details.transType != "AGREEMENTSIGN" || details.transType != "CANCELLED" || details.transType != "INVEST" ){
					if( details.transType == "ADVERT" && this.#isExchangeMarketMining && this.productNote ){
						let productNote 	= JSON.parse( JSON.stringify( this.productNote ) );
						this.#isExchangeMarketMining	= false;
						productNote.exchangeValue 		= parseFloat( productNote.exchangeValue ) - parseFloat( details.transValue );
						newBlock.productNote 	= JSON.parse( JSON.stringify( productNote ));
						newBlock.isExchangeMarketMining = 1;
						delete this.productNote;
					} else if( details.transType == "EXECUTEBUDGET" && this.#isExchangeMarketMining && details.agreement && details.agreement.budgetID && details.agreement.item && details.agreement.item.itemValue ){
						this.#isExchangeMarketMining	= false;
						let productNote 				= await this.getCurrentExchangeNote( details.agreement.stockID );
						
						if( ! productNote || ! productNote.exchangeValue ){
							this.errorMessage("No Product Note to Bill Budget From");
							return false;
						}
						
						productNote.exchangeValue 		= parseFloat( productNote.exchangeValue ) - parseFloat( details.transValue );
						newBlock.productNote 	= JSON.parse( JSON.stringify( productNote ));
						newBlock.isExchangeMarketMining = 1;
						newBlock.transType 				= details.transType;
						
						let agreed 						= details.agreement.item.agreement;
						
						if( this.itemBlockID && typeof details.agreement.budgetItems == "object" ){
							details.agreement.budgetItems.splice( details.agreement.budgetItems.indexOf( this.itemBlockID ), 1 );			
							
							if( details.agreement.item.isPeriodic && details.agreement.item.times && ! isNaN( parseInt( details.agreement.item.times ) ) && details.agreement.item.times > 0 ){
								details.agreement.budgetItems.push( newBlock.blockID );
								details.agreement.item.lastExecID 	= this.itemBlockID;
								
								details.agreement.item.times 		= parseInt( details.agreement.item.times ) - 1;
								
								if( details.agreement.item.waitPeriod ){
									let wait 		= parseInt( this.calculateTime( details.agreement.item.waitPeriod ));
									let curTime		= Date.now();
									
									if( ! isNaN( wait ) ){
										details.agreement.item.time 	= curTime + wait;
									} else {
										details.agreement.item.time 	= curTime;
									}
								}
							} else {							
								delete details.agreement.item;//forgotten forever.
							}
							
							delete this.itemBlockID;
						}
						newBlock.budgetID 				= details.agreement.budgetID;
						newBlock.agreement 				= JSON.parse( JSON.sringify( details.agreement ));
						details.agreement 				= JSON.parse( JSON.stringify( agreed ));
					} else {
						note.noteValue 		= parseFloat( note.noteValue ) - parseFloat( details.transValue );
						newBlock.isExchangeMarketMining = 0;
					}
				}
				
				//if in mining mood 
				if( details.transType == "INVEST" && note.budgetID && this.#isExchangeMarketMining ){
					if( ! currentNote && newBlock.exchangeNote )
						currentNote		= JSON.parse( JSON.stringify( newBlock.exchangeNote ));
					
					if( ! currentNote.demandValue )
						currentNote.demandValue = 0;
					
					if( currentNote.exchangeValue && currentNote.exchangeValue > details.transValue )
						currentNote.exchangeValue 	= parseFloat( currentNote.exchangeValue ) - parseFloat( details.transValue );
					
					else
						currentNote.demandValue 	= parseFloat( currentNote.demandValue ) + parseFloat( details.transValue );
					
					newBlock.exchangeNote 			= JSON.parse( JSON.stringify( currentNote ));
					//note.noteValue 					= parseFloat( note.noteValue ) + parseFloat( details.transValue );
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					let budgetID 		= await this.getPublicKey(id);
					let budgetBlock 	= await this.getCurrentBudgetBlock( budgetID );
					
					if( ! budgetBlock ){
						this.errorMessage("No Budget Block was found connected to this note's Budget.  We'll try the auto investment transaction again.");
						return false;
					}
					
					let productNote 	= JSON.parse( JSON.stringify( budgetBlock.productNote ));
					
					if( ! budgetBlock.agreement || ! budgetBlock.agreement.budgetType || ! budgetBlock.agreement.budgetType == "business" || ! productNote ){
						this.errorMessage("Investment are only valid for business budget with a valid public product note data!");
						return false;
					}
					
					if( ! budgetBlock.agreement.businessID && ! budgetBlock.agreement.businessKey && ! budgetBlock.agreement.businessSign ){
						this.errorMessage("No Business Manager Data on the Agreement Yet, Please advertise this budget to a Business Manager in the Scriptbill Network for observation first.");
						return false;
					}
					
					if( ! this.Verify(budgetBlock.agreement.businessSign, budgetBlock.agreement.businessKey, budgetBlock.agreement.businessID) ){
						this.errorMessage("We couldn't verify the business data on the budget block");
						return false;
					}
					
					let businessProfile 	= await this.getData("business", budgetBlock.agreement.businessKey, this.#default_scriptbill_server);
					
					if( ( ! businessProfile || ! businessProfile.profitRate ) && navigator.onLine ){
						this.errorMessage("Business Manager that signed this block does not seems to have a profile with Scriptbank or the Company Matrix Business Fellowship. Please try again with a valid Business Manager Profile");
						return false;
					}
					
					let profit 		= parseFloat( businessProfile.profitRate );
					
					productNote 	= await this.getCurrentExchangeNote( budgetBlock.agreement.stockID );
					
					if( ! productNote && navigator.onLine ){
						this.errorMessage("We couldn't find the latest product note data, investing on any data may lead to inaccurately placed data");
						productNote 		= JSON.parse( JSON.stringify( budgetBlock.productNote ));
					}
					
					profit 		= parseFloat( details.transValue ) * profit;
					
					productNote.exchangeValue 	= parseFloat( productNote.exchangeValue ) + parseFloat( details.transValue );
					
					if( ! productNote.stockValue )
						productNote.stockValue 		= 0;
					
					productNote.stockValue 		= parseFloat( productNote.stockValue ) + parseFloat( details.transValue );
					
					newBlock.productNote 		= JSON.parse( JSON.stringify( productNote ));
					newBlock.transType 			= details.transType;
					newBlock.transValue 		= details.transValue;
					newBlock.isExchangeMarketMining	= 1;
				}
					
				//since everything in the agreement has already been set, we can create am hash of it Now
				//to save on our own block
				//a product block agreement cannot be hashed because it gives
				//the general public information about the company and the CURRENT
				//product.
				if( ! newBlock.productID && (newBlock.transType != "BUYPRODUCT" || newBlock.transType != "PRODUCTSUB" )){
					var string 	= JSON.stringify( agreement );
					newBlock.agreement = this.hashed( string );	
				}				
				
				
				//before encrypting the budget let's add references to our block
				privKey 				= await this.generateKey( 20, true, true );
				var id 					= await this.generateKey(10);
				await this.setPrivateKey( privKey, id );
				newBlock.blockRef	= await this.getPublicKey( id, true );
				newBlock.signRef	= await this.generateKey( 20 );
				agreement.privateKey		= privKey;
				var id 				= await this.generateKey(10);
				await this.setPublicKey( details.recipient, id );
				//console.log( "Recipient of this funds log: ", details.recipient );
				if( details.recipient.length == 171 )
					newBlock.recipient = await this.#encrypt( JSON.stringify( agreement ), id );
				
				else
					newBlock.recipient = this.encrypt( JSON.stringify( agreement ), this.publicKey[id] );
				
				/* //console.log( "Recipient data: ", newBlock.recipient );
				alert("check recipient data"); */
				
				newBlock.transType = details.transType;
				
				if( this.autoExecute && details.blockRef ){
					newBlock.blockRef 	= details.blockRef;
				}
				newBlock.transValue = details.transValue;
			}
			//to recieve a transaction, the send block must be set in the response handler and the send block must have 
			//transaction type that equal send.
			else if( ( this.#transRecieve.includes( details.transType )  && response && this.#transSend.includes( response.transType ) ) || ( response.transType == "DEPOSIT" && this.#fiatCurrencies[ testType ] && details.transType == "CONFIRM" ) || ( response.transType == "AGREEMENTSIGN" && details.transType == "AGREEMENTREQUEST" ) /* && response.transType != "WITHDRAW" */  ){
				//console.log("running recieve transaction");
				
				//console.log("trans type: " + response.transType);
				//await this.createAlert("check this " + response.blockID);
							
				
				/* //a recieved transaction is not connected to a product details
				if( newBlock.productID ){
					delete newBlock.productID;
				}
				
				//a recieved transaction is not connected to a budget details
				if( newBlock.budgetID ){
					delete newBlock.budgetID;
				} */
				
				//the recipient must be the same as the response.
				if( ! details.recipient || details.recipient != response.recipient )
					details.recipient 		= response.recipient;
				
				//the first private key to use when recieving a transaction is the note secret.
				/* if( noteSecret == note.noteSecret && !isNew && ! this.#isExchangeMarketMining ){
					//await this.createAlert("isNew");
					var string 	=	 transKey;
					note.noteSecret = this.decrypt( noteSecret, this.hashed( string ) );
				} */
				//console.log( "secret: " + note.noteSecret );
				//await this.createAlert( "check secret");
				//first we use the note secret key to attempt to decrypt the AGREEMENT
				//on the block.
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( note.noteSecret, id );				
				let agreement = await this.#decrypt( details.recipient, id );
				//console.log( "decrypted agreement: ", agreement );
				
				if( ( details.transType == "VIEWADVERT" || details.transType == "PUBLISHADVERT" ) && response.transType == "ADVERT" && response.agreement && response.agreement.advertID ){
					id 			= await this.generateKey(10);
					await this.setPrivateKey( response.agreement.privateKey, id );
					agreement 	= await this.#decrypt( details.recipient, id );
					
					if( ! this.isJsonable( agreement )) return false;
					
					agreement 	= JSON.parse( agreement );
					
					if( ! agreement.privateKey ){
						this.errorMessage("No Private Key in the advert request");
						return false;
					}
					id 		= await this.generateKey(10);
					await this.setPrivateKey( agreement.privateKey, id );
					let blockRef 		= await this.getPublicKey(id);
					let number 			= 1;
					
					if( details.transType == "VIEWADVERT" )
						number 			= parseInt( agreement.viewers );
					
					else
						number 			= parseInt( agreement.publishers );
					
					let blocks 			= await this.getTransBlock( number, {blockRef: blockRef, transType: details.transType });
					
					if( blocks.length == number ){
						this.errorMessage("Advert budget reached");
						return false;
					}
					
					let accountDetails 	= await this.getAccountData();
					accountDetails		= accountDetails[ note.noteAddress ];
					
					
					if( details.transType == "VIEWADVERT" ){
					
						//next we check if the user is in the range of the advert.
						if( agreement.scope.toUpperCase() != "WORLD" ){						
							let scope 			= agreement.scope.toUpperCase();
							
							if( ! accountDetails.country.toUpperCase().includes( scope ) || ! accountDetails.city.toUpperCase().includes( scope ) || ! accountDetails.zipCode.toUpperCase().includes( scope ) || ! accountDetails.state.toUpperCase().includes( scope ) || ! accountDetails.city.toUpperCase().includes( scope ) || ! accountDetails.address.toUpperCase().includes( scope ) ){
								this.errorMessage("Advert not in your location scope");
								return false;
							}						
						}
						
						//before we continue, let's see if the user is in the interest set on the 
						//advert.
						
						if( agreement.interest.length && accountDetails.userInterest && accountDetails.userInterest.length ){
							let interest 		= accountDetails.userInterest.filter( (interest)=>{
								return agreement.interest.includes( interest );
							});
							
							if( ! interest.length ){
								this.errorMessage("Advert not included in your interest range. You may as well update your interest to view more adverts.");
								return false;
							}
						}
						
						let pubUrl 		= details.publisherServer || location.origin;
						let checkPub 	= await this.getData("scriptbillPing", "TRUE", pubUrl);
						
						if( ! checkPub || ! checkPub.isScriptbillServer || ! checkPub.isScriptbillServer == "TRUE" )
							newBlock.advertPublishers = this.#default_scriptbill_server;
						
						else 
							newBlock.advertPublishers = pubUrl;
						
						//this function will create a view advert UI for the recipient who is
						//going to view the advert. clicking on the advert button means buying
						//or subscribing to the product connected to the advert. This Function
						//will run while the user is getting paid on the advert he has just 
						//viewed.
						let view = await this.viewAdvert( agreement );
						
						if( ! view ){
							this.errorMessage("advert view not initialized ");
							return false;
						}
						
						details.transValue 			= ( parseFloat( response.transValue ) * parseFloat( agreement.viewersShare ) ) / number;
					} else {
						//for publishers.
						//publishers should only run this function if they have started 
						//gaining views from the advert they placed on their Scriptbill 
						//integrated applications to earn from the views they have gotten.
						//it can be runned multiple times until they have gotten all the funds
						//from this advert.
						let share 			= ( parseFloat( response.transValue ) * parseFloat( agreement.publishShare ) ) / number;
						let requiredViews 	= parseInt( agreement.viewers );
						//number of viewers the publisher must get.
						let shareViewers 	= Math.floor( requiredViews / number );
						let pubUrl 		= details.publisherServer || location.origin;
						let checkPub 	= await this.getData("scriptbillPing", "TRUE", pubUrl);
						
						if( ! checkPub || ! checkPub.isScriptbillServer || ! checkPub.isScriptbillServer == "TRUE" ){
							this.errorMessage("Can't Publish a Scriptbill Advert on a server not integrated with the Scriptbill Block Web System.");
							return false;
						}
						
						//next we get the number of funds already gotten by the publisher.
						blocks 				= blocks.filter((block)=>{
							return block.advertPublishers == pubUrl;
						});
						
						let valueGotten = 0;
						
						for( let e = 0; e < blocks.length; e++ ){
							valueGotten += parseFloat( blocks.transValue );
						}
						
						if( valueGotten >= share ){
							this.errorMessage("Publisher has already gotten the required share value. However if the viewership deal has not been reached, you can still make more revenue from this advert.");
						}
						
						//getting total viewers.
						let viewers 		= await this.getTransBlock( requiredViews, {transType: "VIEWADVERT", blockRef: blockRef});
						
						if( viewers.length == requiredViews ){
							this.errorMessage("No more advert to view, publishing deal for this advert has ended!");
							return false;
						}
						
						//let's see the total viewers the current publisher has gotten.
						viewers 			= viewers.filter( (view)=>{
							return view.advertPublishers == pubUrl;
						});
						
						if( ! viewers.length ){
							this.errorMessage("No Viewers available to earn on your publishing contract");
							return false;
						}
						
						//the per view share must be calculated here.
						//which will be the total share expected to give the publisher 
						//divided by the required view count the publisher must get.
						let perViewShare 		= share / shareViewers;
						
						//this is important for publishers who had broken even.
						let totalViewShare 		= ( parseFloat( response.transValue ) * parseFloat( agreement.publishShare ) ) / requiredViews;
						
						//this is the expected revenue the publisher should get based on 
						//the total number of views he had gotten.
						let expectedShare 		= perViewShare * viewers.length;
						
						//now we subtract the already gotten value from the expected Share
						//to get the value to be paid to the publisher.
						let value 				= expectedShare - valueGotten;
						
						//if the publisher has already broken even, this value will be 
						//negative so we calculate the value to be gotten by the publisher 
						//from the total view share.
						if( value <= 0 ){
							expectedShare		= 	totalViewShare * viewers.length;
							value 				= expectedShare - valueGotten;
							
							if( value <= 0 ){
								this.errorMessage("No more funds to get from this advert");
								return false;
							}
						}
						
						details.transValue 			= value;
						newBlock.advertPublishers 	= pubUrl;
						
					}				
					
					this.signKey 		= agreement.privateKey;
					newBlock.blockRef 	= blockRef;
					newBlock.signRef 	= await this.Sign( agreement.privateKey, response.signRef );
					newBlock.transType	= details.transType;
				}
				
				//if it was an INVEST RECIEVE transaction, the budget key makes more 
				//sense.
				if( details.transType == "INVESTRECIEVE" && note.budgetID ){
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					agreement = await this.#decrypt( details.recipient, id );
					
					if( ! agreement || ! this.isJsonable( agreement ) ) return false;
					
					this.#storeConnectedBlock(response);
					
					agreement 		= JSON.parse( agreement );
					let budgetValue = agreement.value;
					
					let t, percent, stock, amount, total, pay;
					t 		= agreement.sleepingPartner;
					percent = agreement.sleepingPartnerShare;
					
					//please note that the Pay Value is the total number of stock the user is allowed to hold based 
					//on the agreement of the company. While the stock value is the actual value of the client'this.s investment
					switch(t){
						case 'percent-high':
							amount  = parseFloat( details.transValue ) * percent;
							total  	= parseFloat( details.transValue ) + amount;
							pay 	= total / budgetValue;
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							break;
						case 'percent-low':
							amount 	= parseFloat( details.transValue ) * percent;
							total  	= parseFloat( details.transValue ) - amount;
							pay  	= total / budgetValue;
							stock   = parseFloat( details.transValue ) / parseFloat( budgetValue );
							break;
						case 'percent-equal':
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock;
							break;
						case 'dividend-high':
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock + percent;
							break;
						case 'dividend-equal':
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock;
							break;
						case 'dividend-low':
							stock  	= parseFloat( details.transValue  )/ parseFloat( budgetValue );
							pay 	= stock - percent;
							break;
						default :
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock;
						break;
					}
					
					currentNote = await this.getCurrentExchangeNote( note.noteType );
					
					if( ! currentNote ){
						return false;
					}
					
					let stockNote = newBlock.exchangeNote;
					stockNote.pay = pay;
					stockNote.noteValue = stock;
					let priv 			= await this.generateKey(40, true) ;
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( priv, id );
					stockNote.noteAddress = await this.getPublicKey(id);
					stockNote.noteSecret   = priv;
					stockNote.exchangeID 	= stockNote.noteAddress;
					stockNote.exchangeKey 	= priv;
					stockNote.motherKey 	= currentNote.noteAddress;
					stockNote.blockID 		= newBlock.blockID;
					newBlock.agreement = JSON.parse( JSON.stringify( agreement ) );
					delete newBlock.agreement.privateKey;
				}
				
				/* //console.log("agreement: " + agreement );
				await this.createAlert( "check agreement" ); */
				
				if( ! this.isJsonable( agreement ) && typeof agreement != "object" ){
					//await this.createAlert("Not jsonable" );
					//sometimes a transaction may be ignited by the network through 
					//the client's block key, we try to handle that here.
					var id 					= await this.generateKey(10);
					await this.setPrivateKey( note.blockKey, id );
					agreement 	= this.decrypt( details.recipient, this.getPublicKey(id, true) );
					
					if( this.isJsonable( agreement ) && note.blockID != response.repBlockID ){
						this.errorMessage("Recieve Transaction Aborted Because Sender Didn't Specify Your Note's Block as The Recipient Block");
						return false;
					}
					
					if( ! this.isJsonable( agreement ) && note.unfulfilled && note.unfulfilled[ response.repBlockID ] ){
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( note.unfulfilled[ response.repBlockID ], id );
						agreement 	= this.decrypt( details.recipient, this.getPublicKey(id,true) );
						
						if( this.isJsonable( agreement ) ){
							delete note.unfulfilled[ response.repBlockID ];
						}
					}
						
					//return false;			
				}
				
				if( this.recieveKey ){
					let acc 	= await this.getAccountData();
					
					//some how some people may decide to create a transaction to a 
					//note using the note's contacts like email, phone number.
					//this type of transaction always come with a trans key which is 
					//supplied to this function using the recieveKey handler.
					//note that if you use the note's contact to mail them a 
					//transaction, the contact should also be used to share this 
					//key to avoid the transaction being listened to by unsolicited 
					//people.
					if( acc[ note.noteAddress ] ){
						//first we test the note's email to see if the transaction
						//was directed to the note's email.
						let emails = acc[ note.noteAddress ].emails;
						var id;
						for( id = 0; id < emails.length; id++ ){
							var string 	= emails[id] + this.recieveKey;
							var string 	= this.hashed( string );
							agreement 		= this.decrypt( details.recipient, this.hashed( string ) );
							
							if( this.isJsonable( agreement ) ) break;
						}
						
						if( ! this.isJsonable( agreement ) ){
							//if we couldn't find an email on the note to recieve the
							//transaction we ceck the phones.
							let phones = acc[ note.noteAddress ].phones;
							var id;
							for( id = 0; id < phones.length; id++ ){
								var string 	= phones[id] + this.recieveKey;
								var string		= this.hashed( string );
								agreement 		= this.decrypt( details.recipient, this.hashed( string ) );
								
								if( this.isJsonable( agreement ) ) break;
							}
						}
					}
					delete this.recieveKey;
				}
				
				//sometimes it may be only a particular key that was used to send the
				//transaction, this must be set in the key handler for this to work.
				if( this.key && ! this.isJsonable( agreement ) ){
					var string 	= this.key;
					agreement 		= this.decrypt( details.recipient, this.hashed( string ) );
					delete this.key;
				}
				
				//configure the blockID in the details too.
				if( ! details.blockID || response.blockID != details.blockID )
					details.blockID 		= response.blockID;
				
				if( ! details.blockID )
					return false;
				
				if( ! details.noteType || response.noteType != details.noteType )
					details.noteType 		= response.noteType;
				
				
				
				let noteType 			= response.noteType || details.noteType;
				
				if( response.transType == "AGREEMENTSIGN" && response.agreement ){
					let blockKey 		= note.unfulfilled[ response.agreement.agreeID ];
					
					if( ! blockKey ){
						return false;
					}
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( blockKey, id );
					agreement 			= this.decrypt( response.recipient, await this.getPublicKey( id,true ) );
				}
				let privateKey = false;
				if( this.isJsonable( agreement ) && noteType == note.noteType ){
					//await this.createAlert("Transaction Recieved");					
					
					//trying to extract private key from the agreement handler.
					this.#storeConnectedBlock(response);
					agreement 	= JSON.parse( agreement );
					privateKey  = agreement.privateKey;
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( privateKey, id );
					this.pubKey = await this.getPublicKey(id, true);
					
					if( details.transType == "INVESTRECIEVE" && agreement.budgetType == "business" ){
						//we configure the new public exchange note that will represent the
						//stock notes held by the exchange market.
						
					}
					
					if( this.pubKey != response.blockRef && response.nextBlockID != "AUTOEXECUTE"){
						this.errorMessage("This block is invalid!!! the reference key is not equal with key supplied! Your Recieved Block Reference: " + response.blockRef + ". Recieved Transaction Now Aborting!!!");
						return false;
					}
					else if( response.nextBlockID == "AUTOEXECUTE" && details.agreement ){
						privateKey 	= details.agreement.privateKey;
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( privateKey, id );
						this.pubKey 		= await this.getPublicKey(id,true);
						
						if( newBlock.agreements[ agreement.agreeID ] ){
							delete newBlock.agreements[agreement.agreeID];
						}
						//block with the autoKey handler would be noted in the network to be an auto generated transaction.
						 this.signTxt 		= response.signRef;
						newBlock.autoKey	= await this.getPublicKey(id);
						newBlock.blockRef	= response.blockRef;
					}
					delete agreement.privateKey;
					//storing the agreement this way on the block makes it executable
					//by any node in the network.
					//the recipient note will not be able to recieve the block transaction
					//more than once because the transaction will be referenced to the 
					//current block, re recieving the funds means having two or more 
					//blocks in the network having the same reference key, that will be
					//invalid, so scriptbill default behaviour is to do away with the 
					//first private key of the agreement to prevent the note from
					//re recieving agreements again.
					//we won't add the agreement back to the new block is it is autogenerated, except the agreement is
					//period.
					if( response.nextBlockID != "AUTOEXECUTE" || agreement.isPeriodic )
						newBlock.agreements[agreement.agreeID] = newBlock.blockID;
					
					newBlock.agreement 	= agreement;
					
					//lastly, before we recieve the transaction block, we have to test if the recipient is ready to recive
					//the transaction based on the connected agreement.
					if( details.transType == 'RECIEVE' && response.nextBlockID != "AUTOEXECUTE" && ( response.transType != "CONFIRM" || response.transType != "AGREEMENTSIGN" || response.transType != "CANCELLED" || response.transType != "DEPOSIT" )
						&& ! this.#isExchangeMarketMining ) {
						//console.log("transtype: " + response.transType );
						let conf = await this.createConfirm('You are about recieving ' + details.transValue + ' and the details on the agreement: agreement value = ' + agreement.value + ';' + ( agreement.ExecTime ? ' the agreement will end in: ' + this.timeToString( agreement.ExecTime, true ) + '; You\'ll be given a grace of: ' + this.timeToString( parseInt( response.transTime ) - parseInt( agreement.ExecTime ) ) : '' ) + '; The Payment is ' + ( agreement.isPeriodic ? 'going to be periodic and the periodic times will be ' + agreement.times + ' with an interest rate of ' + parseFloat( agreement.interestRate ) * 100 + '% which will be calculated as a ' + agreement.interestType + ' interest and would be calculated every ' + agreement.interestSpread : 'not going to be periodic' ) +  '. Do you which to continue recieving Scriptbill transaction or click cancel to cancel the transaction? ' );
						//console.log("continuing " + conf );
							
						if( ! conf ){ 
							this.errorMessage( response.blockID + " Recieved Transaction Now Being Cancelled!!!");
							//create a transaction block to cancel the transa
							details.transType 	= "CANCELLED";
							transType 			= "CANCELLED";
							details.recipient 	= response.blockKey;
							details.transValue = response.transValue;
							details.noteValue 	= note.noteValue;
							details.noteType	= note.noteType;
							details.agreement 	= agreement;
							//adding the block reference to be sure.
							details.agreement.privateKey = privateKey;
							details.blockRef 	= response.blockRef;
							return await this.generateScriptbillTransactionBlock(details);
						}
					
					} else if( response.transType == "AGREEMENTSIGN" && response.agreement ){
						newBlock.transType = "AGREEMENTUPDATE";
						newBlock.transValue = 0;
						delete newBlock.agreements[ response.agreement.agreeID ];
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( privateKey, id );
						newBlock.signRef 	= await this.Sign(privateKey, response.signRef);
						newBlock.blockRef 	= await this.getPublicKey(id, true);
					} 
					else if( response.transType == "CANCELLED" ){
						newBlock.transType 	= "SEND";
						newBlock.transValue 	= response.transValue;
						//we deduct the value from the note without checking the note value.
						note.noteValue 		= parseFloat( note.noteValue ) - parseFloat( response.transValue );
						newBlock.recipient 	 = this.encrypt( JSON.stringify( agreement ), response.blockKey );
						
						delete newBlock.agreements[ agreement.agreeID ];
					}
					else if( response.transType == "CONFIRM" ){
						return response;
					}
					
					
					
				}
				//now if the noteType that would recieve this transaction is not the same note type as 
				else if(  this.isJsonable( agreement ) && noteType != note.noteType && ! this.#isExchangeMarketMining ){
					
					
					let conf = await this.createConfirm('You are about recieving ' + details.transValue + ' with a Credit Type of: ' + details.noteType + '. To Recieve Scriptbill Credit you need to create a new Scriptbill Note of Scriptbill type. Do you Wish to Continue?' );
						
					if( ! conf && this.alertDetails ) {
						let noteAdd = await this.createPrompt('Please enter the note Address to recieve Scriptbill credit. Cancel if you don\'t want to recieve Scriptbill credit or you want to exchange Scriptbill credit directly!!!');
						
						if( noteAdd != null ){
							details.recipient = noteAdd;
							note.noteValue 	+= parseFloat( details.transValue );
							let type 				= note.noteType;
							note.noteType 	= noteType;
							details.transType 	= "SEND";
							transType 			= "SEND";
							details.agreement 	= JSON.parse( agreement );
							return await this.generateScriptbillTransactionBlock().then( async dBlock =>{
								note.noteType 	= type;
								if( this.returnNote )
									this.returnNote 	= JSON.parse( JSON.stringify( note ) );
								
								await this.saveNote( note );
								
								return dBlock;
							});
							
						}
						else {
							if( ! response )
								this.response = details;
							
							this.exchangeCredits();
						}
					
					} else {
						//save the current note ro preserve the note's information
						//then create a new note th
						
						if( this.returnNote )
							this.returnNote 		= JSON.parse( JSON.stringify( note ));
						
						await this.saveNote( note );
						agreement 							= JSON.parse( agreement );
						this.defaultBlock 					= JSON.parse( JSON.stringify( details ) );
						this.defaultBlock.agreement 		= agreement;
						this.defaultScriptbill.noteType 	= details.noteType;
						this.defaultScriptbill.noteServer 	= details.noteServer;
						this.defaultScriptbill.walletID		= note.walletID;
						return await this.createNewScriptbillWallet();
					}
				}
				//else if the agreement was not properly decrypted, we check other possible private keys in the note.
				else if( typeof agreement != "object" || ! this.isJsonable( agreement ) ) {
					//await this.createAlert("Not Decrypted");
					//before returning, we test other private keys that exists on Scriptbill note that can be used to send data to Scriptbill note.
					//first test the note products, incase the note is selling a product.
					let products = note.noteProducts;
					if( typeof products == 'object' ){	
						let x;
						for( x = 0; x < products.length; x++ ){
							privKey = products[x];
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( privKey, id );
							agreement = await this.#decrypt( details.recipient, id );
							if( this.isJsonable( agreement ) ){
								if( noteType != note.noteType ){
									this.exchangeCredits();//BAAACK
									break;
								}
								agreement 	= JSON.parse( agreement );
								privateKey = agreement.privateKey;
								delete agreement.privateKey;
								newBlock.agreement 					= JSON.parse( JSON.stringify( agreement ));
								newBlock.agreements[ agreement.agreeID ] = newBlock.blockID;
								this.#storeConnectedBlock(response);
								break;
							}
						}					
					}
					//next we need to check the agreements the note has made whether it'this.s the transaction block offered in the details.
					if( typeof note.agreements == 'object' ){
						let x;
						for( x = 0; x < note.agreements.length; x++ ){
							privKey = note.agreements[x];
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( privKey.key.split('----')[0], id );
							agreement = await this.#decrypt( details.recipient, id );
							if( this.isJsonable( agreement ) ){
								if( noteType != note.noteType ){
									this.exchangeCredits();
									break;
								}
								agreement = JSON.parse( agreement );
								privateKey = agreement.privateKey;
								delete agreement.privateKey;
								delete note.agreement[x];
								this.#storeConnectedBlock(response);
								break;
							}
						}
					}
					
					//the profit keys are added to the note whenever the note makes a payment for a product
					//the profit keys will remain on the note as long as the block carrying the public key has 
					//not expired
					if( details.transType == 'PROFITRECIEVE' && response.transType == "PROFITSHARING" && note.profitKeys && typeof note.profitKeys == 'object' && note.profitKeys.length > 0 ){
						this.signKey 		= false;
						for( x = 0; x < note.profitKeys.length; x++ ){
							privKey = note.profitKeys[x];
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( privKey, id );
							agreement = await this.#decrypt( details.recipient, id );
							if( this.isJsonable( agreement ) ){
								this.#storeConnectedBlock(response);
								agreement = JSON.parse( agreement );
								privateKey = agreement.privateKey;
								delete agreement.privateKey;
								break;
							}
						}
						if( noteType != note.noteType && agreement && agreement.agreeID ){
							this.errorMessage("Profit Credit Sent Didn't Match With Your Note's, Exchanging Credit Instead!");
							return await this.exchangeCredits();		
						}
						
						if( note.referee ){
							let result = {};
							let accd 	= await this.getAccountData();
							result.loanValue = accd.loanValue;
							newBlock.referer 	= this.encrypt( JSON.stringify( result ), note.referee );	
						}
					}			
					
				}
				//console.log("continue recieving 2");
				
				//we can stop recieveing if the agreement was not propely decrypted.
				if( typeof agreement != "object" || ! privateKey ){
					newBlock = undefined;
					return false;
				}
				//console.log("continue recieving 3");
				//this point we are confidence the note is actually recieving the transaction block
				//once the agreement is successfully decrypted, the note can now recieve the block convienently.
				note.recievedBlockID = response.blockID;
				note.recievedTime	  = response.transTime;
					
				newBlock.recievedIDs.push( response.blockID.slice(0, 5) );
					
				//the recieved id store can't take more than 10 kilobytes of data
				if( newBlock.recievedIDs.length > 2000 ) {
					newBlock.recievedIDs.splice( (newBlock.recievedIDs.length - 1), ( newBlock.recievedIDs.length - 2000 ) );
				}
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( privateKey, id );
				
				if( response.nextBlockID != "AUTOEXECUTE" ){
					newBlock.blockRef 		 = await this.getPublicKey(id,true);
					newBlock.signRef 		 = await this.Sign( privateKey, response.signRef);
				}
				
				else { 
					newBlock.blockRef 	= response.blockRef;
					newBlock.autoKey	= await this.getPublicKey(id, true);
				}
				
				if( details.productID || response.productID ){
					details.origValue  = details.transValue;
					
					if( details.transType != "PROFITRECIEVE" ){
						this.#shareValue 		= ( parseFloat( details.transValue ) * parseFloat( agreement.sharingRate ) );
						newBlock.transValue = details.transValue;
						
						this.titheValue 		= this.#shareValue / 2;
						this.#shareValue 		= this.#shareValue / 2;
					} else if( response && response.transType == "PROFITSHARING" ) {
						this.#shareValue 		= parseFloat( response.transValue ) / 2;
						
						if( this.#shareValue < 1 || ! response.nextRecipient ){
							this.#shareValue 	= false;
							details.transValue 	= response.transValue;
						} else {
							details.transValue 		= this.#shareValue;
							if( response.nextRecipient ){
								this.#productBlock 		= await this.getTransBlock(1, {productBlockID: response.nextRecipient});
								
								if( this.#productBlock.length && this.#productBlock[0].blockID ){
									this.#productBlock 			= JSON.parse( JSON.stringify( this.#productBlock[0] ));
									
									if( response.agreement && response.agreement.payPeriod ){
										let exTime 					= this.calculateTime( response.agreement.payPeriod );
										
										if( isNaN( exTime ))
											exTime 					= this.calculateTime( "2 weeks" );
										
										let curTime 				= this.currentTime();
										
										if( ( parseFloat( response.transTime ) + parseInt( exTime ) < curTime ) ){
											//this shows the block has expired and not recieving profits again from this business.
											this.#productBlock 		= false;
										}
									}
								} else {
									this.#productBlock 			= false;						
								}
								
								if( ! this.#productBlock ){
									details.transValue 		= response.transValue;
									this.#shareValue 		= false;
								}
							}
						
														
						}
						newBlock.transValue 	= details.transValue;
					}
				}
				
				//console.log("continue recieving 5");
				newBlock.referenceID 	= response.blockID;
				newBlock.referenceKey 	= agreement.agreeID;
				details.note 			= response.transNote;
				
				if( details.transType != 'STOCKRECIEVE' || details.transType != 'BONDRECIEVE' ){
					//console.log("continue recieving adding value to note");
					note.noteValue 		= parseFloat( note.noteValue ) + parseFloat( details.transValue );
					newBlock.transType 	= details.transType;
						
					/* if( newBlock.agreements && Object.keys( newBlock.agreements ).length > 0 ) {
						//transaction closed.
						delete newBlock.agreement[ agreement.agreeID ];
					} */
						
					 
					if( response.transType == "DEPOSIT" )
						newBlock.transType = "CONFIRM";
					
					var id 				= await this.generateKey(10);					
					await this.setPrivateKey( response.blockKey, id );
						
					//signing the agreement.
					/*  this.signTxt 			= newBlock.blockID;
					agreement.recieverSign	= await this.Sign();
					agreement.recieverID	=  this.signTxt;
					agreement.recieverKey	= await this.getPublicKey(true); */
						
					if( ! newBlock.agreements ||  typeof newBlock.agreements != "object" )
					newBlock.agreements = {};
						
					//configuring the new block
					newBlock.agreement 						= JSON.parse( JSON.stringify( agreement ));
					newBlock.agreements[agreement.agreeID] = newBlock.blockID;
					newBlock.transValue 	= details.transValue;
					newBlock.noteType 		= note.noteType;
					/* newBlock.recipient 	= this.#encrypt( JSON.stringify( agreement ), id );/*CHECKOUT**/				
					
				}
				else {
					//configuring the default stock note for the User.
					this.defaultScriptbill.walletID		= note.walletID;
					this.defaultScriptbill.stockKey 	= agreement.transKey;
					this.defaultScriptbill.noteValue	= agreement.stock;
					this.defaultScriptbill.transValue	= agreement.pay;
					this.defaultScriptbill.noteType 	= agreement.stockID;
					this.defaultScriptbill.motherKey 	= note.noteAddress;
					let note 							= note;
					
					if( details.budgetProducts && details.budgetProducts.length > 0 )					
						this.defaultScriptbill.stockProducts = details.budgetProducts;
					
					return await this.createNewScriptbillWallet().then( dBlock => {
						note 		= note;
						return dBlock;
					});
										
				}						
				
			}
			//handling other trnasactions apart from sending and recieving.
			//these transaction are transactions that describes an event that occured 
			//in the note. These event can be created and added to the scriptbill code
			//depending on the activities that will be allowed in Scriptbills.
			//soon, Scriptbill will begin to support transaction type that supports social
			//events like chatting which only exist in the BARGAIN transaction for users
			//who want to chat with the seller of a product before purchasing the product.
			//to chat using bargain, the user send a short message to the reciever, this 
			//message will be encrypted and can only be read by the sender and reciever.
			else if( this.#otherTrans.includes( details.transType ) ){
				if( details.transType == 'CREATEPRODUCT' ) {
					//first configure the product ID
					let productKey 			= await this.generateKey( 20, true, true );
					
					if( this.productKey ){
						//console.log( "product key set: " + this.productKey );
						productKey = this.productKey;
					}
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( productKey, id );
					newBlock.productID 		= await this.getPublicKey(id,true);
					//relevant only on create and update product transaction.
					newBlock.productSign 	= await this.Sign(productKey, newBlock.blockID);
					
					if( note.noteProducts.includes( productKey ) ){
						this.errorMessage("You should be updating product instead of creating it");
						details.transType 	= "UPDATEPRODUCT";
						return await this.generateScriptbillTransactionBlock( details, note );
					}
					
					note.noteProducts.push( productKey );
					
					if( newBlock.budgetID )
						delete newBlock.budgetID;
					
					//searching for the budget which the product can fall into.				
					/* if( note.noteProducts && note.noteProducts.length > 0 ) {
						let product = note.noteProducts[0];
						await this.setPrivateKey( product );
						this.productID = await this.getPublicKey();
						let prodBlock = await this.getTransBlock();
						prodBlock  		= prodBlock[0];
						
						if( prodBlock && prodBlock.budgetID ){
							newBlock.budgetID = prodBlock.budgetID;
							newBlock.budgetProducts 	= prodBlock.budgetProducts;
							newBlock.exchangeNote 		= prodBlock.exchangeNote;
							
						}
					} */
					
					delete this.budgetID;
					
					//the budget ID of the product should be stored on the budgetID
					//handler of the note.
					let budgetID = note.budgetID;
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( budgetID, id );
					this.budgetID	= await this.getPublicKey(id);
					let budget 		= await this.getTransBlock(10);
					budget 			= await this.getCurrentBlock( budget );
					budgetID		= await this.getPublicKey(id);
					/* let budgets = note.noteBudgets, budget;
					
					//trying to get the budget id which this product will be under.
					if( budgets && budgets.length > 0 ){	
						for( x = 0; x < budgets.length; x++ ){
							budget = budgets[x];
							await this.setPrivateKey( budget );
							budgetID = await this.getPublicKey();
							this.budgetID	= budgetID;
							budget 			= await this.getTransBlock();
							budget 			= budget[0];
							
							if( budget && budget.agreement )
								agreement = budget.agreement;
							
							//incase the budget agreement was gotten directly
							else if( budget && budget.budgetType )
								agreement = budget;
							
							else 
								agreement = false;
							
							//The product producer must have a budget to create product
							if( agreement && agreement.budgetType == 'business' ){
								newBlock.budgetID 				= budgetID;
								if( budget.productNote )
									newBlock.productNote 		= JSON.parse( JSON.stringify( budget.productNote ));
								break;
							} else {
								budgetID = false;
							}
						}
					}
				 */	
					if( ( ! budgetID || ! budget || ! budget.productNote || ! budget.productNote.exchangeID == newBlock.productNote.exchangeID || ! budget.agreement || budget.agreement.budgetType != "business" ) && ! this.isScriptbankProduct ){
						this.errorMessage("Can't Create a Product In the Scriptbill Network Without a Valid Business Budget. Create a Business Budget First and Then Try Creating Your Product Again.");
						return false;
					}
					
					if( this.isScriptbankProduct ){//generate a product note.
						
						if( typeof this.isScriptbankProduct == "object" && this.isScriptbankProduct.budgetID ){
							newBlock.budgetID = this.isScriptbankProduct.budgetID;
							
							if( this.isScriptbankProduct.note && typeof this.isScriptbankProduct.note == "object" && this.isScriptbankProduct.note.exchangeID){
								newBlock.productNote 	= JSON.parse( JSON.stringify( this.isScriptbankProduct.note ));
							}
							else {
								newBlock.productNote 	= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ));
								let privateKeyd 		= await this.generateKey(10, true );
								var id 					= await this.generateKey(10);
								await this.setPrivateKey( privateKeyd, id );
								newBlock.productNote.exchangeID 	= await this.getPublicKey(id);
								newBlock.productNote.exchangeKey 	= privateKeyd;
							}
						} else {
							newBlock.budgetID 	= this.isScriptbankProduct;
							newBlock.productNote 	= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ));
							let privateKeyd 		= await this.generateKey(10, true );
							var id 					= await this.generateKey(10);
							await this.setPrivateKey( privateKeyd, id );
							newBlock.productNote.exchangeID 	= await this.getPublicKey(id);
							newBlock.productNote.exchangeKey 	= privateKeyd;
						}
					}
					else
						newBlock.budgetID = budgetID;
					
					/* if( ! newBlock.productNote.noteProducts )
						newBlock.productNote.noteProducts = [];
					
					//save the key in the current note.						
					newBlock.productNote.noteProducts.push( productKey ); */
										
					/* this.seed 				= newBlock.productBlockID;
					newBlock.productNextBlockID	= await this.calculateNextBlockID(note); */
					
					//add the product details as agreement to the block.
					newBlock.agreement 			= details.agreement;
										
					//add the business manager key to the block as a refferal.
					if( note.BMKey ){
						newBlock.businessKey		= note.BMKey;
					}
					
					else {
						newBlock.businessKey		= note.noteAddress;
					}
					
					//next update the demand value of the product note.
					if( ! newBlock.productNote.demandValue )
						newBlock.productNote.demandValue = 0;
					
					let units 		= parseInt( newBlock.agreement.productConfig.units );
					
					if( ! units )
						units 	= 1;
					
					let prodValue 	= 	parseFloat( newBlock.agreement.productConfig.value ) * units;
					
					if( ! isNaN( prodValue ))
						newBlock.productNote.demandValue 	= parseFloat( newBlock.productNote.demandValue ) + prodValue;
					
					//add the value of the product as the transaction value of the product.
					newBlock.transValue				= details.transValue;
					newBlock.transType				= details.transType;			
					
					this.#productBlock 			= JSON.parse( JSON.stringify( newBlock ));
				}
				//create product transaction.
				else if( details.transType == "CREATEBUDGET" ){
					//console.log( "budgets: " + note.noteBudgets );
					let exchangeNote 			= newBlock.exchangeNote;
					let productNote				= newBlock.productNote;
					
					delete newBlock.budgetKey;
					delete newBlock.budgetSign;
					
					if( ! this.#budgetSecret ) {
						this.errorMessage("Please re-try to generate your budget with a budget secret key.");
						return false;
					}
					
					//await this.createAlert("Creating Budget");
					
				/* 	if( details.agreement.budgetType != "governmental" ){
						if( ! this.#budgetSecret ){
							privKey = await this.generateKey( 20, true );
							await this.setPrivateKey( privKey );
							note.noteBudgets.push( privKey );
							details.budgetID = await this.getPublicKey();
							newBlock.budgetID 	= details.budgetID;
						} else {
							if( ! note.noteBudgets.includes( details.budgetID ) )
								note.noteBudgets.push( details.budgetID );
							
							await this.setPrivateKey( this.#budgetSecret );
							details.budgetID 		= await this.getPublicKey();
							newBlock.budgetID 		= details.budgetID;
						}
					} */					
					
					//testing the type of the budget,
					if( details.agreement.budgetType &&  details.agreement.budgetType == 'business' ) {
						//alert("business budget!");
						let x, product, productID, productBlock;
						
						productNote 	= JSON.parse( JSON.stringify( this.defaultBlock.exchangeNote ) );
						
						productNote.noteSecret = await this.generateKey( 40, true );
						var id 					= await this.generateKey(10);
						await this.setPrivateKey( productNote.noteSecret, id );
						productNote.noteAddress = await this.getPublicKey(id);
						productNote.exchangeID = await this.getPublicKey(id);
						productNote.exchangeKey = await this.getPrivateKey(id);
						productNote.noteType 	= details.agreement.stockID;
						productNote.creditType  = note.noteType;
						productNote.rankPref 	= "business";
						productNote.walletID 	= note.walletID;
						productNote.stockID 	= details.agreement.stockID;
						productNote.stockValue 	= 0;
						productNote.bondValue 	= 0;
						var id 					= await this.generateKey(10);
						await this.setPrivateKey( this.#budgetSecret, id );
						productNote.budgetID 	= await this.getPublicKey(id);
						newBlock.budgetID 		= productNote.budgetID;
						details.budgetID 		= newBlock.budgetID;
						details.agreement.budgetID = productNote.budgetID;
						
						newBlock.productNote 	= productNote;
						
						if( ! note.budgetID )
							note.budgetID 	= this.#budgetSecret;
						
						else {
							this.errorMessage("Can't create a new business from an existing business note. Use another note to create this business instead.");
							return false;
						}
						
						note.budgetKey 				= await this.generateKey(10, true, true );
						id 							= await this.generateKey(10);
						await this.setPrivateKey( note.budgetKey, id );
						newBlock.budgetKey 			= await this.getPublicKey( id, true );
						newBlock.budgetSign 		= await this.Sign( note.budgetKey, newBlock.blockID );
						
						//alert(details.agreement.budgetID);
						
					} else if( details.agreement && details.agreement.budgetType == "governmental" ){
						
						if( ! details.agreement.stockID || ( details.agreement.stockID.length - details.agreement.stockID.lastIndexOf("CRD") ) == 3 ){
							this.errorMessage("Governmental Budget must have a properly configured stockID, with a CRD -prefix, Yours was formatted like this: " + ( details.agreement.stockID ? details.agreement.stockID : "none was found!" ));
							return false;
						}
						
						//await this.createAlert('Governmental Budget!');
						newBlock.noteType 		= details.agreement.stockID;
						//creating the exchange note.						
						this.noteTypeS 			=	newBlock.noteType		
						let data 	  			= 	await this.getTransBlock();
						
						if( data.length > 0 && data[0].budgetID ){					
							let budgetData 		= await this.getCurrentBudgetBlock( data[0].budgetID );
							
							if( budgetData ){
								this.errorMessage("Budget Already Exists");
								return budgetData;
							}
						}
						
						if( motherKeys.noteAddresses[ newBlock.noteType ] )
							privKey 				= motherKeys.noteAddresses[ newBlock.noteType ];
						else
							privKey 				= await this.generateKey( 40, true );
						var id 						= await this.generateKey(10);
						await this.setPrivateKey( privKey, id );
						
						if( typeof exchangeNote != "object" )
							exchangeNote 	= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
						
						exchangeNote.exchangeID 	= await this.getPublicKey(id);
						exchangeNote.exchangeKey	= privKey;
						exchangeNote.noteType		= newBlock.noteType;
						
						if( motherKeys[ newBlock.noteType ] ){
							id 						= await this.generateKey(10);
							await this.setPrivateKey( motherKeys[ newBlock.noteType ], id );
							exchangeNote.motherKey	= await this.getPublicKey(id);
							exchangeNote.creditType  = exchangeNote.noteType.slice( 0, exchangeNote.noteType.lastIndexOf("CRD") );
						}						
						else{
							exchangeNote.motherKey 		= note.noteAddress;
							exchangeNote.noteValue 		= note.noteValue;
							exchangeNote.creditType 	= note.noteType;
						}
						
						if( note.withdrawAccount && ! this.withdrawAccount )
							exchangeNote.withdrawAccount = note.withdrawAccount;
						
						else if( this.withdrawAccount )
							exchangeNote.withdrawAccount = this.withdrawAccount;
						
						if( details.agreement && details.agreement.stockID && motherKeys.budgetIDS[ details.agreement.stockID ] )
							note.budgetID  = motherKeys.budgetIDS[ details.agreement.stockID ];
						else if( details.agreement && details.agreement.stockID )
							note.budgetID 	= this.#budgetSecret;
						var id 						= await this.generateKey(10);
						await this.setPrivateKey( this.#budgetSecret, id );
						exchangeNote.budgetID 	= await this.getPublicKey(id);
						details.agreement.budgetID 	= exchangeNote.budgetID;
						exchangeNote.transTime 		= this.currentTime();
						exchangeNote.stockID 		= exchangeNote.noteType.slice( 0, exchangeNote.noteType.lastIndexOf("CRD") ) + "BND";

						
						details.budgetID 			= await this.getPublicKey(id);
						newBlock.budgetID 			= details.budgetID;
						note.budgetKey 				= await this.generateKey(10, true, true );
						var id 						= await this.generateKey(10);
						await this.setPrivateKey( note.budgetKey, id );
						newBlock.budgetKey 			= await this.getPublicKey( id, true );
						newBlock.budgetSign 		= await this.Sign( note.budgetKey, newBlock.blockID );
					}
					
					if( ! newBlock.budgetKey || ! newBlock.budgetSign ){
						var id 						= await this.generateKey(10);
						await this.setPrivateKey( this.#budgetSecret, id );
						newBlock.budgetKey 		= await this.getPublicKey( id, true );
						newBlock.budgetSign		= await this.Sign( this.#budgetSecret, newBlock.blockID );
					}
					
					newBlock.budgetID 		= details.budgetID;
					newBlock.agreement 		= details.agreement;
					
					if( ! newBlock.budgetRefs )
						newBlock.budgetRefs = [];
					
					newBlock.budgetRefs.push( details.budgetID );
					
					if( details && details.agreement && details.agreement.budgetCredit )
						newBlock.budgetCredit 	= details.agreement.budgetCredit;
					else
						newBlock.budgetCredit 	= note.noteType;
					
					newBlock.expiry 		= Infinity;
					newBlock.transType 		= details.transType;
					newBlock.transValue 	= details.transValue;
					newBlock.exchangeNote 	= exchangeNote;
					
					if( ( ! note.noteBudgets || typeof note.noteBudgets != "object" ) && ! note.noteBudgets.length )
						note.noteBudgets 		= [];
					
					note.noteBudgets.push( this.#budgetSecret );
					//console.log("Exchange Note ID: " + newBlock.exchangeNote.exchangeID, "Block ID: " + newBlock.blockID );
					//await this.createAlert("Check exchange note and block id");
				}
				else if( details.transType == "BUSINESS" && note.BMKey && response && response.agreement && response.agreement.budgetType == "business" && this.#budgetTrans.includes( response.transType ) && note.rankPref == "businessManager" ){
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.BMKey, id );
					let pubKey 		= await this.getPublicKey(id, true);
					
					//checking if the budget hasn't been signed by another Business Manager
					if( response.agreement.businessID || response.agreement.businessSign || response.agreement.businessKey ){
						this.errorMessage("This budget appear to have been signed by another business manager! If that's a mistake, tell the entrepreneur to create an update budget transaction to remove the illicit signatures from the budget.");
						return false;
					}
					
					newBlock.agreement 		= JSON.parse( JSON.stringify( response.agreement ));
					newBlock.agreement.businessID 	= newBlock.blockID;
					newBlock.agreement.businessKey 	= pubKey;
					newBlock.agreement.businessSign = await this.Sign( note.BMKey, newBlock.agreement.businessID );
					
					if( ! newBlock.agreement.businessSign ){
						this.errorMessage("We could sign the agreement on the block. You may have a corrupted Business Manager's Key. Please try updating your note or upgrading your note to get a new Business Key.");
						return false;
					}
					
					//newBlock.businessID 		= newBlock.agreement.businessKey;
					newBlock.budgetID 			= newBlock.agreement.budgetID;
					newBlock.transValue 		= 0;
					newBlock.transType 			= details.transType;
				}
				//for quote bond transa type.
				else if( ( details.transType == "QUOTESTOCK" || details.transType == "QUOTEBOND" ) && ( response.transType == "SOLDSTOCK" || response.transType == "SOLDBOND" ) ){
					/* if( noteSecret == note.noteSecret && ! isNew && ! this.#isExchangeMarketMining ){
						var string 			= transKey;
						note.noteSecret 	= this.decrypt( noteSecret, this.hashed( string ) );
					} */
					//first decrypt the agreement handler.
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.noteSecret, id );
					let recipient 	= response.recipient || details.recipient;
					agreement 		= await this.#decrypt( recipient, id );
					
					//was not successfully decrypted...
					if( ! this.isJsonable( agreement ) ) return false;
					
					agreement 		= JSON.parse( agreement );
					
						
					//test the agreement to see if it is a valid budget configuration.
					if( ! agreement.budgetID /*|| agreement.budgetID != details.budgetID  || ! agreement.investorsHub */  ) {
						this.errorMessage("Invalid Budget Agreement Found While Quoting Stock or Bond");
						return false;
					} 
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( agreement.budgetID, id );
					let budgetID 	= await this.getPublicKey(id);
					
					if( ! budgetID ){
						this.errorMessage("Invalid Budget Agreement Found While Quoting Stock or Bond");
						return false;
					}
					
					this.budgetBlock 		= await this.getCurrentBudgetBlock( budgetID );
					
					this.budgetID 		= budgetID;
					this.transType 		= "UPDATEBUDGET";
					this.budgetBlock	= await this.getTransBlock();
					
					if( ! this.budgetBlock  ){
						this.errorMessage("Invalid Budget Agreement Found While Quoting Stock or Bond");
						this.budgetBlock 	= false;
						return false;
					}
						
					//the note will store all the stock note public key on the stockNote handler and that of bond on the
					//bondNote handler.
					//the stocknote handler on a Scriptbill note is not a preset handler, only appears on the note's
					//variable when the note has started to invest on stocks.
					let noteAddress, hash, isQuoted = false;
					let stockNote = {};
					if( details.transType == "QUOTESTOCK" && note.stockNotes && note.stockNotes.length > 0 ) {
						let x;
						for( x = 0; x < note.stockNotes.length; x++ ){
							stockNote 		= JSON.parse( JSON.stringify( note.stockNotes[x] ));
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( agreement.budgetKey, id );
							var VerifyKey  =  await this.getPublicKey(id, true);
							if( ! await this.Verify(stockNote.hash, VerifyKey, stockNote.transTime) ) {
								hash 		= false;
								stockNote 	= {};
								continue;
							}
							
							noteAddress 	= stockNote.address;
							// delete note.stockNotes[x];
							// delete agreement.investorsHub[ agreement.investorsHub.indexOf( hash ) ];
							isQuoted 		= true;
							break;
						}
					}
					else if( details.transType == "QUOTEBOND" && note.bondNotes && note.bondNotes.length > 0 ) {
						let x;
						for( x = 0; x < note.bondNotes.length; x++ ){
							stockNote 		= JSON.parse( JSON.stringify( note.bondNotes[x] ) );
							var signature  = stockNote.hash;
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( agreement.budgetKey, id );
							var VerifyKey  =  await this.getPublicKey(id, true);
							var VerifyText = stockNote.transTime + stockNote.value;
							hash			= this.hashed( string );
							if( ! await this.Verify(signature, VerifyKey, VerifyText) ){
								hash 	= false;
								stockNote = {};
								continue;
							}
							
							noteAddress 	= stockNote.address;
							// delete note.bondNotes[x];
							// delete agreement.investorsHub[ agreement.investorsHub.indexOf( hash ) ];
							isQuoted 		= true;
							break;
						}
					}
					
					
					if( ! noteAddress ) {
						agreement.transKey = await this.generateKey( 20, true );
						var id 				= await this.generateKey(10);	
						await this.setPrivateKey( agreement.transKey, id );
						noteAddress = await this.getPublicKey(id);					
					}
					
					if( ! stockNote.address )
						stockNote.address = noteAddress;
					
					stockNote.transTime = this.currentTime();
					
					//before encrypting the agreement for the recipient, let'this.s add the recipient
					//as a valid investor to the budget.
					
					if( details.transType == "QUOTESTOCK" ){
						if( isQuoted ){
							agreement.pay 		= ( parseFloat( agreement.pay ) + parseFloat( stockNote.pay ) ).toString();
							agreement.stock 	= ( parseFloat( agreement.stock ) + parseFloat( stockNote.stock ) ).toString();						
						}
						
						this.signText 		= stockNote.transTime.toString() + agreement.pay + agreement.stock;
						stockNote.pay 		= agreement.pay;
						stockNote.stock 	= agreement.stock;
					}
					
					else if( details.transType == "QUOTEBOND" ) {
						if( isQuoted ){
							agreement.value 	= ( parseFloat( agreement.value ) + parseFloat( response.transValue ) ).toString();						
						} else {
							agreement.value 	= parseFloat( response.transValue ).toString();
						}
						
						this.signText 		= stockNote.transTime.toString() + agreement.value;
						stockNote.value 	= agreement.value;
					}
					
					
					this.signKey 			= agreement.privateKey;
					stockNote.hash			= await this.Sign(this.signKey, this.signText);
					
					//we direct the transaction to the stock note.
					if( isQuoted ){
						var id 				= await this.generateKey(10);
						await this.setPublicKey( noteAddress, id );
						
						newBlock.recipient = await this.#encrypt( agreement, id );
						//help the network quickly discover this block using the budget id.
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( agreement.budgetID, id );
						newBlock.budgetID 	= await this.getPublicKey(id);
					}
					else {
					
						//save the current note so that we can configure the stock note already.
						note.blockID 		= newBlock.blockID;
						
						this.noteAddress		= note.noteAddress;
						currentNote			= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
						currentNote.noteAddress  	= noteAddress;
						currentNote.noteSecret  	= agreement.transKey;
						
						if( details.transType == "QUOTESTOCK" ){
							currentNote.noteValue 	= details.agreement.stock;
							currentNote.pay			= details.agreement.pay;
						}else if( details.transType == "QUOTEBOND" ){
							currentNote.noteValue 	= response.transValue;
						}
						currentNote.transType 		= details.transType;
						currentNote.motherKey 		= this.noteAddress;
						currentNote.transValue 		= details.transValue;
						currentNote.noteType		= details.agreement.stockID;//this also contains the bondkey for bond
						currentNote.noteServer		= this.#default_scriptbill_server;
						currentNote.walletID		= this.walletID;
						currentNote.blockID			= newBlock.blockID;
						currentNote.budgetID 		= agreement.budgetID;
						currentNote.budgetValue		= agreement.value;
						currentNote.budgetKey 		= agreement.budgetKey;
						this.#isQuotedNote			= true;
					}
					
					if( details.transType == "QUOTESTOCK" ){
						if( ! note.stockNotes || ! note.stockNotes.length || ! typeof note.stockNotes == "object" )
							note.stockNotes = [];
						
						note.stockNotes.push( stockNote );
					}
					else if( details.transType == "QUOTEBOND" ){
						if( ! note.bondNotes || ! note.bondNotes.length || ! typeof note.bondNotes == "object" )
							note.stockNotes = [];
						
						note.bondNotes.push( stockNote );
					}
						
					//the main data that will be transaferred to the recipient will be deleted
					//before adding the budget data to a public view in the agreement handler.
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( agreement.budgetID, id );
					var signKey 			= agreement.privateKey;
					delete agreement.transKey;
					delete agreement.stock;
					delete agreement.pay;
					delete agreement.privateKey;
					delete agreement.budgetKey;
					
					agreement.budgetID 		= await this.getPublicKey(id);
					
					newBlock.agreement 		= agreement;
					newBlock.transValue 	= this.detils.transValue;
					newBlock.transType 		= details.transType;
					newBlock.noteValue 		= isQuoted ? newBlock.noteValue : currentNote.noteValue;
					newBlock.noteType 		= isQuoted ? note.noteType : currentNote.noteType;
					
					newBlock.blockRef 		= await this.getPublicKey(id, true);
					var signTxt 			= response.signRef;
					newBlock.signRef		=  await this.Sign( signKey, signTxt );
					
					newBlock.splitID 		= this.Base64.encode( await this.generateKey(newBlock.blockID.length) ).toString().slice(0, newBlock.blockID.length );
					
					//
					
				}  else if( ( details.transType == "SOLDBOND" || details.transType == "SOLDSTOCK" ) && response && ( response.transType == "BUYSTOCK" || response.transType == "BUYBOND" || response.transType == "INVEST" ) ) {
					let privKey = false;
					if( response.transType == details.transType ) {
						
						if( response.transType == "BUYBOND" )
							details.transType = "SOLDBOND";
						
						else if( response.transType == "INVEST" ){
							if( ! response.agreement.budgetType )
								details.transType 	= "INVESTRECIEVE";
							
							else if( response.agreement.budgetType == "business" )
								details.transType 	= "SOLDSTOCK";
							else if( response.agreement.budgetType == "governmental" )
								details.transType 	= "SOLDBOND";
							
						}
						else
							details.transType 	= "SOLDSTOCK";
					}
					transType 			= details.transType;
					
					//most of the time the blockKey is what is used to make the transaction not the noteAddress because
					//it is a public exchange transaction. But ofr a credit note type, it must be the note that created
					//the budget. So we use the note'this.s budget private keys to verify that the transaction was pointing to us.
					let x, agree;
					let agreement 		= false;
					
					let exchangeNote 	= await this.getCurrentExchangeNote(  note.noteType );
					let budgetKey 		= false;
					var id 				= await this.generateKey(10);
					if( ! this.#isExchangeMarketMining ){
					
						for( x = 0; x < note.noteBudgets.length && response.transType != "INVEST"; x++ ){
							
							await this.setPrivateKey( note.noteBudgets[x], id );
							agree 		= await this.#decrypt( response.recipient, id );
							
							if( ! this.isJsonable( agree ) ) continue;
							
							privKey 		= note.noteBudgets[x];
							agreement 		= JSON.parse( agree );
							break;
						}
						//but an invest transaction will always be from a stock or bond note held by 
						//the holder, this means the stock note must have used the budget key of The
						//budget to recieve an exchange transaction and send the proceed to the 
						//connected note of the budget so we use the note secret to recieve this 
						//transaction.
						
						if( response.transType == "INVEST" ){
							
							await this.setPrivateKey( note.noteSecret, id );
							agreement 		= await this.#decrypt( response.recipient, id );
							
							if( agreement ){
								if( agreement.budgetID )
									privKey 		= agreement.budgetID;
								//since we have gotten the private key of the budget.
								//if this is actually the private key then we can escape the part where 
								//the original budget will be queried from the budget's private key, if not 
								//found the function returns fals;
								
								if( agreement.budgetKey )
									budgetKey 		= agreement.budgetKey;
								
								await this.setPrivateKey( privKey, id );
							}
							
						}
						
						//the agreement muust be succcessfully decrypted and parsed to continue the
						//transaction.
						if( ! typeof agreement == "object" ) return response;
					
					} else {
						//if directed to the exchange market directly.
						//most of the time it will be directed to the public market using the budget's
						//key
						await this.setPrivateKey( note.noteSecret, id );
						agree 		= await this.#decrypt( response.recipient, id );
						
						if( ! this.isJsonable( agree ) ) return response;
						
						//if it was the public exchangeNote, then we can also escape the budget block query
						//using the public budget key on the note.
						this.setPublicKey( note.budgetID, id );
						agreement 		= JSON.parse( agree );
					}
					
					if( /* ! this.#isExchangeMarketMining &&  */! this.#fiatCurrencies[ testType ] || ( this.#fiatCurrencies[ testType ] && details.transType == "SOLDSTOCK" ) ){
						//testing the budget id.
									
						
						this.budgetBlock 		= await this.getCurrentBudgetBlock( await this.getPublicKey(id), true );
						
						if( ! this.budgetBlock.length && ! this.budgetBlock[0].blockID  && ! agreement ) return false;
						
						//if the public budget was found by querying the detabase, then we should have the exchange NOTE
						//intact if true. The buyer must then wait for an agreement requeest from the budget creator//to get the budget private key on their stock or bond note that would be generated.
						if( this.budgetBlock[0].exchangeNote && this.budgetBlock.exchangeNote[0].exchangeID != note.noteAddress && this.#isExchangeMarketMining ){
							thie.errorMessage("exchange note compromised!");
							return false;
						}
						
						
						let transTimes = this.budgetBlock.map( (block)=>{
							return parseInt( block.transTime );
						});
						
						let sortedTimes = transTimes.toSorted( (a,b)=>{
							return b - a;
						});
						
						let index 		= transTimes.indexOf( sortedTimes[0] );
						
						//come with the most recent information on the exchange market.
						this.budgetBlock 	= JSON.parse( JSON.stringify( this.budgetBlock[index] ));
						
						if( details.transType == "SOLDBOND" && ( ! this.budgetBlock.agreement || this.budgetBlock.agreement.budgetType != "governmental" ) ) {
							this.errorMessage("Can't sell Bond without a governmental budget!");
							return false;
						} 
						else if( details.transType == "SOLDSTOCK" && ( ! this.budgetBlock.agreement || this.budgetBlock.agreement.budgetType != "business" || this.budgetBlock.agreement.budgetType != "recursive" ) && ! this.budgetBlock.productNote ){
							this.errorMessage("Can't sell Stock without a valid business budget!");
							return false;
						}

						//all checks for authencity had been completed.
						
					} else {
						this.budgetBlock 			= JSON.parse( JSON.stringify( this.defaultBlock ));
						this.budgetBlock.agreement 	= JSON.parse( JSON.stringify( this.budgetConfig ));
						this.budgetBlock.agreement.budgetType = "governmental";
						let Private 				= motherKeys.budgetIDS[note.noteType ];
						var id 						= await this.generateKey(10);
						await this.setPrivateKey( Private, id );
						this.budgetBlock.agreement.budgetID 	= await this.getPublicKey(id);
						this.budgetBlock.agreement.budgetValue = Infinity;
						this.budgetBlock.agreement.sleepingPartner = "percent-high";
						this.budgetBlock.agreement.sleepingPartnerShare = 0.5;
						this.budgetBlock.agreement.workingPartner = "percent-high";
						this.budgetBlock.agreement.workingPartnerShare = 0.5;
						this.budgetBlock.agreement.value = exchangeNote ? exchangeNote.exchangeValue : details.transValue;
						this.budgetBlock.agreement.agreement 	= await this.createAgreement(await this.generateKey(10), newBlock );
						this.budgetBlock.agreement.agreement.value = response.transValue;	
						
						if( ! this.budgetBlock.agreement.agreement.senderID ){
							this.budgetBlock.agreement.agreement.senderID = newBlock.blockID;
						}
						
						var signTxt		= this.budgetBlock.agreement.agreement.senderID;
						this.budgetBlock.agreement.agreement.senderKey		= await this.generateKey(10, true, true );
						var signKey 		= this.budgetBlock.agreement.agreement.senderKey;
						this.budgetBlock.agreement.agreement.senderSign = this.Sign(signKey, signTxt );
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( this.signKey, id );
						this.budgetBlock.agreement.agreement.senderKey 	= await this.getPublicKey(id, true);
						newBlock.exchangeNote.agreement 				= this.signKey;
						currentNote.agreement 			= this.signKey;
						
						if( this.#isExchangeMarketMining )
							note.agreement 				= this.signKey;
						
						this.budgetBlock.agreement.agreement.agreeType 	= "BOND";
						this.budgetBlock.agreement.agreement.interestRate = (this.interestRate / 2 ).toFixed(2);
						this.budgetBlock.agreement.agreement.interestType = "FIXED";
						this.budgetBlock.agreement.agreement.ExecTime 	= this.currentTime() + ( this.calculateTime( ( response.agreement.payPeriod ? response.agreement.payPeriod : "1 Months") ) ? this.calculateTime( ( response.agreement.payPeriod ? response.agreement.payPeriod : "1 Months") ) : this.calculateTime( "1 Months" ) );
						this.budgetBlock.agreement.agreement.payPeriod 	= "1 Days";
						this.budgetBlock.agreement.agreement.payTime 	= this.currentTime() + this.calculateTime( this.budgetBlock.agreement.agreement.payPeriod );
					}
					
					//the current note is now updated if the response ransaction type is invest.
					if( response.transType == "INVEST" ){
						note.noteValue 			= parseFloat( note.noteValue ) + parseFloat( response.transValue );
					}
					
					
					
					if( this.budgetBlock.agreement.budgetType == "governmental" ){
						//this shows that the exchange market is selling bonds.
						if( ! currentNote && exchangeNote && exchangeNote.exchangeID )
							currentNote = JSON.parse( JSON.stringify( exchangeNote ));
						
						//since it's only exchange note that sells bond.
						//we check the current note running.
						/* if( note.noteAddress != currentNote.noteAddress ){
							if( newBlock.exchangeNote && note.noteAddress == newBlock.exchangeNote.exchangeID )
								currentNote = note;
							
							else if( this.#isExchangeMarketMining ){
								note = currentNote;
								
								if( ! note.noteAddress && newBlock.exchangeNote ){
									note.noteAddress = newBlock.exchangeNote.exchangeID;
									note.noteSecret = newBlock.exchangeNote.exchangeKey
								}
							}
						} */
						
						if( response.transType != "INVEST" )
							currentNote.exchangeValue += parseFloat(response.transValue );
						//currentNote.noteValue 	+= parseFloat(response.transValue );
						currentNote.transType 	= "SOLDBOND";
						currentNote.blockID 	= newBlock.blockID;
						newBlock.transType 		= "SOLDBOND";
						newBlock.transValue 	= response.transValue;
						newBlock.exchangeNote 	= JSON.parse( JSON.stringify( currentNote ));
					} else if( this.budgetBlock.agreement && this.budgetBlock.agreement.budgetType == "business" ){
						//the stockID of the product note is stored in the note type.
						//doesn't affects transaction to it.
						let productNote 	= await this.getCurrentExchangeNote( this.budgetBlock.productNote.noteType );
						
						if( ! productNote || ! productNote.exchangeID ){
							this.errorMessage("Couldn't find current product note information. Using the default one instead");
							productNote 	= JSON.parse( JSON.stringify( this.budgetBlock.productNote ));
						}
						
						if( response.transType != "INVEST" )
							productNote.exchangeValue += parseFloat(response.transValue );
						//currentNote.noteValue 	+= parseFloat(response.transValue );
						productNote.transType 	= "SOLDSTOCK";
						productNote.blockID 	= newBlock.blockID;
						newBlock.transType 		= "SOLDSTOCK";
						newBlock.transValue 	= response.transValue;
						newBlock.productNote 	= JSON.parse( JSON.stringify( productNote ));
					} else {
					
						newBlock.transValue 	= response.transValue;
					}
					
					//recieving the transaction value into the note.
					/* if( note.noteType == response.noteType )
						note.noteValue 			+= parseFloat( details.transValue );
					
					else {
						let exValues = await this.getExchangeValue( note.noteType, response.noteType );
						let exValue = exValues[0];
						note.noteValue 	+= (parseFloat( details.transValue) * exValue );
					} */
					
					let prodAgree = JSON.parse( JSON.stringify( this.budgetBlock.agreement ));
					let budgetValue = prodAgree.value;
					let rankFound = false;
					
										
					if( ! agreement.privateKey ) {
						this.errorMessage("No Private Key in the transaction agreement, This may hinder the verification for recieving this block. Investment Recieve Transaction Aborting!!!");
						return false;
					}
					
					//adding the budget private key to the agreement that will be sent
					//to the stock or bond quoter.
					prodAgree.budgetID 			= privKey;
					
					if( ! note.budgetKey && details.transType != "INVEST" && note.budgetID )
						note.budgetKey 			= await this.generateKey( 10, true, true );
					
					if( note.budgetKey ){
						prodAgree.budgetKey 	= note.budgetKey;
					}
					else if( budgetKey ){
						prodAgree.budgetKey 	= budgetKey;
					}
									
					//this is because the note can have more than one ranks
					/* if( prodAgree.companyRanks && note.companyRanks && typeof note.companyRanks == 'object' ) {
						let ranks = note.companyRanks;
						let q;
										
						for( q = 0; q < ranks.length; q++ ) {
							privKey = ranks[q];
							var string 	= privKey;
							pubKey  		= this.hashed( string );
							var string 	= pubKey;
							pubKey  		= this.hashed( string );
										
							//compare the pubkey gotten with the companyRank key
							//supplied.
							if( prodAgree.companyRanks.includes( pubKey ) ) {
								rankFound = true;
								break;
							}
						}
					} */
					if( prodAgree.companyRanks && agreement.companyRank && typeof agreement.companyRank == 'string' && prodAgree.companyRanks.length ) {
						let rank = agreement.companyRank;
						var string 	= rank;
						pubKey  		= this.hashed( string );
						var string 	= pubKey;
						pubKey  		= this.hashed( string );
									
						//compare the pubkey gotten with the companyRank key
						//supplied.
						if( prodAgree.companyRanks.includes( pubKey ) ) {
							rankFound = true;							
						}
						
					}
					let t, percent, stock, amount, total, pay;
					if( rankFound ) {
						t 		= prodAgree.workingPartner;
						percent = prodAgree.workingPartnerShare;
					} else {
						t 		= prodAgree.sleepingPartner;
						percent = prodAgree.sleepingPartnerShare;
					}
					//please note that the Pay Value is the total number of stock the exchange market will pay the Holder
					//while the stock value is the actual investment value with the budget.
					//on the agreement of the company. While the stock value is the actual value of the client'this.s investment
					switch(t){
						case 'percent-high':
							amount  = parseFloat( details.transValue ) * percent;
							total  	= parseFloat( details.transValue ) + amount;
							pay 	= total / budgetValue;
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							break;
						case 'percent-low':
							amount 	= parseFloat( details.transValue ) * percent;
							total  	= parseFloat( details.transValue ) - amount;
							pay  	= total / budgetValue;
							stock   = parseFloat( details.transValue ) / parseFloat( budgetValue );
							break;
						case 'percent-equal':
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock;
							break;
						case 'dividend-high':
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock + percent;
							break;
						case 'dividend-equal':
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock;
							break;
						case 'dividend-low':
							stock  	= parseFloat( details.transValue  )/ parseFloat( budgetValue );
							pay 	= stock - percent;
							break;
						default :
							stock  	= parseFloat( details.transValue ) / parseFloat( budgetValue );
							pay 	= stock;
					}
					
					newBlock.transType 			= details.transType;
					prodAgree.pay 				= pay;
					prodAgree.stock				= stock;
					var id 						= await this.generateKey(10);
					prodAgree.privateKey 		= agreement.privateKey;
					await this.setPrivateKey( prodAgree.privateKey, id );
					newBlock.blockRef		= await this.getPublicKey(id, true);
					newBlock.signRef		=  await this.Sign(prodAgree.privateKey, response.signRef);
					newBlock.transValue		= details.transValue;
					let sbLink =  "https://t.ly/1RYEc";
					if( this.#isExchangeMarketMining && note.accountData && response.transType != "INVEST" ){
						let email, phone, pass;
						if( note.accountData.emails && note.accountData.emails.length ){
							email 				= not.accountData.emails[0];
							pass 				= await this.generateKey(10);
							var string 		= email + pass;
							details.recipient 	= this.hashed( string );
							this.successMessage("I Have Just Sent You " + details.transValue + " " + testType + " In Scriptbill Bonds.  Visit " + sbLink + " to download the Scriptbill browser extension, usable with Kiwi Mobile browser and Login With The Username: " + email + " and Shared Trans Key: " + pass + ".");
						}
						else if( note.accountData.phones && note.accountData.phones.length ){
							phone 				= note.accountData.phones[0];
							pass 				= await this.generateKey(10);
							var string 		= phone + pass;
							details.recipient 	= this.hashed( string );
							this.successMessage("I Have Just Sent You " + details.transValue + " " + testType + " In Scriptbill Bonds.  Visit " + sbLink + " to download the Scriptbill browser extension, usable with Kiwi Mobile browser and Login With The Username: " + phone + " and Shared Trans Key: " + pass + ".");
						}
						this.#set_pass = details.recipient;
					} else if( response.transType == "INVEST" && agreement.recipient ){
						details.recipient 	= agreement.recipient;
					} else {
						details.recipient = response.blockKey;
					}
					 
					newBlock.recipient 	= this.encrypt( JSON.stringify( prodAgree ), details.recipient );
					//taking of the sensitive information that was added to the agreement before adding it publicly for any other user to see.
					delete prodAgree.pay;
					delete prodAgree.stock;
					delete prodAgree.privateKey;
					delete prodAgree.budgetKey;
					newBlock.agreement 	= JSON.parse( JSON.stringify( prodAgree ));
					//newBlock.exchangeNote 	= JSON.parse( JSON.stringify( currentNote ));
										
				} else if( details.transType == "EXCHANGE" && ( response && this.#transSend.includes(  response.transType ) ) ) {
				
					//console.log("Inside Exchange");
						
					let blockID 				= newBlock.blockID;
					let formerBlockID 			= newBlock.formerBlockID;
					let nextBlockID 			= newBlock.nextBlockID;
					let wID 					= newBlock.walletHASH;
					let fwID					= newBlock.formerWalletHASH;
					let nwID					= newBlock.nextWalletHASH;
					newBlock 				= JSON.parse( JSON.stringify( details ));
					newBlock.blockID 		= blockID;
					newBlock.formerBlockID = formerBlockID;
					newBlock.nextBlockID 	= nextBlockID;
					newBlock.walletHASH	= wID;
					newBlock.formerWalletHASH	= fwID;
					newBlock.nextWalletHASH	= nwID;
				
					if( ! details.sellCredit || ! details.buyCredit ) {
						this.errorMessage("Can't continue an Exchange Transaction Without Appropraite Credits!!!");
						return false;
					}
					
					
					this.noteTypeS  = details.buyCredit;
					let buyBlock	= await this.getTransBlock(1);
					this.sellCredit = details.sellCredit;
					let sellBlock 	= await this.getTransBlock(1);
					
					if( ! buyBlock.length ) {
						this.errorMessage("Can't buy Credit from a Credit not Included into Scriptbills. You can as well include it by Creating a Scriptbill Note with the Credit Information");
						return false;
					}
					
					//
					
					 if( response && response.transValue < details.transValue && this.#transSend.includes( response.transType ) ){
						this.errorMessage("Your Transaction Block Value is Lesser Than The Requested Block Value. Exchange Transaction Now Aborting!!!");
						return false;
						
					}else if( response.blockID == currentNote.blockID ){
						//this shows that the current note was the initiator of the exchange
						this.blockID			= currentNote.blockID;
						let transBlock			= await this.getTransBlock();
						transBlock 				= transBlock[0];
						
						if( transBlock && transBlock.blockID ){
							//to get the correct hash value of the transblock, we remove the variables,				
							var string 		= JSON.stringify( transBlock );
							let transHash		= this.hashed( string );
							var string 		= JSON.stringify( currentNote );
							let noteHASH 		= this.hashed( string );
							let joinNote 		= response.noteHash + currentNote.noteHash;
							let joinTrans 		= response.transHash 	+ currentNote.transHash;
							
							if( joinNote != noteHASH && joinTrans != transHash ){							
								this.errorMessage("Exchange Error: Supply Transaction Not Verified!!");
								return false;
							} else if( response.transType != "DEPOSIT" ){
								//next is verify the recipient of the transaction.
								//if the transaction is not a fiat based transaction, then the exchange note should 
								//be the recipient.
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( response.exchangeNote.exchangeKey, id );
								agreement 		= await this.#decrypt( response.recipient, id );
								
								if( ! this.isJsonable( agreement ) ){
									this.errorMessage("Exchange Error: Supply Transaction Not Verified!!");
									return false;
								}
							}
						} else {
							this.errorMessage("Exchange Error: Supply Transaction Not Verified!!");
						}
					}
					else if( response && response.recipient ){
						//we check if the response was initiate by another client but for this note.
						
						if( response.productID && ( response.transType == "BUYPRODUCT" || response.transType == "PRODUCTSUB" )){
							//this shows the note must have sold a product to acquire this credit he would love to
							//exchange.
							let x;							
							for( x = 0; x < note.noteProducts.length; x++ ){
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( note.noteProducts[x], id );
								agreement 		= await this.#decrypt( response.recipient, id );
								
								if( this.isJsonable( agreement ) ){
									break;
								}
							}
							
							if( ! agreement || ! this.isJsonable( agreement ) ){
								this.errorMessage("Error in Exhange: Product Transaction Block was not verified to be sold by your note to initiate this exchange.");
								return false;
							}
						}
						else if( response.productID && response.transType == "PROFITSHARING" ){
							//this shows the note is actually recieving a profit base transaction,
							let x;
							for( x = 0; x < note.profitKeys; x++ ){
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( note.profitKeys[x], id );
								agreement 		= await this.#decrypt( response.recipient, id );
								
								if( this.isJsonable( agreement ) ){
									break;
								}
							}
							
							if( ! agreement || ! this.isJsonable( agreement ) ){
								this.errorMessage("Error in Exhange: Profit Sharing Transaction is not verified to be shared to your note...");
								return false;
							}
						}
						else {
							//test first with the note'this.s secret
							/* if( noteSecret == note.noteSecret && ! isNew && ! this.#isExchangeMarketMining ){
								var string 			= transKey;
								note.noteSecret 	= this.decrypt( noteSecret, this.hashed( string ) );
							} */
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( note.noteSecret, id );
							agreement 		= await this.#decrypt( response.recipient, id );
							
							if( ! this.isJsonable( agreement ) ){
								//before returning the transaction we try the block keys.
								await this.setPrivateKey( note.blockKey, id );
								agreement 			= this.decrypt( response.recipient, await this.getPublicKey( id, true ) );
								
								if( ! this.isJsonable( agreement ) ){
									//then we try the budget keys if present.
									let x;
									for( x = 0; x < note.noteBudgets.length; x++ ){
										var id 				= await this.generateKey(10);
										await this.setPrivateKey( note.noteBudgets[x], id );
										agreement 	= await this.#decrypt( response.recipient, id );
										
										if( this.isJsonable( agreement ) ) break;
									}
									
									if( ! agreement || ! this.isJsonable( agreement ) ){
										this.errorMessage("Error in Exhange: Transaction Block is not verified to be sent to your Note...");
										return false;
									}
								}														
							}
						}
					}
					else if( ! response ){
						this.errorMessage("You Cannot Ignite an Exchange Transaction Without a Readiness to Supply Credits to the Exchange market!!!");
						return false;
					} else {
						let sellCredit;
						if( details.sellCredit.lastIndexOf("CRD") < 0 ){
							sellCredit 		= details.sellCredit;
						}
						else if( ( details.sellCredit.length - details.sellCredit.lastIndexOf("CRD") ) == 3 ){
							sellCredit = details.sellCredit.slice( details.sellCredit.lastIndexOf("CRD"),  details.sellCredit.length);
						}
						else {
							sellCredit = details.sellCredit;
						}			
					}
					
					//next is to bill the client
					//there are three ways to bill the client
					//first is to check the response variable, if the response is a Scriptbill block, and the
					//block is a send block already tested above, and the client can actually decrypt the recipient
					//handler, we accept it as a means of payment.
					if( response.blockID ){
						this.response 	= JSON.parse( JSON.stringify( response ) );
						this.#noVerify	= false;
						let verify 		= this.storeBlock(response, note);
						
						if( ! verify && note.noteType == details.sellCredit ) {
							delete response.blockID;
							return await this.generateScriptbillTransactionBlock();
						}
					}
					
					let secret;
					if( ! sellBlock || ! sellBlock.length || ! sellBlock[0].exBlockID ) {
						//generating the exchange keys and IDs
						newBlock.exchangeKey 	= await this.generateKey( 30, true );
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( newBlock.exchangeKey, id );
						newBlock.exchangeID 	= await this.getPublicKey(id);
						
						//generating the exchange block IDs.
						secret = note.noteSecret;
						note.noteSecret 		= newBlock.exchangeKey;
						this.sit 				= "Calculating block ID for exchange " + details.transType;
						newBlock.exBlockID 	= await this.calculateNextBlockID(note);
						newBlock.exNextBlockID = await this.calculateNextBlockID(note, newBlock.exBlockID );
						newBlock.exFormerBlockID = "";
						note.noteSecret 		= secret;
						
						//adding the totalUnits.
						newBlock.totalUnits 	= details.transValue;
					} else {
						sellBlock					= sellBlock.length ? sellBlock[ sellBlock.length - 1 ] : sellBlock;
						newBlock.exchangeKey = sellBlock.exchangeKey;
						newBlock.exchangeID  = sellBlock.exchangeID;
						
						//generating the exchange block IDs.
						secret 						= note.noteSecret;
						note.noteSecret		= newBlock.exchangeKey;
						this.sit 				= "Calculating Block ID for Exchange " + details.transType;
						newBlock.exBlockID 	= await this.calculateNextBlockID(note, sellBlock.exBlockID);
						newBlock.exNextBlockID	= await this.calculateNextBlockID(note, newBlock.exBlockID);
						newBlock.exFormerBlockID = sellBlock.exBlockID;
						
						//adding the total units.
						newBlock.totalUnits 	= parseInt( sellBlock.totalUnits ) + parseInt( details.transValue );
					}				
				}else if( details.transType == "UPDATE" || details.transType == "UPDATEPRODUCT" || details.transType == "DEPOSIT" || details.transType == "LOAN" ){
					/* let uBlockID = newBlock.blockID;
					let uNextBlockID = newBlock.nextBlockID;
					let uFormerBlockID = newBlock.formerBlockID;
					let uWalletHash 	= newBlock.walletHASH;
					let uNextWalletHash = newBlock.nextWalletHASH;
					let uFormWalletHash = newBlock.formerWalletHASH;
					let agreements 		= newBlock.agreements;
					let exNote 	 		= newBlock.exchangeNote;
					
					newBlock   			= JSON.parse( JSON.stringify( details ) );
					newBlock.blockID		= uBlockID;
					newBlock.nextBlockID	= uNextBlockID;
					newBlock.formerBlockID	= uFormerBlockID;
					newBlock.walletHASH	= uWalletHash;
					newBlock.formerWalletHASH = uFormWalletHash;
					newBlock.nextWalletHASH	= uNextWalletHash;
					newBlock.transValue    = 0;
					newBlock.noteValue 	= note.noteValue;
					newBlock.noteType		= note.noteType;
					newBlock.agreements 	= agreements;
					newBlock.exchangeNote 	= exNote; */
					
					//console.log("newblock deposit: " + JSON.stringify( newBlock ));
					this.#note 		= JSON.parse( JSON.stringify( note ));
					this.details 	= JSON.parse( JSON.stringify( details ));
					note 			= await this.#updateNote( note, details );
					
					//checking things that has updated in the details that are not updated in the note.
					if( details.businessKey && details.businessKey != note.BMKey ){
						note.BMKey = details.businessKey;
					}
					 if( details.noteServer && details.noteServer != note.noteServer ){//LOOKBACK
						note.noteServer = details.noteServer;
					}
					 if( details.interestRate && details.interestRate != note.interestRate ){
						note.interestRate 	= details.interestRate;
					}
					
					if( details.interestType && details.interestType != note.interestType ) {
						note.interestType 	= details.interestType;
					}
					
					if( details.transType == "UPDATEPRODUCT" && ! details.productID ){
						this.errorMessage("We couldn't find a product to update from the information provided!");
						return false;
					}					

					if( details.transType == "DEPOSIT" && ( ( ! response || response.transType != "WITHDRAW" ) && ! this.#isExchangeDeposit ) ){
						this.errorMessage("Can't Deposit Funds to Your Note Without a Corresponding Withdrawal Request!");
						return false;
					}
					
					if( details.transType == "DEPOSIT" && ( ( response &&  response.transType == "WITHDRAW") || this.#isExchangeDeposit ) ){
							if( typeof note.agreements != "object" )
								note.agreements 	= [];
							
							//console.log( "Deposit trans value: " + details.transValue );
							//console.log( "Deposit note value 3: " + note.noteValue );			
							
							//console.log("newBlock Deposit Agreement: " + JSON.stringify( newBlock ), " The Agreement if found: " + JSON.stringify( details.agreement ));
							
							if( ! this.#isExchangeDeposit && response && response.transType == "WITHDRAW" ){								
													
								//console.log("response withdraw");

								newBlock.transValue 	= details.transValue;
								let exNote 				= await this.getCurrentExchangeNote( note.noteType );
								
								if( exNote && exNote.exchangeID && exNote.noteType == note.noteType )
									newBlock.exchangeNote 	= JSON.parse( JSON.stringify( exNote ));
								
								delete newBlock.agreement;
													
								if( ! response.agreement )
									details.agreement = await this.createAgreement("", newBlock);
								
								else
									details.agreement  = JSON.parse( JSON.stringify( response.agreement ) );
								
								if( details.agreement ){
									
									if( details.agreement.privateKey && this.#createdAgreement ){
										note.agreements.push( { agreeID: details.agreement.agreeID, key:details.agreement.privateKey} );
										this.#createdAgreement	= null;
										delete details.agreement.privateKey;
									}
									
									if( ! details.agreement.ExecTime ) {
										//console.log( details.agreeement );
										details.agreement.ExecTime 	= parseInt( this.currentTime() ) + parseInt( this.calculateTime( "3 Days" ) );
									}
									
									if( ! details.agreement.value || details.agreement.value != details.transValue )
										details.agreement.value 	= details.transValue;
									
									if( ! details.agreement.privateKey )
										privKey		= await this.generateKey( 30, true, true );
									
									else
										privKey 	= details.agreement.privateKey;
									
									var id 				= await this.generateKey(10);
									await this.setPrivateKey( privKey, id );
									details.agreement.privateKey 	= privKey;
									
									//NOT REALY PART OF THE CODE, JUST ADDING IT FOR DEBUG PURPOSE THANKS.
									if( location.origin.includes("scriptbank") && ( location.href.includes("checkout") || this.#isExchangeDeposit ) ){
										this.s.depositKey 		= privKey;
									}
									
									if( details.agreement.agreeID == "" ) {
										details.agreement.agreeID = response.blockKey;
									}
									
									newBlock.transType 			= "DEPOSIT";
									details.agreement.agreeType 	= "DEPOSIT";
									newBlock.blockRef				= await this.getPublicKey(id, true);
									newBlock.signRef				= await this.Sign( privKey, response.signRef);
									newBlock.recipient 			= this.encrypt( JSON.stringify( details.agreement ), details.agreement.agreeID  );
									newBlock.exchangeNote 			= JSON.parse( JSON.stringify( response.exchangeNote ));
							
									if( newBlock.agreements[ details.agreement.agreeID ] ){
										let agreeBlock 		= await this.getTransBlock(1, {blockID: newBlock.agreements[ details.agreement.agreeID ]});
										
										if( agreeBlock.length && agreeBlock[0].agreement && agreeBlock[0].agreement.agreeID == details.agreement.agreeID ){
											newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
											agreeBlock[0].agreement.value = parseFloat(agreeBlock[0].agreement.value ) + parseFloat( details.agreement.value );
											newBlock.agreement 		= JSON.parse( JSON.stringify( agreeBlock[0].agreement ));
											/* newBlock.agreements[ details.agreement.agreeID ].value = parseFloat( newBlock.agreements[ details.agreement.agreeID ].value ) + parseFloat( details.agreement.value ); */
										} else {
											newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
											newBlock.agreement 	= JSON.parse( JSON.stringify( details.agreement ));
										}
										
									} else {
									
										newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
										newBlock.agreement 	= JSON.parse( JSON.stringify( details.agreement ));
									}
									
								}
								newBlock.isExchangeMarketMining		= 0;
							} else {
								//console.log("Response Exchange");
								if( ! this.#currentNote ){
									this.#currentNote 	= await this.getCurrentExchangeNote( note.noteType );
								}

								if( ! this.#currentNote || typeof this.#currentNote != "object" || ! this.#currentNote.exchangeID ){
									this.errorMessage("We Couldn't find an Exchange note connected to this note type " + note.noteType + " to authorize this deposit.");
									return false;
								}
								
								newBlock.exchangeNote 			= JSON.parse( JSON.stringify( this.#currentNote ));
								newBlock.exchangeNote.transID 	= await this.generateKey(15);
								let transKeey 					= await this.generateKey( 10, true, true );
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( transKeey, id );
								newBlock.exchangeNote.transKey 	= await this.getPublicKey(id,true);
								
								if( this.#fiatCurrencies[ testType ] )
									newBlock.exchangeNote.noteServer 	= this.#default_scriptbill_server;
								
								await this.resolveRemoteData( ['transID', 'transKey', 'exID'], [ newBlock.exchangeNote.transID, transKeey, newBlock.exchangeNote.walletID ], newBlock.exchangeNote.noteServer, 'POST' );
								newBlock.exchangeNote.transSign 	= await this.Sign(transKeey, newBlock.exchangeNote.transID );
								//because the deposit is targeted at the exchange market
								//the note value representing the total fiat credit
								//supplied to the exchange market will remain at the note
								//of the exchange note. The total value may not be 
								//ultimately correct but verifiers will have a way of 
								//correcting this value during verification process.
								newBlock.exchangeNote.noteValue 	= parseFloat( newBlock.exchangeNote.noteValue ) + parseFloat( details.transValue );
								
								//since new credits is created to the exchange network of 
								//the exchange market during deposit to the exchange market
								//we increase the demand value of the exchange market.
								//however, the demand value should only be increased if
								//the supply value is low and can't handle the request.
								
								if( newBlock.exchangeNote.exchangeValue >= details.transValue )
									newBlock.exchangeNote.exchangeValue = parseFloat( newBlock.exchangeNote.exchangeValue ) - parseFloat( details.transValue );
								
								else 
									newBlock.exchangeNote.demandValue 	= parseFloat( newBlock.exchangeNote.demandValue ) + parseFloat( details.transValue );
								
								
								if( this.depositInstance && this.depositInstanceKey ){
									
									details.agreement = await this.createAgreement( "", newBlock);
										
									note.agreements.push({ agreeID: details.agreement.agreeID, key: details.agreement.privateKey, signKey: details.agreement.senderSignKey });
									
									delete details.agreement.privateKey;
									delete details.agreement.senderSignKey;
									newBlock.agreement 					= details.agreement;
									
									//this does not make sense here
									if( details.agreement.agreeType == "ADVERT" ){
										this.s.advertAgreeID 			= details.agreement.agreeID;
										this.l.lastAgreeID 				= this.s.advertAgreeID;
									}
									
									
									if( newBlock.agreements[ details.agreement.agreeID ] ){
										this.blockID 		= newBlock.agreements[ details.agreement.agreeID ];
										let blk 			= await this.getTransBlock(1);
										let agrees 			= {};
										if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )	
											agrees 			= JSON.parse( JSON.stringify( blk[0].agreement ));
										
										newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
										
										agrees.value 		= parseFloat( agrees.value ? agrees.value:0) + parseFloat( details.agreement.value );
										newBlock.agreement 	= JSON.parse( JSON.stringify( agrees ));
										
									} else {										
										newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
									}
									
									
									
									newBlock.agreement.depositInstance = this.depositInstance;
									newBlock.agreement.depositInstanceKey = this.depositInstanceKey;
									
									if( this.depositServer )
										newBlock.agreement.depositServer = this.depositServer;
									
									if( this.depositType )
										newBlock.agreement.depositType 	= this.depositType;
									
									if( this.depositRequestType )
										newBlock.agreement.depositRequestType = this.depositRequestType;
									
									if( this.depositBody )
										newBlock.agreement.depositBody = this.depositBody;
									
									newBlock.isExchangeMarketMining		= 1;
								} else {
									this.errorMessage("Can't create deposit without a valid exchange key " );
									//console.log("key not present");
									return false;
								}
							}
							//console.log( "Deposit trans value 2: " + details.transValue );
							//console.log( "Deposit note value 3: " + note.noteValue );
							note.noteValue				= parseFloat( note.noteValue ) + parseFloat( details.transValue );
							newBlock.transValue 		= details.transValue;
							
						//referee
						if( note.referee ){
							let result = {};
							let accd 	= await this.getAccountData();
							result.loanValue = accd.loanValue;
							newBlock.referer 	= this.encrypt( JSON.stringify( result ), note.referee );			
						}
						
					}else if( details.transType == "LOAN" ){
						//update the note value of the credit to sign an agreement that returns the credit
						//to the exchange market based on the interest rate
						note.noteValue 			+= parseFloat( details.transValue );
						newBlock.transValue 	= details.transValue;
						let exNote 				= await this.getCurrentExchangeNote( note.noteType );
						
						if( exNote && exNote.exchangeID && exNote.noteType == note.noteType )
							newBlock.exchangeNote 	= JSON.parse( JSON.stringify( exNote ));
						
						//dealing with the agreement. The agreement has a public key created from the word
						//SCRIPTBANKLOANS. Any agreementID with this structure will be regarded as loan 
						//agreement in the code.
						
						let demandValue = newBlock.exchangeNote.demandValue ? parseFloat( newBlock.exchangeNote.demandValue ): 0.0;
			
						let exchangeValue = newBlock.exchangeNote.exchangeValue ? parseFloat( newBlock.exchangeNote.exchangeValue ): 0.0;
						
						let enoteValue = newBlock.exchangeNote.noteValue ? parseFloat( newBlock.exchangeNote.noteValue ): 0.0;
						
						let totalMinable 	= await this.calculateLoanEligibility();
						
						//check the minable instance of the exchange note and check if the 
						//exchangeNote could mine credits or has credit to fulfil this request
						
						if( totalMinable < details.transValue && exchangeValue < details.transValue ){
							this.errorMessage("The exchange market for this credit " + note.noteType + " is not able to give out loans at the moment. Create more deposits to enable mining.");
							return false;
						}
						
						newBlock.agreement 	= JSON.parse( JSON.stringify( details.agreement ) );
						/* var string 				= "SCRIPTBANKLOANS";
						this.signKey 				= privKey;
						this.signTxt				= this.hashed( string ); */
						newBlock.agreement					= await this.createAgreement("", newBlock, true );
						newBlock.agreement.value 			= details.transValue;
						newBlock.agreement.recieverID		= newBlock.blockID;
						privKey 							= await this.generateKey( 40, true, true );
						newBlock.agreement.recieverSign		= await this.Sign(privKey,newBlock.blockID);
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( privKey, id );
						newBlock.agreement.recieverKey		= await this.getPublicKey(id, true );
						newBlock.agreement.agreeType		= "LOAN";
						newBlock.agreement.payTime			= this.calculateTime(newBlock.agreement.payPeriod);
						
						if( ! newBlock.agreement.payTime || newBlock.agreement.payTime < 86400000 ){
							newBlock.agreement.payPeriod 		= "1 Days";
							newBlock.agreement.payTime			= this.calculateTime(newBlock.agreement.payPeriod);
							newBlock.agreement.times 			= 365;
						}
							
						
						if( ! note.agreements || typeof note.agreements != "object")
							note.agreements = [];
						
						note.agreements.push( { agreeID: newBlock.agreement.agreeID, key: newBlock.agreement.privateKey, signKey: privKey } );
						
						delete newBlock.agreement.privateKey;
						
						if( newBlock.agreements && Object.keys( newBlock.agreements ).includes( newBlock.agreement.agreeID ) ){
							this.blockID 	= newBlock.agreements[ newBlock.agreement.agreeID ];
							let blk 		= await this.getTransBlock();
							let agree  		= {};
							
							if( blk.length && blk[0].agreement && blk[0].agreement.agreeID )
								agree 		= JSON.parse( JSON.stringify( blk[0].agreement ));
							
							newBlock.agreement.value = parseFloat( agree.value ? agree.value : 0 ) + parseFloat( newBlock.agreement.value );
						} 
						
						newBlock.agreements[ newBlock.agreement.agreeID ] = newBlock.blockID;				
																
						
						
						this.account = await this.getAccountData();
						
						if( ! this.account )
							this.account = {};
						
						if( ! this.account.loanValue )
							this.account.loanValue 	= 0;
						
						if( ( this.account.loanID && this.account.loanID != "v/ylMo3bvINarUq89+AZBg==" ) || ( note.accountData && note.accountData.loanID ) ){
							this.blockID = this.account.loanID || note.accountData.loanID;
							let loanBlock = await this.getTransBlock();
							loanBlock 	= loanBlock[0];
							
							if( loanBlock && loanBlock.loanValue )
								this.account.loanValue = loanBlock.loanValue; 
							else {
								this.errorMessage("Fraudulent Loan Account Detected");
								return false;
							}
						}
						
						this.account.loanValue 		+= parseFloat( details.transValue );
						this.account.loanID 		= newBlock.blockID;
						newBlock.loanValue 	= this.account.loanValue;
						note.accountData 		= this.account[ note.noteAddress ];
						note.accountData.loanID 			= this.account.loanID;
						note.accountData.loanValue 		= newBlock.loanValue;
						
						var string 	= note.walletID;
						trivKey 		= this.hashed( string );
						
						localStorage[trivKey] 		= JSON.stringify( this.account );
						
						
						if( ! note.loanValue )
							note.loanValue = 0;
						
						note.loanValue += parseFloat( details.transValue );
											
						//since new credits is created to the exchange network of 
						//the exchange market during deposit to the exchange market
						//we increase the demand value of the exchange market.
						//however, the demand value should only be increased if
						//the supply value is low and can't handle the request.
						
						if( newBlock.exchangeNote.exchangeValue >= details.transValue )
							newBlock.exchangeNote.exchangeValue = parseFloat( newBlock.exchangeNote.exchangeValue ) - parseFloat( details.transValue );
						
						else 
							newBlock.exchangeNote.demandValue 	= parseFloat( newBlock.exchangeNote.demandValue ) + parseFloat( details.transValue );
						
						if( ! newBlock.exchangeNote.loanValue )
							newBlock.exchangeNote.loanValue = 0;
						
						newBlock.exchangeNote.loanValue = parseFloat( newBlock.exchangeNote.loanValue ) + parseFloat( details.transValue );
						
						currentNote 		= JSON.parse( JSON.stringify( newBlock.exchangeNote ));
					}
					else if( details.transType == "UPDATEPRODUCT" ){
						this.productID 		= details.productID;
						this.#productBlock 	= await this.getTransBlock();
						this.#productBlock 	= await this.getCurrentBlock( this.#productBlock );
						
						if( ! details.agreement || ! details.agreement.value || ! details.agreement.units ){
							this.errorMessage( "Product Poorly Configured" );
							return false;
						}
						
						if( ! this.#productBlock || ! this.#productBlock.productID || ! this.#productBlock.productNote || ! this.#productBlock.agreement || ! this.#productBlock.agreement.value ){
							this.errorMessage("Invalid Product Selected to be Updated. Please Check the Product ID Provided and Try again!");
						}
						
						let productNote 		= JSON.parse( JSON.stringify( this.#productBlock.productNote ));

						//checking if the note is authorized to create this product
						let productKey 		= false;
						
						if( ! note.noteProducts || ! note.noteProducts.length || ! typeof note.noteProducts == "object" ){
							this.errorMessage("No Product Private Key on note to show you created this product.");
							return false;
						}
						
						for( let x = 0; x < note.noteProducts.length; x++ ){
							productKey 		= note.noteProducts[x];
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( productKey, id );
							
							if( details.productID != await this.getPublicKey(id,true) )
								productKey 		= false;
						}
						
						if( ! productKey ){
							this.errorMessage("No Product Private Key on note to show you created this product.");
							return false;
						}
						
						var signKey 			= productKey;
						var signTxt			= newBlock.blockID;
						newBlock.productSign 	= await this.Sign(signKey, signTxt );
						newBlock.productID 		= details.productID;
						
						let totalNew  = parseFloat( details.agreement.value ) * parseFloat( details.agreement.units );
						let totalOld = parseFloat( this.#productBlock.agreement.value ) * parseFloat( this.#productBlock.agreement.units );
						let added 	= totalNew - totalOld;
						
						productNote.demandValue 	= parseFloat( productNote.demandValue ) + added;
						
						newBlock.productNote 		= JSON.parse( JSON.stringify( productNote ) );
						newBlock.agreement 			= JSON.parse( JSON.stringify( details.agreement ));
						
						
						
					}
					
				}else if( (details.transType == "ADDITEM"||details.transType == "CANCELITEM"||details.transType == "UPDATEITEM" || details.transType == "UPDATEBUDGET" ) && this.#budgetSecret ){
					if( ! note.noteBudgets.includes( this.#budgetSecret )){
						this.errorMessage( "Budget note found on note, Please check the budget ID supplied and try again" );
						return false;
					}
					
					let isBusiness 			= true;
					
					if(  ! details.transType == "UPDATEBUDGET" ) {
						if( ! details.agreement || ! details.agreement.itemName || ! details.agreement.itemValue || ! details.agreement.itemProduct || ! details.agreement.itemID ){
							details.agreement 		= JSON.parse( JSON.stringify( this.defaultItem ));
						}
						
						
						let value 		= parseFloat( details.agreement.itemValue );
						
						if( details.agreement.itemCredit != note.noteType ){
							let exValue			= await this.getExchangeValue( details.agreement.itemCredit, note.noteType );
							value 				= value * exValue[0];
						}
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( this.#budgetSecret, id );
						let budgetBlock 		= await this.getCurrentBudgetBlock( await this.getPublicKey(id));
						
						if( ! budgetBlock || ! budgetBlock.agreement ){
							budgetBlock 		= await this.getCurrentBudgetBlock( await this.getPublicKey(id, true));
							
							if( ! budgetBlock || ! budgetBlock.agreement ){
								this.errorMessage( "No Budget found associated with this item" );
								return false;
							}
							isBusiness 			= false;
						}
						
						let budget 			= JSON.parse( JSON.stringify( budgetBlock.agreement ));
						
						if( ! budget.budgetItems || ! budget.budgetItems.length || ! typeof budget.budgetItems == "object" )
							budget.budgetItems 		= [];
						
						if( details.transType == "ADDITEM" ){
						
							budget.budgetItems.push( newBlock.blockID );
							budget.item 		= JSON.parse( JSON.stringify( details.agreement ));
							budget.item.itemID 	= await this.generateKey(20);
							budget.value 		= parseFloat( budget.value ) + parseFloat( details.agreement.itemValue );
							newBlock.agreement 	= JSON.parse( JSON.stringify( budget ));
							newBlock.referenceID 	= budget.item.itemID;
							newBlock.referenceKey 	= budget.budgetID;
						
						} else {
							if( details.transType == "UPDATEITEM" ){
								if( ! details.itemID || ! budget.budgetItems[ budget.budgetItems.indexOf( details.itemID ) ] ){
									this.errorMessage("No Budget Items to Update, adding the item instead.");
									budget.budgetItems.push( newBlock.blockID );
									newBlock.transType 	= "ADDITEM";
									details.transType 	= "ADDITEM";
									transType 			= "ADDITEM";
								} else {
									this.blockID 		= details.itemID;
									let blk 			= await this.getTransBlock(1);
									let added 			= 0;
									if( blk.length && blk[0].agreement && blk[0].agreement.item ){
										let formerItem 	= JSON.parse( JSON.stringify( blk[0].agreement.item ));
										
										added 		=  parseFloat( details.agreement.itemValue ) - parseFloat( formerItem.itemValue );
										
										if( blk[0].referenceID != details.agreement.itemID ){
											this.errorMessage("Reference ID Did not match supposed former Item ID, transaction woukd be regarded as an Add Item instead of update. If you think this is an error, simply run the remove item transaction to remove the item from the budget.");
											budget.budgetItems.push( newBlock.blockID );
											newBlock.transType 	= "ADDITEM";
											details.transType 	= "ADDITEM";
											transType 			= "ADDITEM";
										}
										
										 
									} else {
										this.errorMessage("No Budget Items to Update, adding the item instead.");
										budget.budgetItems.push( newBlock.blockID );
										newBlock.transType 	= "ADDITEM";
										details.transType 	= "ADDITEM";
										transType 			= "ADDITEM";
										added 		= details.agreement.itemValue;
									}
									budget.value 			= parseFloat( budget.value ) + parseFloat( added );
									budget.budgetItems[ budget.budgetItems.indexOf( details.itemID ) ] = newBlock.blockID;
								}
								budget.item 	= JSON.parse( JSON.stringify( details.agreement ));
								newBlock.referenceID 	= budget.item.itemID;
								newBlock.referenceKey 	= budget.budgetID;
							} else if( details.transType == "CANCELITEM" ){
								if( ! details.itemID || ! budget.budgetItems[ budget.budgetItems.indexOf( details.itemID ) ] ){
									this.errorMessage("No Budget Item to remove from the budget.");
									return false;
								}
								this.blockID 	= details.itemID;
								let agreeBlock 	= await this.getTransBlock();
								
								if( ! agreeBlock.length || ! agreeBlock[0].blockID || ! agreeBlock[0].agreement || ! agreeBlock[0].agreement.item ){
									this.errorMessage("We couldn't find an agreement block connected to this item");
									return false;
								}
								
								let item 		= JSON.parse( JSON.stringify( agreeBlock[0].agreement.item ));
								budget.budgetItems.splice(  budget.budgetItems.indexOf( details.itemID ), 1 );
								budget.value 			= parseFloat( budget.value ) - parseFloat( item.itemValue );
								newBlock.referenceID 	= item.itemID;
								newBlock.referenceKey 	= budget.budgetID;
								delete budget.item;
							}
							newBlock.agreement 	= JSON.parse( JSON.stringify( budget ));
						}
						
						newBlock.transType 		= details.transType;
						newBlock.transValue 	= details.agreement.itemValue;
					} else {
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( this.#budgetSecret, id );
						let budgetBlock 		= await this.getCurrentBudgetBlock( await this.getPublicKey(id));
						
						if( ! budgetBlock || ! budgetBlock.agreement ){
							this.errorMessage( "No Budget found to be updated" );
							return false;
						}
						
						if( ! details.agreement || ! details.agreement.budgetID || ! details.agreement.budgetItems ){
							details.agreement 		= JSON.parse( JSON.stringify( budgetBlock.agreement ));
						}
						else {
							//maintain the budget items from the former agreement.
							details.agreement.budgetItems 	= budgetBlock.agreement.budgetItems;
							details.agreement.stockID 	= budgetBlock.agreement.stockID;
						}
						
						newBlock.agreement 			= JSON.parse( JSON.stringify( details.agreement ));
						
					}
					
					if( isBusiness && note.budgetKey ){
						newBlock.budgetSign	= await this.Sign( note.budgetKey, newBlock.blockID );
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( note.budgetKey, id );
						newBlock.budgetKey	= await this.getPublicKey( id, true );
					}
					else if( ! isBusiness ){
						newBlock.budgetSign	= await this.Sign( this.#budgetSecret, newBlock.blockID );
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( this.#budgetSecret, id );
						newBlock.budgetKey	= await this.getPublicKey( id, true );
					} else {
						this.errorMessage("Can't update a budget without a budget key");
						return false;
					}
					
					
				}else if( details.transType == "AGREEMENTREQUEST" ){
					//await this.createAlert("In Agreement Request");
					//ONLY FOR THE MEAN TIME. THIS IS REQUIRED TO CHECK IF THE CLIENT HAS THE 
					//AGREEMENT BEFORE RUNNING THE REQUEST
					/* if( ( ! newBlock.agreements && ! newBlock.agreements[ details.agreement.agreeID ] ) ) {
						this.errorMessage("No Agreement with the agreement ID " + details.agreement.agreeID + " Was Found in your Note'this.s Personal Database. Please Check The ID and Try AGain.");
						return false;
					} */
					
					if( details.agreement.agreeKey != details.recipient ){
						this.errorMessage( "Can't run an agreement request without using the ID as recipient. Script automatically reverting to the agreement ID" );
						details.recipient = details.agreement.agreeKey;
					}
					
					//we will try removing the agreement from the personal database of this note to create
					//the request, if rejected, the network will not regard that the agreement was deleted
					//from the database.
					
					// delete newBlock.agreements[ details.agreement.agreeID ];
					if( details.agreement.privateKey )
						privKey 					= details.agreement.privateKey;
					else
						privKey						= await this.generateKey( 25, true, true );
					
					var signTxt						= newBlock.blockID;
					var signKey 					= privKey;						
					details.agreement.recieverID 	= this.signTxt;
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					details.agreement.recieverKey 	= await this.getPublicKey( id, true );
					details.agreement.recieverSign = await this.Sign(signKey, signTxt );
					details.agreement.privateKey 	= privKey;
					var id 							= await this.generateKey(10);
					await this.setPublicKey( details.recipient, id );
					
					if( details.recipient.length == 171 )
						newBlock.recipient = await this.#encrypt( JSON.stringify( details.agreement ) , id);
					
					else
						newBlock.recipient = this.encrypt( JSON.stringify( details.agreement ), this.publicKey[id] );
					
					await this.setPrivateKey( privKey, id );
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					newBlock.signRef		= await this.generateKey(20);
					newBlock.transType 	= details.transType;
					newBlock.transValue    = details.transValue;
					newBlock.noteType 		= note.noteType;
					newBlock.agreement 		= JSON.parse( JSON.stringify( details.agreement ));
					delete newBlock.agreement.privateKey;
				}
				//the opposite of the AGREEMENTREQUEST transaction is the AGREEMENTSIGN transaction
				//the transactions are used to clear an agreement from the Scriptbill database system
				//to prevent it from running. The agreement once signed will be deleted from the requesters
				//database system.
				else if( ( details.transType == "AGREEMENTSIGN" || details.transType == "CANCELLED" ) ){
					if(  ! response || ( ( ! this.#transSend.includes( response.transType ) || response.transType != "SPLIT" ) && details.transType == "CANCELLED" ) || ( response.transType != "AGREEMENTREQUEST" && details.transType == "AGREEMENTSIGN" )  ) {
						this.errorMessage("Can't Sign an Agreement without a valid Agreement Request!");
						return false;
					}
					let agreements = note.agreements, x, agreeKey, runned = false;
					
					//since the agreement ID is used to encrypt the agreement request, the recipient
					//must be the holder of the private key of the request.
					//now looping through the agreements handler to find the key.
					if( ! this.#isExchangeMarketMining || ! details.password ){
						let confarm = true, message;
						for( x = 0; x < agreements.length; x++ ) {
							agreeKey  = agreements[x];
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( agreeKey.key.split('----')[1], id );
							agreement = await this.decrypt( response.recipient, await this.getPublicKey(id, true) );
							
							if( ! this.isJsonable( agreement ) ) {
								var id 				= await this.generateKey(10);
								await this.setPrivateKey( agreeKey.key.split('----')[0], id );
								agreement = await this.#decrypt( response.recipient, id );
								
								if( ! this.isJsonable( agreement ) ) continue;
							}					
							
							runned = true;
							agreement = JSON.parse( agreement );
							privKey 	= agreement.privateKey;
							
							//first confirm from the user if he/she would want to sign the agreement for the user.
							message 	= "Would you like to sign this agreement request, with ID " + agreement.agreeID + "? Please ensure that all details in the agreement are fulfilled before continuing.";
							if( this.alertDetails )
								confarm 			= await this.createConfirm( message );
							
							if( confarm && note.unfulfilled && note.unfulfilled[ agreement.senderID ] ){
								var signTxt 			= agreement.senderID;
								var signKey  			= note.unfulfilled[ agreement.senderID ];
								agreement.senderSign 	= await this.Sign( signKey, signTxt );
								var id 					= await this.generateKey(10);
								await this.setPrivateKey( signKey, id );
								agreement.senderKey 	= await this.getPublicKey( id, true );
								newBlock.signRef 		= await this.Sign(agreement.privateKey, response.signRef);
								await this.setPrivateKey( signKey, id );
								newBlock.blockRef 	= await this.getPublicKey( id, true );
								newBlock.agreement 	= JSON.parse( JSON.stringify( agreement ));
								newBlock.recipient 	= this.encrypt( JSON.stringify( agreement ), response.blockKey );
								delete newBlock.agreement.privateKey;
								delete note.unfulfilled[ agreement.senderID ];
							}
							else {
								runned = false;
							}
						}
					} else if( response && response.exchangeNote && response.exchangeNote.agreement && typeof response.exchangeNote.agreement == "string" ){
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( response.exchangeNote.agreement, id );
						agreement 		= await this.decrypt( response.recipient, await this.getPublicKey( id, true ) );					
						if( ! this.isJsonable( agreement ) ){
							this.errorMessage("Agreement Not Successfully Decrypted, Agreement Sign Transaction Failed");
							return false;
						}
						
						
						if( ! this.#isExchangeMarketMining ){
							let verify 		= await this.getData('verify_script_nonce', details.password, this.#default_scriptbill_server );
							
							if( ! verify || ! verify.verified ){
								this.errorMessage('Agreement Signature Transaction was not verified to be created by the exchange note server. Transaction now aborting!');
								return false;
							} else {
								this.#isExchangeMarketMining = true;
								delete details.password;
							}
						}
						
						privKey 	= agreement.privateKey;
						agreeKey 	= response.exchangeNote.agreement;
						
						if(  ! this[ this.#odogwu ] ){ 
						
							if( this.#fiatCurrencies[ testType ] || note.noteType == "SBCRD" ){
								if( ! location.href.includes("scriptbank") && ! this.scriptKey ) {
									this.errorMessage("Can't Run an Agreement Sign Transaction For a Scriptbank Exchange Market Note Without Being a Client of The Scriptbank Server and Having The Scriptbank Staff Key");
									return false;
								}						
							}
							//to protect other exchange notes, we only accept if it is runned 
							//their server origin with their staff key in the scriptKey 
							//handler.
							else if( ! note.noteServer.includes(location.origin) && ! this.scriptKey ){
								this.errorMessage("Can't Run an Agreement Sign Transaction For an Exchange Market Note Without Being a Client of The Exchange Market Server and Having Their Staff Key");
								return false;
							}
							
							var string = location.origin;
							let server 	= this.hashed( string );
							let run 	= await this.getData(["server", "staff", "value", "type", "ID"],[server, this.scriptKey, details.agreement.value, "SIGN", details.agreement.agreeID], location.origin, "socket" );
							
							
							if( ! run || ! run.verify  ){
								this.errorMessage("Server Verification Fail For Signing an Exchange Market Agreement");
								return false;
							}
						}
						
						block 					= await this.getTransBlock(1, {blockID:agreement.senderID});
						
						if( ! block[0] || ! block[0].blockID ){
							this.errorMessage("Couldn't get sender block");
							return false;
						}
						
						agreement.senderSign 	= await this.Sign(block[0].blockKey,agreement.senderID);
						var id 					= await this.generateKey(10);
						await this.setPrivateKey( block[0].blockKey, id );
						agreement.senderKey 	= await this.getPublicKey( id, true );
						newBlock.signRef 	= await this.Sign(privKey,response.signRef);
						await this.setPrivateKey( privKey, id );
						newBlock.blockRef 	= await this.getPublicKey( id, true );
						await this.setPrivateKey( this.scriptKey, id );
						newBlock.scriptKey		= await this.getPublicKey( id, true );
						newBlock.scriptSign	= await this.Sign(this.scriptKey,newBlock.blockID );
					}
					
					if( ! runned ){
						if( details.transType == "AGREEMENTSIGN" && this.alertDetails && ! this.#isExchangeMarketMining )
							runned = await this.createConfirm("Would you rather Cancel the Agreement?");
						
						if( ! runned )
							return false;
						
						else{
							details.transType 	= "CANCELLED";
							transType		 	= "CANCELLED";
						}
					}
					
					newBlock.noteType     = note.noteType;
					newBlock.transValue 	= 0;
					newBlock.transType     = details.transType;
					newBlock.agreement  	= agreement;
					agreement.privateKey 		= privKey;
					newBlock.recipient 	= this.encrypt( JSON.stringify( agreement ), response.blockKey );
					
					if( details.transType == "CANCELLED" )
						newBlock.transValue 	= agreement.value;
					
					else 
						newBlock.transValue 	= 0;
									
					note.agreements.forEach( (agreement, index)=>{
						if( agreement.key.includes( agreeKey ) )
							note.agreements.splice( index, 1 );
					});
				}
			}
			
		}
		//this block are for transactions that can only be handled by stock note types.
		else if( await this.testNoteType("STK", note) ) {
			if( details.transType == "SOLDSTOCK" && response.transType == "BUYSTOCK" ) {
					if( response && response.transType == details.transType ) {
						
						if( response.transType == "BUYSTOCK" )
							details.transType = "SOLDSTOCK";
						
						else
							details.transType 	= "SOLDSTOCK";
					}
					
					transType				= details.transType;
					
					//most of the time the budgetID is what is used to make the transaction not the noteAddress because
					//it is a public exchange transaction.
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					
					if( typeof response.agreement == "string" ){
					
						agreement = this.#decrypt( response.recipient, id );
						
						if( ! this.isJsonable( agreement ) ) return false;
						
						agreement 		= JSON.parse( agreement );
					} else {
						agreement 		= JSON.parse( JSON.stringify( response.agreement ));
					}
					
					//testing whether the purchaser has not bought stocks already.
					this.blockRef 		= response.blockRef;
					this.transType 		= "SELLSTOCK";
					
					let checkBlock 		= await this.getTransBlock( 10, {blockRef:this.blockRef, transType: this.transType });
					
					if( checkBlock.length && checkBlock.length > 1 ){
						this.errorMessage("Buy Stock Request for this Buyer ID: " + response.blockID + " Has already been fulfilled.");
						return false;
					}
					let budgetID 		= await this.getPublicKey(id);
					this.budgetBlock 	= await this.getCurrentBudgetBlock( budgetID );
					
					if( ! this.budgetBlock && ! this.budgetBlock.blockID && ! this.budgetBlock.productNote ){
						this.errorMessage("Can't sell Scriptbill Stocks or Bond without a valid Scriptbill Budget.");
						return false;
					}
					
					let productNote 		= await this.getCurrentExchangeNote( this.budgetBlock.agreement.stockID );
					
					if( ! productNote ){
						productNote 		= JSON.parse( JSON.stringify( this.budgetBlock.productNote ));
					}
					
					if( ! productNote ){
						this.errorMessage("Can't sell Scriptbill Stocks or Bond without a valid Scriptbill Budget Note.");
						return false;
					}
					
					
					//billing the scriptbill note.
					//this is the current value of the note.
					let value 			= parseFloat( productNote.exchangeValue ) * parseFloat( note.noteValue );
					let stock  			= parseFloat( productNote.exchangeValue ) * parseFloat( note.stock );
								
					
					if( response.transValue > value ){
						this.errorMessage("Your stock note cannot sell stock to this buy stock request. You can retry again another time.");
						return false;
					}
					
					//this is the rate of stocks he had acquired from the current stock note.
					//this will be subtracted from the stock note value.
					let rate 		= parseFloat( response.transValue ) / parseFloat( value );
					let stockRate	= parseFloat( response.transValue ) / parseFloat( stock );
					//this is the actual rate of stock the buyer is purchasing from the stock market.
					let actualRate 	= parseFloat( response.transValue ) / parseFloat( productNote.exchangeValue );
					
					let diffRate 	= rate - stockRate;
					
					//before we bill the note, let's check if the note buystock request have note been
					//honoured by another note.
					this.blockRef 	= response.blockRef;
					let refBlock	= await this.getTransBlock();
					
					if( refBlock.length > 1 ){
						this.errorMessage( "Stock Has already been sold to another vendor" );
						return false;
					}
					
					note.noteValue 		= parseFloat( note.noteValue ) - rate;		
					//add neccesary keys to the agreement before encrypting it
					agreement.budgetID 	= budgetID;
					agreement.budgetKey = note.budgetKey;
					
					if( ! note.budgetKey )
						note.budgetKey 		= agreement.budgetKey;
					
					agreement.stock 	= 	actualRate;
					agreement.pay 		= 	actualRate - diffRate;
					
					//next create a transaction block that will target the mother note
					//the transaction type will INVEST transType. the note will recieve the investment funds
					//and create a SOLDSTOCK transaction to the initiator'this.s note, which will create a QUOTESTOCK
					//transaction to either create the stock note or update an existing stock note.
					//first we save the block IDs in the newBlock
					let blockID				= newBlock.blockID;
					let nextBlockID 		= newBlock.nextBlockID;
					let formerBlockID 		= newBlock.formerBlockID;
					let walletHash			= newBlock.walletHASH;
					let nextWalletHASH 		= newBlock.nextWalletHASH;
					let formerWalletHASH 	= newBlock.formerWalletHASH;
					let agreements 			= newBlock.agreements;
					//this will help preserve the blockRefs and other important info on the block which will be 
					//used by the mother note to prepare the SOLDSTOCK transaction.
					newBlock				= JSON.parse( JSON.stringify( response ));
					//set the mother note Key as public key to encrypt the agreement;
					var id 				= await this.generateKey(10);
					await this.setPublicKey( note.motherKey, id );
					//not parsed yet
					newBlock.recipient	= await this.#encrypt( agreement, id );
					//adding the blockIDs
					newBlock.blockID 			= blockID;
					newBlock.nextBlockID		= nextBlockID;
					newBlock.formerBlockID 	= formerBlockID;
					newBlock.walletHASH		= walletHash;
					newBlock.formerWalletHASH	= formerWalletHASH;
					newBlock.nextWalletHASH	= nextWalletHASH;
					newBlock.agreements		= agreements;
					
					//ensure the transType is an INVEST transType so that the program can interprete the details 
					//as INVESTRECIEVE treansType. this transType occurs when a stock or bond note is redirecting a 
					//transaction to her mother note.
					newBlock.transType 		= "INVEST";
					newBlock.noteType 		= note.noteType;
					
					
					
				}
				else if( details.transType == "SELLSTOCK" || response.transType == "BUYSTOCK" ){
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					let budgetID 		= await this.getPublicKey(id);
					this.budgetBlock 	= await this.getCurrentBudgetBlock( budgetID );
					
					if( ! this.budgetBlock || ! this.budgetBlock.blockID ){
						this.errorMessage("Invalid Block Selected!!");
						return false;
					}
					
					let budget 			= this.budgetBlock.agreement;
					let totalValue, Pay;
					//check the stock value. If not equal then we only reconfigure the pay.
					if( details.stock != note.noteValue )
						details.stock 	= note.noteValue;
					
					if( response.transType == "BUYSTOCK" ){
						//this transaction will be directed to the stock note address
						//because no one can direct a BUYSTOCK transaction to a stock note directly
						//without knowing the noteAddress.
						/* if( noteSecret == note.noteSecret && ! isNew && ! this.#isExchangeMarketMining ){
							var string 			= transKey;
							note.noteSecret 	= this.decrypt( noteSecret, this.hashed( string ) );
						} */
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( note.noteSecret, id );
						agreement 	= await this.#decrypt( response.recipient, id );
						
						let trade   = true;
						
						if( ! this.isJsonable( agreement ) ){
							await this.setPrivateKey( note.budgetID, id );
							agreement 	=  this.#decrypt( response.recipient, id );
							if( ! this.isJsonable( agreement ) )
								return false;
							else {
								this.blockRef 		= response.blockRef;
								let blocks 			= await this.getTransBlock();
								
								//this shows that the stocks had alrready been bought by the user.
								if( blocks.length > 1 ){
									trade 		= false;
								}
							}
						} 
							
						if( this.alertDetails ){
							//before continuing alert the recipient first.
							trade = await this.createConfirm("Hello, a Scriptbill User with note Credit " + response.noteType + " and Transacting with Value of " + response.transValue +" Want's to Buy Stock From your note. Please Cancel This Transaction if you are not willing to sell your stock now.");
						} else {
							trade = true;
							this.alert 	= "Hello, a Scriptbill User with note Credit " + response.noteType + " and Transacting with Value of " + response.transValue +" Want's to Buy Stock From your note. Please Cancel This Transaction if you are not willing to sell your stock now.";
						}
						
						
						agreement 		= JSON.parse( agreement );
						
											
						details 		= response;
						
						if( ! trade ){
							//instead of cancelling the transaction we redirect the transaction to the
							//original budget block.
							details.recipient 	= budgetID;
						} else {						
							details.transType 	= "SOLDSTOCK";
							transType		 	= "SOLDSTOCK";
							details.recipient 	= agreement.noteAddress;
						}
					}
					
					//the stock value of a stock note is the total value of your investment in the budget in rates.
					//the pay value is the actual value of your investment vbased on the agreement on the budget.
					//your stock value is important when trying to sell your stock or bonds.
					//to calculate the actual stock, we have to calculate the budget value when the note invested on
					//the stock.			
					
					if( ! note.stock || ! note.budgetValue ){
						this.errorMessage("This is not a valid Stock Note....SellStock transaction now aborting");
						return false;
					}
					
					let stockValue 	= parseFloat( note.budgetValue ) * parseFloat( note.stock );
					let stock 		= stockValue / parseFloat( budget.value );
					
					totalValue 		= parseFloat( budget.value ) * stock;
					Pay 			= parseFloat( budget.value ) * parseFloat( note.noteValue );						
					
					
					let exValue;
					
					//we have to configure the pay to obey the exchange values of the credits 
					//involve in the transaction if the seller want'this.s to sell to a particular note type
					if( details.noteType != budget.budgetCredit ){
					/* 	exValue 	= await this.getExchangeValue( details.noteType, budget.budgetCredit );
						Pay 	= Pay * exValue[1];
						totalValue = totalValue * exValue[1]; */
					}
					
					//if the pay value gotten is lesser than the transaction value.
					if( Pay < details.transValue ){
						details.transValue 	= Pay;
					}

										
					budget.pay 			= parseFloat( details.transValue )/ Pay;
					budget.stock 		= parseFloat( details.transValue )/ totalValue;
					
					details.pay 		= budget.pay;
					budget.budgetID 	= note.budgetID;
					budget.budgetKey 	= note.budgetKey;
					
					//sending the funds to the recipient note.
					//configuring it to favour the recipient and the sender of the transaction
					if( ! response )						
						details.recipient =  budgetID;
					
					//first we save the block IDs in the newBlock
					let blockID				= newBlock.blockID;
					let nextBlockID 		= newBlock.nextBlockID;
					let formerBlockID 		= newBlock.formerBlockID;
					let walletHash			= newBlock.walletHASH;
					let nextWalletHASH 		= newBlock.nextWalletHASH;
					let formerWalletHASH 	= newBlock.formerWalletHASH;
					let agreements		 	= newBlock.agreements;
					
					newBlock 				= details;
					//creating the block refs signatures.
					budget.privateKey 			= await this.generateKey(20, true, true );
					var id 						= await this.generateKey(10);
					await this.setPrivateKey( budget.privateKey, id );
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					newBlock.signRef 		= await this.generateKey(15);
					
					//encrypting the agreement.
					var id 				= await this.generateKey(10);
					await this.setPublicKey( details.recipient, id );
					if( details.recipient.length == 171 )
						newBlock.recipient		= await this.#encrypt( JSON.stringify( budget ), id );
					
					else
						newBlock.recipient		= this.encrypt( JSON.stringify( budget ), this.publicKey[id] );

					//adding the blockIDs
					newBlock.blockID 			= blockID;
					newBlock.nextBlockID		= nextBlockID;
					newBlock.formerBlockID 	= formerBlockID;
					newBlock.walletHASH		= walletHash;
					newBlock.formerWalletHASH	= formerWalletHASH;
					newBlock.nextWalletHASH	= nextWalletHASH;
					newBlock.agreements		= agreements;
					
					//update the note value.
					note.noteValue 		= parseFloat( note.noteValue  ) - parseFloat( details.pay );
				}
				else if( details.transType == 'STOCKPAY' && note.budgetID ) {
					//dividend paying transaction always ignited by the payInterest method who monitors
					//the agreement on the note to ignite the transaction.
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					if( ! this.budgetBlock ) {						
						this.budgetBlock 	= await this.getCurrentBudgetBlock( await this.getPublicKey());
						
					} else {
						this.budgetID 		= await this.getPublicKey(id);
						if( ! this.budgetBlock.budgetID || this.budgetBlock.budgetID != this.budgetID ){
							this.errorMessage("Budget block supplied seems fraudulent, we will now check for the authentic budget block!");
							this.budgetBlock 	= await this.getCurrentBudgetBlock( await this.getPublicKey(id));		
						}
					}
										
					if( ! this.budgetBlock && ! this.budgetBlock.blockID && ! this.budgetBlock.agreement ){
						this.errorMessage("Sorry we can't process a stock pay transaction without a valid budget block. Please try again by checking the budget ID.");
						return false;
					}
									
						
					/* let investorsHub 	= this.budgetBlock.agreement.investorsHub;
					var string 		= details.reference;
					let hashKey			= this.hashed( string );
						
					if( ! investorsHub.indexOf( hashKey ) ) {
						this.errorMessage("Sorry, We couldn't find your stock note as a valid investor on this budget. Please try again with a different stock note.");
						return false;
					} */
					
					details.agreement 		= this.budgetBlock.agreement;
					
					let agreement 			= JSON.parse( JSON.stringify( details.agreement ));
					
					this.blockID 			= note.blockID;
					let block 				= await this.getTransBlock();
					
					//this will help us get the latest agreement on the block.
					if( block && block[0] && block[0].blockID )
						agreement 			= block[0].agreement;
					
					if( agreement && agreement.agreement )
						agreement 		= JSON.parse( JSON.stringify( agreement.agreement ));
					
					let payTime 		= this.currentTime();
					
					if( agreement.payTime )
						payTime 		= agreement.payTime;
					
					let time 			= this.currentTime();
					
					if( payTime > time ){
						this.errorMessage("Stock Payment can't be executed, the payment time hasn't reached!");
						return false;
					}
					
					let nextPay 		= this.calculateTime( "1 weeks" );
					
					if( agreement.payPeriod )
						nextPay 		= this.calculateTime( agreement.payPeriod );
					
					if( nextPay )
						agreement.payTime 	= parseInt( time ) + parseInt( nextPay );
					
					else 
						agreement.payTime 	= parseInt( time ) + parseInt( this.calculateTime( "1 weeks" ) );
					
					//try getting the product note.
					let productNote 		= await this.getCurrentExchangeNote( details.agreement.stockID );
					
					if( ! productNote ){
						//check the budget block handler to see if the product note is stored there.
						productNote 		= this.budgetBlock.productNote;
						
						if( productNote )
							productNote 	= JSON.parse( JSON.stringify( this.budgetBlock.productNote ));
					}
					
					if( ! productNote ){
						this.errorMessage("No Public Note representing this stocks was found!");
						return false;
					}
					
					if( ! note.pay )
						note.pay = note.noteValue;
					
					//if the product note is found, then the exchange value will be affected by this 
					//transaction. to know the right value to remove, we need to check the budget
					//agreement first.
					let value 					= parseFloat( this.budgetBlock.agreement.value );
					let amount 					= ( productNote.exchangeValue - value ) * note.pay;//the pay handler contains the 
					//stock value that the investor can recieve. the actual stock holding is used in 
					//the company for ranking and reward purpose.
					//to calculate the amount of money the user will send, we need to subtract the 
					//total note value from the current budget value, to give the stock earner the 
					//current gross profit earned by the company at that instance.
					//if the budget value is higher than the note value, we are going to have a
					//negative value to pay. At this point, stocks won't be paid out until we can 
					//have a positive value or the product note experience more sale.
					//sometimes this can happen if at this instance of running this function the 
					//product note gotten was outdated and didn't contain the latest information.
					
					if( amount <= 0 ){
						this.errorMessage("Unfortunately, dividend cannot be paid from this exchange market at this moment. You'll need to retry again next time ");
						return false;
					}
					
					details.agreement.privateKey = await this.generateKey( 30, true, true );
					
					if( ! details.recipient || details.recipient != note.motherKey )
						details.recipient 	= note.motherKey;
					
					var id 				= await this.generateKey(10);
					await this.setPublicKey( details.recipient, id );
					newBlock.recipient 	= await this.#encrypt( JSON.stringify( details.agreement ),id);
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( details.agreement.privateKey, id );
					
					newBlock.transType 		= details.transType;
					newBlock.budgetID 		= details.budgetID;
					newBlock.transValue 	= amount;
					newBlock.blockRef		= await this.getPublicKey( id, true );
					newBlock.signRef		= await this.generateKey(20);
					delete details.agreement.privateKey;
					newBlock.agreement 		= JSON.parse( JSON.stringify( details.agreement ));
					newBlock.agreement.agreement = JSON.parse( JSON.stringify( agreement ) );
					
					//billing the product note.
					productNote.exchangeValue 	= parseFloat( productNote.exchangeValue ) - parseFloat( amount );
					newBlock.productNote 		= JSON.parse( JSON.stringify( productNote ));
				}
				
				else if( details.transType == "STOCKRECIEVE" && ( response.transType == "STOCKPAY" || response.transType == "QUOTESTOCK" ) ){
					var id 				= await this.generateKey(10);
					if( this.#privKey ){						
						await this.setPrivateKey( this.#privKey, id );
						this.#privKey = false;
					} else {
						await this.setPrivateKey( note.noteSecret, id );
					}
					
					let productNote 	= JSON.parse( JSON.stringify( response.productNote ));
					
					
					agreement 		= await this.#decrypt( response.recipient, id );
					
					if( agreement && this.isJsonable( agreement ) ) 
						agreement = JSON.parse( agreement );
					
					if( ! agreement || ! agreement.privateKey ) return false;
					let value 			= parseFloat( note.budgetValue ) * parseFloat( note.noteValue );
					let stockValue 		= ( parseFloat( details.transValue ) + value ) /  parseFloat( productNote.exchangeValue );
					//updating the note value.
					note.noteValue 		= parseFloat( stockValue );
					note.budgetValue 	= productNote.exchangeValue;
					
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( agreement.privateKey, id );
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					newBlock.signRef 		= await this.Sign(agreement.privateKey,response.signRef);
					delete agreement.privateKey;
					newBlock.agreement 	= JSON.parse( JSON.stringify( agreement ));
					newBlock.agreements[ agreement.agreeID ] = newBlock.blockID;
				}
		}
		//for transactions that can only be handled by bond note types. Note bonds are created by the exchange market of a 
		//Scriptbill credit.
		else if( await this.testNoteType("BND", note)){
			testType				= note.noteType.slice( 0, noteType.lastIndexOf("BND") )
			if( response && ( details.transType == "SOLDBOND" || response.transType == "BUYBOND" ) ) {
					if( response && response.transType == details.transType ) {
						
						if( response.transType == "BUYBOND" )
							details.transType = "SOLDBOND";
						
					}
					
					transType			= details.transType;
					
					//most of the time the blockKey is what is used to make the transaction not the noteAddress because
					//it is a public exchange transaction.
					if( ! this.#isExchangeMarketMining ){
						for( agreeID in note.agreements ){
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( note.agreements[ agreeID ].key.split("----")[0], id );
							
							agreement 		= await this.#decrypt( response.recipient, id );
							
							if( ! this.isJsonable( agreement ) ) continue;
						}
						
						if( ! this.isJsonable( agreement )){
							var id 				= await this.generateKey(10);
							await this.setPrivateKey( note.noteSecret, id );
							agreement 		= await this.#decrypt( response.recipient, id );
						}
					}
					else {
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( note.exchangeKey, id );				
						agreement 		= await this.#decrypt( response.recipient, id );
					}
					
					if( ! this.isJsonable( agreement ) ) {
						//testing if it was a public transaction.
						
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( note.budgetID, id );
						agreement 		= this.#decrypt( response.recipient, id );
						
						if( ! this.isJsonable( agreement ) ) return false;
					}
					
					if( ! this.#isExchangeMarketMining && ! this.#fiatCurrencies[ testType ] ){
						var id 				= await this.generateKey(10);
						await this.setPrivateKey( note.budgetID, id );
						this.budgetID 		= await this.getPublicKey(id);
						this.budgetBlock 	= await this.getCurrentBudgetBlock( this.budgetID );
						
						if( ! this.budgetBlock || ! this.budgetBlock.transType ){
							this.errorMessage("Can't sell Scriptbill Bond without a valid Scriptbill Budget.");
							return false;
						}
						
						if( ! this.budgetBlock.agreement || this.budgetBlock.agreement.budgetType != "governmental" ) {
							this.errorMessage("Can't Buy Bond without a Valid Governmental Budget data");
							return false;
						}
					}
					
					agreement 					= JSON.parse( agreement );
					agreement.budgetKey 		= note.budgetKey;
					agreement.budgetID 			= note.budgetID;
					
					//next create a transaction block that will target the mother note
					//the transaction type will INVEST transType. the note will recieve the investment funds
					//and create a SOLDSTOCK transaction to the initiator'this.s note, which will create a QUOTESTOCK
					//transaction to either create the stock note or update an existing stock note.
					//first we save the block IDs in the newBlock
					let blockID				= newBlock.blockID;
					let nextBlockID 		= newBlock.nextBlockID;
					let formerBlockID 		= newBlock.formerBlockID;
					let walletHash			= newBlock.walletHASH;
					let nextWalletHASH 		= newBlock.nextWalletHASH;
					let formerWalletHASH 	= newBlock.formerWalletHASH;
					//this will help preserve the blockRefs and other important info on the block which will be 
					//used by the mother note to prepare the SOLDSTOCK transaction.
					newBlock				= JSON.parse( JSON.stringify( response ));
					//set the mother note Key as public key to encrypt the agreement;
					newBlock.signRef 		= await this.Sign(agreement.privateKey,newBlock.signRef);
					var id 					= await this.generateKey(10);
					await this.setPrivateKey( agreement.privateKey, id );
					newBlock.blockRef 		= await this.getPublicKey(id,true);
					//agreement.privateKey 	= note.budgetKey;
					var id 					= await this.generateKey(10);
					await this.setPublicKey( note.motherKey, id );
					newBlock.recipient	= await this.#encrypt( JSON.stringify( agreement ), id );
					//adding the blockIDs
					newBlock.blockID 			= blockID;
					newBlock.nextBlockID		= nextBlockID;
					newBlock.formerBlockID 	= formerBlockID;
					newBlock.walletHASH		= walletHash;
					newBlock.formerWalletHASH	= formerWalletHASH;
					newBlock.nextWalletHASH	= nextWalletHASH;
					
					//ensure the transType is an INVEST transType so that the program can interprete the details 
					//as INVESTRECIEVE treansType. this transType occurs when a stock or bond note is redirecting a 
					//transaction to her mother note who will create a SOLD transaction to the recipient
					newBlock.transType 		= "INVEST";
					
				} else if( details.transType == "BONDPAY" && this.#isExchangeMarketMining ){
					let exNote 			= await this.getCurrentExchangeNote( note.noteType.slice(0, lastIndexOf("BND") ) + "CRD" );				
					let agrees 			= await this.getNoteAgreements();
					
					if( ! details.agreement || details.agreement.agreeType != "BOND" || ! agrees[ details.agreement.agreeID ] ){
						this.errorMessage("BONDPAY transaction cannot be executed on a note who do not have a registered agreement!");
						return false;
					}					
					
					if( ! note.budgetID ){
						this.errorMessage("Couldn't find a budget key on this bond note. This shows your bond note is invalid and can't recieve interest on bond.");
						return false;
					}
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					let budgetID 		= await this.getPublicKey(id);
					
					if( budgetID != exchangeNote.budgetID ){
						this.errorMessage("budget on bond note not equal to the budget key on the exchange note.");
						return false;
					}
					
					let curTime = this.currentTime();
					let payTime = details.agreement.payTime;
					let payPeriod 	= details.agreement.payPeriod;
					
					if( payTime > curTime ){
						this.errorMessage("BOND PAY Transaction time hasn't been set, You still have up to " + (payTime - curTime ) + " Milliseconds to get interest" );
						return false;
					}
					
					let nextTime 	= this.calculateTime( payPeriod );
					
					if( ! nextTime )
						nextTime 	= this.calculateTime( "1 weeks");
					
					payTime 		= parseInt( nextTime ) + parseInt( curTime );
					details.agreement.payTime = payTime;
					
					//does not require that the exchange note runs as
					//the current note.
					newBlock.agreement 	= JSON.parse( JSON.stringify( details.agreement ));
					newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
					
					if( ! currentNote || currentNote.noteAddress != exNote.exchangeID ){
						currentNote = JSON.parse( JSON.stringify( exNote ));
						currentNote.noteAddress = exNote.exchangeID;
						currentNote.noteSecret = exNote.exchangeKey;
					}
					
					//currentNote.noteValue  -= parseFloat( details.transValue );
					if( currentNote.exhangeValue >= details.transValue )
						currentNote.exchangeValue 	= parseFloat( currentNote.exchangeValue ) - parseFloat( details.transValue );
					
					else 
						currentNote.demandValue 	= parseFloat( currentNote.demandValue ) + parseFloat( details.transValue );
					
					currentNote.blockID 		= newBlock.blockID;
					
					//setting the block reference system for the block.
					privKey 					= await this.generateKey( 40, true, true );
					var id 						= await this.generateKey(10);
					await this.setPrivateKey( privKey, id );
					agreement.privateKey 		= privKey;
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					newBlock.signRef 		= await this.generateKey(30);
					
					if( ! agreement.isColdDeposit ){
						//encrypting the agreement
						//connected credit note receives the transaction						
						this.setPublicKey( note.motherKey, id );
						this.#privKey	= false;
					} else {
						this.#privKey 	= await this.generateKey(10, true );
						await this.setPrivateKey( this.#privKey, id );						
					}
					newBlock.recipient 	= await this.#encrypt( JSON.stringify( details.agreement ), id );			
					newBlock.transValue	= details.transValue;
					newBlock.exchangeNote 	= JSON.parse( JSON.stringify( currentNote ));
					
				}
				else if( details.transType == "BONDRECIEVE" && ( response.transType == "BONDPAY" || response.transType == "QUOTEBOND" ) && this.#isExchangeMarketMining ){
					var id 				= await this.generateKey(10);
					if( this.#privKey ){
						await this.setPrivateKey( this.#privKey, id );
						this.#privKey = false;
					} else {
						await this.setPrivateKey( note.noteSecret, id );
					}
					
					agreement 		= await this.#decrypt( response.recipient, id );
					
					if( agreement && this.isJsonable( agreement ) ) 
						agreement = JSON.parse( agreement );
					
					if( ! agreement || ! agreement.privateKey ) return false;
					
					
					//updating the note value.
					note.noteValue 		= parseFloat( note.noteValue ) + parseFloat( details.transValue );
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( agreement.privateKey, id );
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					newBlock.signRef 		= await this.Sign(agreement.privateKey, response.signRef);
					delete agreement.privateKey;
					newBlock.agreement 	= JSON.parse( JSON.stringify( agreement ));
					newBlock.agreements[ agreement.agreeID ] = newBlock.blockID;
				} else if( this.#transSend.includes( details.transType ) ){
					//checking the agreements on the block to see if the bond file can
					//withdraw or send his credit to another note file in the network.
					let bnAgrees = this.block.agreements;//picking the agreements in the former block where the agreement is supposed to be stored.
					let bnID, bnAgree, runSend = false, value = 0, curTime = this.currentTime(), payTime, expiry;
					
					for( bnID in bnAgrees ){						
						
						if( bnAgrees[bnID].agreeType != "BOND" ) continue;
						
						bnAgree 		= bnAgrees[bnID];
						
						//getting the value.
						value 		= bnAgree.value;
						
						//checking the payTime.
						payTime  	= bnAgree.payTime;
						
						//checking the Exec time, talking about it's expiry.
						expiry 		= bnAgree.ExecTime;
						
						if( note.noteValue <= value  ){
							//this shows the bond note has not earned any interest yet.
							//to withdraw, we check the expiry and the note type.
							if( expiry <= curTime && note.rankPref != "businessManager" ){
								runSend 	= true;
								break;
							} else continue;
						}
						
						if( payTime <= curTime ){
							if( ( parseFloat( value ) + parseFloat( details.transValue ) ) <= note.noteValue ){
								runSend 	= true;
								break;
							}
						}
					}
					
					if( ! runSend ){
						this.errorMessage("Can't Process Withdrawal From Your Bond Note. Your Bond Note is Not Eligible to Withdraw!");
						return false;
					}
					
					//checking the recipient.
					if( ! details.recipient || ( details.recipient != note.motherKey ) ){
						this.errorMessage("No Valid Recipient in The Request, reverting to your note's Mother Key if it Exists.");
						
						if( note.motherKey )
							details.recipient = note.motherKey;
						
						else {
							this.errorMessage("Please Set a Mother Key on You Bond Not Before Withdrawing");
							return false;
						}
					}
					
					details.agreement = bnAgree;					
					
					//adding the block refs to the block.
					newBlock.signRef 		= this.generateKey(15);
					details.agreement.privateKey = this.generateKey(40, true, true );
					var id 					= await this.generateKey(10);
					await this.setPrivateKey ( details.agreement.privateKey, id );
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					
					if( details.recipient ) {
						var id 				= await this.generateKey(10);
						this.setPublicKey( details.recipient, id );
						
						if( details.recipient.length == 171 )
							newBlock.recipient 	= await this.#encrypt( JSON.stringify( details.agreement ), id );
						
						else
							newBlock.recipient 	= this.encrypt( JSON.stringify( details.agreement ), this.publicKey[id] );
						
						delete details.agreement.privateKey;
					}
					
					note.noteValue = parseFloat( note.noteValue ) - parseFloat( details.transValue );
					newBlock.transValue = details.transValue;
					newBlock.transType = details.transType;
					
				}
				else if( details.transType == "SELLBOND" ){
					if( note.noteValue < details.transValue ){
						this.errorMessage("Note value cannot handle the sales request!");
						return false;
					}
					
					let bondAgrees = JSON.parse( JSON.stringify( newBlock.agreements ));
					let agreement = null, blk;
					
					for( agreeID in bondAgrees ){
						this.blockID 		= bondAgrees[ agreeID ];
						blk 				= await this.getTransBlock(1);
						
						if( blk.length && blk[0].agreement && blk[0].agreement.value )
							agreement 		= JSON.parse( JSON.stringify( blk[0].agreement ));
						
						else 
							agreement 		= null;
						
						if( agreement && agreement.value < details.transValue ) {
							agreement 	= null;
							continue;
						}
					}
					
					if( ! agreement ){
						this.errorMessage("We couldn't find any bond agreement to handle the request");
						return false;
					}
					
					let value 		= parseFloat( agreement.value ) - parseFloat( details.transValue );
					
					if( value == 0 ){
						delete newBlock.agreements[ agreement.agreeID ];
					} else {
						newBlock.agreement 							= JSON.parse( JSON.stringify( agreement ));
						newBlock.agreements[ agreement.agreeID ] 	= newBlock.blockID;
						newBlock.agreement.value 					= value;
					}
					
					
					
					note.noteValue 		=  parseFloat( note.noteValue ) - parseFloat( details.transValue );
					newBlock.transValue 	= details.transValue;
					agreement.privateKey	= await this.generateKey(10, true, true );
					agreement.value 		= details.transValue;
					
					//set a communication channel for interested buyers.
					agreement.agreeKey 		= await this.generateKey(10, true);
					note.agreements.push({agreeID: aagreement.agreeID, key: agreement.agreeKey});
					var id 					= await this.generateKey(10);
					await this.setPrivateKey( agreement.agreeKey, id );
					agreement.agreeKey 		= await this.getPublicKey(id);
					
					//insert agreement to the agreement handler on the block
					newBlock.agreement 		= JSON.parse( JSON.stringify( agreement ));
					await this.setPrivateKey( agreement.privateKey, id );
					newBlock.blockRef 		= await this.getPublicKey( id, true );
					newBlock.signRef 		= await this.generateKey(20);
				}
		}

		if( details.transType == "SPLIT" && this.#splitNote ){
			//simply define the trans value.
			let agrees, value = 0, blk;
			if( Object.keys( newBlock.agreements ) > 1 ){				
				for( agreeID in newBlock.agreements ){
					this.blockID 		= newBlock.agreements[agreeID];
					blk 				= await this.getTransBlock(1);
					
					if( blk.length && blk[0].blockID && blk[0].agreement )
						agrees 		= JSON.parse( JSON.stringify( blk[0].agreement ));
					
					else
						agrees 		= {};
					
					value 		+= parseFloat( agrees.value );
				}
			}
			
			if( ! this[this.#odogwu] && details.transValue > ( parseFloat( note.noteValue ) - value ) ){
				this.errorMessage("Error Generating Transaction. Can't generate a Child note with Value " + details.transValue + " From Note with Value of " + note.noteValue );
				return false;
			} else {			
				
				note.noteValue 			= parseFloat( note.noteValue ) - parseFloat( details.transValue );
				newBlock.transValue 		= details.transValue;
				newBlock.transType 		= details.transType;
				this.#splitNote.noteValue 		= details.transValue;
				if( ! note.referer )
					note.referer 		= this.generateKey(15);
				
				this.#splitNote.referee  	= note.referer;
				
				if( details.agreement && details.recipient && typeof details.agreement == "object" ){
					details.agreement.privateKey 		= await this.generateKey(10, true, true );
					var id 					= await this.generateKey(10);
					await this.setPrivateKey( details.agreement.privateKey, id );
					details.agreement.note 	=  JSON.parse( JSON.stringify( this.#splitNote ) );
					var string 			= JSON.stringify( details.agreement );
					newBlock.agreement = this.hashed( string );
					newBlock.recipient = this.encrypt( string, details.recipient );
					newBlock.blockRef 	= await this.getPublicKey(id, true);
					newBlock.signRef 	= await this.generateKey(10);
				}
				
				newBlock.splitID 		= this.Base64.encode( await this.generateKey( newBlock.blockID.length ) ).toString().slice(0, newBlock.blockID.length );
			}
		}
		//await this.createAlert( "Before Merging note: " + details.transType );
		if( ( details.transType == "MERGE" /* || details.transType == "QUOTEBOND" || details.transType == "QUOTESTOCK" */ ) && this.mergeNote && this.mergeNote.noteValue && this.mergeNote.noteValue == details.transValue ){
			//exchange details from this note into the new note, merging means the new note now inherit everything in the
			//former note except the note address and the note secret. The merge note's password is irrelevant because 
			//before the function is used the merge note must have been decrypted by who ever wants to recieve it.
			//sometimes the note details are saved in the details of the agreement send with the block of the note That
			//indicates their interest in the merging
			//await this.createAlert( "Merging note: " + details.transType );
			
			if( ! this.mergeNote.block || this.mergeNote.blockID ){
				this.errorMessage("Can't Merge a Note Without A Reference Block");
				return false;
			}
			
			if( this.set_pass )
				this.#set_pass = this.set_pass;
			
			delete this.set_pass;
			
			if( this.mergeNote.block ){
				this.block 		= JSON.parse( JSON.stringify( this.mergeNote.block ));
			} else {
				this.blockID  	= this.mergeNote.blockID;
				this.block 		= await this.getTransBlock();
				this.block 		= this.block[0];
			}
			
			if( ! this.block ){
				this.errorMessage("Can't Merge a Note without a reference Block!!!");
				return false;
			}
			else {
				//await this.createAlert( "Merging note 2: " + details.transType );
				if( this.block.transType == "SPLIT" || this.block.transType == "SOLDBOND" || this.block.transType == "SOLDSTOCK" ){
					if( ! this.block.recipient ){
						//await this.createAlert( "Merging note Error 1: " + details.transType );
						this.errorMessage("No Recipient in a SPLIT Block, block can't be Merged!!!");
						return false;
					} else {
						if( ! this.#set_pass ){
							//await this.createAlert( "Merging note Error 2: " + details.transType );
							this.errorMessage("No Password to decrypt the agreement. Use the set_pass property to import password into Scriptbill");
							return false;
						} else {
							//console.log('block: ', this.block, JSON.stringify( this.block ));
							let agreedment 	= this.decrypt( this.block.recipient, this.#set_pass );
							//console.log("agreement: ", agreedment, JSON.stringify( agreedment ));
							//await this.createAlert("check agreement");
							
							if( ! this.isJsonable( agreedment ) ){
								//await this.createAlert( "Merging note Error 3: " + details.transType );
								this.errorMessage("Agreement on the SPLIT block could not be successfully decrypted!!!");
								return false;
							} else {
								agreedment = JSON.parse( agreedment );
								
								if( agreedment.privateKey ){
									var id 				= await this.generateKey(10);
									await this.setPrivateKey( agreedment.privateKey, id );
									newBlock.blockRef = await this.getPublicKey( id, true );
									
									//before finally recieving the block we check
									//for the block ref and see if anyone has it In
									//the network.
									this.blockRef 		= newBlock.blockRef;
									let dblock 			= await this.getTransBlock(100, {blockRef: this.blockRef});
									
									if( dblock.length && dblock.length >= 2 ){
										let lastID  	= false, merged = false;
										for( let d = 0; d < dblock.length; d++ ){
											if( lastID && lastID == dblock[d].blockID ) continue;
											
											lastID 		= dblock[d].blockID;
											
											if( dblock[d].transType == "MERGE" ){
												this.errorMessage( "Block With ID " + this.block.blockID + " Is Already Merged, Please Try Merging Another Block " );
												merged 		= true;
												break;
											}
										}
										
										if( merged ){
											return false;
										}
									}
									
									if( this.block.signRef ){
										this.signTxt 		= this.block.signRef;
										this.signKey 		= agreedment.privateKey;
										newBlock.signRef 	= await this.Sign(agreedment.privateKey, this.block.signRef);
									}
									
									if( ! newBlock.agreements || typeof newBlock.agreements != "object" )
										newBlock.agreements = {};
									
									if( agreedment.agreeID ){
										newBlock.agreement 		=JSON.parse( JSON.stringify( agreedment));
										newBlock.agreements[agreedment.agreeID ] = newBlock.blockID;
									}
									
									else if( agreedment.agreement && agreedment.agreement.agreeID ){
										newBlock.agreement 		= JSON.parse( JSON.stringify( agreedment.agreement));
										newBlock.agreements[agreedment.agreement.agreeID ] = newBlock.blockID;
									}
								}
							}
						}
					}
					newBlock.transType 	= details.transType;
					newBlock.transValue 	= details.transValue;
					newBlock.noteServer 	= note.noteServer;
					//await this.createAlert( "Merging note 3: " + details.transType );
				} else {
					//this shows that the note to be merged is controlled by the merger
					//just add the block id as a reference.
					newBlock.blockRef = this.block.blockID;
					this.successMessage("Successfully added block refernce to MERGE trans block.");
				}
			}
			
			
			let valued;
			for( let keyed in this.mergeNote ){
				if( (keyed == "noteAddress" || keyed == "noteSecret")  ) continue;
				
				valued 		= this.mergeNote[ keyed ];
				
				if( typeof valued == "string" ) continue;
				
				if( valued.length ){
					for( let d = 0; d < valued.length; d++ ){
						if( ! note[ keyed ] || ! note[ keyed ].length ){
							note[ keyed ] = [];
						}
						
						note[ keyed ].push( valued[d] );
					}
				}
				else if( Object.keys( valued ).length ){
					for( let id in valued ){
						if( typeof note[ keyed ] != "object" ){
							note[ keyed ] = {};
						}
						
						note[keyed][id] = valued[id];
					}
				}				
			}
			
			if( details.agreement ){
				if( typeof details.agreement != "object" && details.recipient ){
					details.agreement 		= this.decrypt( details.agreement, details.recipient );
					
					if( this.isJsonable( details.agreement ))
						details.agreement 		= JSON.parse( details.agreement );
					
					else 
						details.agreement 		= false;
				}
				newBlock.agreement = details.agreement;
				//note.noteAgreements.push( details.agreement.agreeID );
				newBlock.agreements[ details.agreement.agreeID ] = newBlock.blockID;
			}
			
			if( typeof note.noteValue == "string" )
				note.noteValue = parseFloat( note.noteValue );
			
			note.noteValue 	+= parseFloat( details.transValue );
			newBlock.transType = details.transType;
			//console.log("inner new block: ", newBlock, JSON.stringify( newBlock ));
			//await this.createAlert( "Merging note 5: " + details.transType );
			//await this.createAlert( "Check inner new block - tansType: " + newBlock.transType );
		}
		
		
		if( details.transType == "CREDIT" ){
			
			if( response.transType == "GETCREDIT" ){
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( note.noteSecret, id );
				let name 		= await this.#decrypt( response.recipient, id );
				
				if( ! name || (response.agreement && response.agreement.name != name ) ){
					this.errorMessage(" We couldn't verify your ownership of this product credit transaction, Please re-try with the correct transaction block" );
					return false;
				}
				
				newBlock.recipient 	= name;
				newBlock.agreement 	= response.agreement;
				note.noteValue 		= parseFloat( note.noteValue ) + parseFloat( response.transValue );
				
				if( newBlock.agreement.units ){
					if( newBlock.agreement.agreeType == "PRODUCT" )
						newBlock.agreement.units = parseInt( newBlock.agreement.units ) - 1;
					
					else if( newBlock.agreement.agreeType == "SUBSCRIPTION" ){
						if( note.accountData ){
							//this shows the seller has not recieved any subscription
							//before on this product.
							if( ! note.accountData['SUBSCRIBED'] ||  ! note.accountData['SUBSCRIBED'][newBlock.agreement.subID] ){
								newBlock.agreement.units = parseInt( newBlock.agreement.units ) - 1;
								
								if( ! note.accountData['SUBSCRIBED'] )
									note.accountData['SUBSCRIBED'] = {};
								
								let subs 	= {
									blockID 	: response.blockID,
									value 		: response.transValue,
									totalValue 	: response.agreement.productValue,
									subID 		: response.agreement.subID
								};
								note.accountData['SUBSCRIBED'][subs.subID] = subs; 
							} else {
								let subs 	= note.accountData['SUBSCRIBED'][subs.subID];
								subs.blockID 	= response.blockID;
								subs.value 		= parseFloat( subs.value ) + parseFloat( response.transValue );
								note.accountData['SUBSCRIBED'][subs.subID]	= subs;
							}
							
							newBlock.agreement.agreeType = "PRODUCT";
							delete newBlock.agreement.subID;
							newBlock.transValue 	= newBlock.agreement.productValue;
						}
					}
					newBlock.transType = "CREDIT";//this continues the product or
					//credit transaction.
				} else {
					//if the unit of the agreement is done, we simply change the
					//transaction type to recieved transaction to indicate the end 
					//of selling the product.
					newBlock.transType 		= "RECIEVE";
					details.transType 		= newBlock.transType;
					transType 				= newBlock.transType;
					newBlock.transValue 	= response.transValue;
				}
				
				this.s[ note.noteAddress + '_withdrawal_funds' ] = parseFloat( response.transValue ).toFixed(2);
				
			} else {
			
				//coming to this.
				if( ! details.agreement )
					details.agreement = await this.createAgreement();
				
				if( ! details.agreement.agreeID )
					details.agreement.agreeID = await this.generateKey(15, true, true);
				
				if( ! note.agreements )
					note.agreements 		= [];
				
				note.agreements.push({
					key 	: details.agreement.privateKey,
					agreeID : details.agreement.agreeID
				});
				
				delete details.agreement.privateKey;
				
				this.signTxt 	= this.currentTime();
				/* this.signKey 	= details.agreement.agreeID;
				details.agreement.agreeSign = await this.Sign();
				await this.setPrivateKey( this.signKey );
				details.agreement.agreeID 	= await this.getPublicKey(true);
				
				if( ! note.noteAgreements )
					note.noteAgreements = [];
				
				note.noteAgreements.push( this.signKey ); */
				
				details.agreement.agreeTime	= this.signTxt;
				newBlock.transValue 		= details.transValue;
				newBlock.transType 			= "CREDIT";	
			}
			details.agreement.privateKey 	= await this.generateKey(10, true, true );
			details.agreement.motherKey 	= note.noteAddress;
			var id 							= await this.generateKey(10);
			await this.setPrivateKey( details.agreement.privateKey, id );
			newBlock.blockRef 			= await this.getPublicKey( id, true );
			newBlock.signRef 			= await this.generateKey(15);
			var string 				= JSON.stringify( details.agreement );
			
			if( details.agreement.agreeType == "PRODUCT" ){
				newBlock.agreement 		= JSON.parse( JSON.stringify( details.agreement ));
				newBlock.recipient 		= details.recipient;
			} else {
				newBlock.agreement 		= this.hashed( string );
				newBlock.recipient 		= this.encrypt( string, details.recipient );
			}
			newBlock.splitID			= this.Base64.encode( await this.generateKey(newBlock.blockID.length ) ).toString().slice(0, newBlock.blockID.length );
		} else if( response && response.transType == "CREDIT"  && details.transType == "GETCREDIT" && response.agreement ){
			
			if( typeof response.agreement == "object" && response.agreement.agreeType == "PRODUCT" ) {
				let product 		= JSON.parse( JSON.stringify( response.agreement ));
				product.name 		= response.recipient;
				product.value 		= response.agreement.productValue;
				
				if( note.noteValue < product.value && ( product.canSubscribe == "No" || ! product.canSubscribe ) ){
					this.errorMessage("Product Can't Be Sold, Your Note Doesn't Have Enough Credit to Fulfill This Request!!!");
					return false;
				} else if( ( product.canSubscribe == "Yes" && note.noteValue < product.value ) || details.type == "SUBS"){
					let amountSub = details.transValue;
					
					if( details.type != "SUBS" )
						amountSub = await this.createPrompt( "How much do you want to subscribe to this product. Note that the more you pay for a product as subscription, the higher your earnings and loan/crediting opportunities", product.value );
					
					if( amountSub && amountSub < product.value ){
						product.value 	= amountSub;
						var string 	= product.name + product.storeID;
						var id 			= this.hashed( string );
						
						if( ! note.accountData )
							note.accountData 	= {};
						
						if( ! note.accountData['subscriptions'] )
							note.accountData['subscriptions'] = {};
						
						let elapse 	= parseInt( this.currentTime() ) +  parseInt( this.calculateTime("1 Weeks") );
						
						if( ! note.accountData['subscriptions'][id] ){
							note.accountData['subscriptions'][id] = {remains: parseFloat( response.agreement.productValue ) - parseFloat( product.value ), lastSub: product.value, totalSub: response.transValue, elapse: elapse, blockID: response.blockID, subID : await this.generateKey(10) };
							response.agreement.agreeType 	= "SUBSCRIPTION";
							response.agreement.subID 		= note.accountData['subscriptions'][id].subID;
						} else {
							let remaining = note.accountData['subscriptions'][id].remians;
							note.accountData['subscriptions'][id].remains = parseFloat( remaining ) - parseFloat( amountSub );
							note.accountData['subscriptions'][id].lastSub = amountSub;
							note.accountData['subscriptions'][id].elapse 	= elapse;
							note.accountData['subscriptions'][id].blockID = response.blockID;
						}
						
					}
					if( ! amountSub ){
						this.errorMessage("You have a Zero Purchase level.");
						return false;
					}
				} else if( product.value <= 0 ){
					product.value 	= await this.createPrompt( "Enter the amount you want to pay for this product", "1" );
					
					if( parseFloat( product.value ) == 0 || parseFloat( product.value ) == NaN ){
						this.errorMessage("You have a Zero Purchase level.");
						return false;
					}
				}
				
				note.noteValue 			= parseFloat( note.noteValue ) - parseFloat( product.value );
				newBlock.transValue 	= product.value;
				
				if( ! response.agreement.motherKey ){
					this.errorMessage("Product Can't Be Purchased Without a Mother Key or the Recipient Address!");
					return false;
				}
				
				this.setPublicKey( response.agreement.motherKey );
				newBlock.recipient 		= await this.#encrypt( product.name );
				newBlock.agreement 		= JSON.parse( JSON.stringify( response.agreement ));
				let Time				= parseInt( this.currentTime());
				let Ptime 				= parseInt( this.calculateTime('2 Weeks') );
				
				if( newBlock.agreement.ExecTime < Time || newBlock.agreement.ExecTime < ( Time + Ptime ) )
					newBlock.agreement.ExecTime = ( Time + Ptime );
				
				var signKey 			= newBlock.agreement.privateKey;
				var signTxt				= response.signRef;
				newBlock.signRef 		= await this.Sign(signKey, signTxt);
				var id 					= await this.generateKey(10);
				await this.setPrivateKey( newBlock.agreement.privateKey, id );
				newBlock.blockRef		= await this.getPublicKey( id, true );
				newBlock.transType 		= "GETCREDIT";
				
			}
		}
		
		if( details.transType == "AGREESEND" && details.agreement && details.agreement.agreeID && ( ( newBlock.agreements && newBlock.agreements[ details.agreement.agreeID ] ) || ( this.#agreeBlock && this.#agreeBlock.agreements && this.#agreeBlock.agreements[ details.agreement.agreeID ] )) ){
			let agreement 		= JSON.parse( JSON.stringify( details.agreement ) );
			this.blockID 	= agreement.senderID;
			this.server 		= ( newBlock.exchangeNote && newBlock.exchangeNote.noteServer ? newBlock.exchangeNote.noteServer : this.#default_scriptbill_server );
			block 				= await this.getTransBlock();
			let time 			= this.currentTime();
			
			if( ! this.#agreeBlock ){
				//charge the note.
				if( note.noteValue < details.transValue && time < details.agreement.maxExecTime )
					return false;
				
				note.noteValue = parseFloat( note.noteValue ) - details.transValue;
				
			} else {
				newBlock.referenceID 	= this.#agreeBlock.blockID;
				newBlock.referenceKey 	= details.agreement.agreeID;
			}
			
			newBlock.transValue 		= details.transValue;
			newBlock.transType 			= details.transType;
			
			//setting the recipient handler. this will help the recipient of this fund prove that they 
			//actually created the agreement in the block.
			//no need to sign the agreement since it is auto executed.
			//we wait till our recipient acknowledge the recipt of the funds.
			//Can an autoexecuted transaction happen without the note logged in?
			//No? the note must first log in, the only way the user can escape an autoexecuted TRANSACTION
			//is if he tampers with the agreement on his block. Verifiers will ask for the former block
			//before accepting the newBlock, if the former block has verifiers, some of the verifiers 
			//will be contacted for a back up block. If information on the former block does not match 
			//info on the back up block, the transaction becomes invalid. A verifier must have a verified block 
			//to verify, successful verification attracts eligibility
			this.setPublicKey( agreement.agreeKey );
			var string 			= JSON.stringify( agreement );
			newBlock.recipient = await this.#encrypt( string );
			newBlock.agreement = this.hashed( string );
			
			
			if( block.length && block[0].blockID ){
				this.server 	= block[0].noteServer;
			}
		}
		
		if( ! [ "BUYPRODUCT", "CREATEPRODUCT", "CREATEBUDGET", "UPDATEPRODUCT", "PRODUCTSUB", "UPDATEBUDGET", "PROFITSHARING", "PROFITRECIEVE" ].includes( newBlock.transType ) && newBlock.productNote ){
			delete newBlock.productNote;
			
			if( newBlock.exchangeNote && newBlock.exchangeNote.budgetID )
				newBlock.budgetID 			= newBlock.exchangeNote.budgetID;
		}
		
		if( ! note.referer  )
			note.referer 		= await this.generateKey(15);
		
		if( ! note.referee && this.referee )
			note.referee 		= this.referee;
		
		if( ( response && response.blockID && response.noteServer ) || (  details.recipient && details.recipient.length == 171 ) ){
			let servers = [], server;
				
			if( this.l.scriptbillServers && this.isJsonable( this.l.scriptbillServers ) )
				servers = JSON.parse( this.l.scriptbillServers );
				
			if( typeof servers == "object" && typeof servers.length == "number" ){
				if( servers.length <= 1 ){
					
					if( response.noteServer )
						servers.push( response.noteServer );
					
					if( details.recipient && details.recipient.length == 171 && ! newBlock.productNote ) {
						server = this.#default_scriptbill_server + details.recipient.slice(0,24).replaceAll('/','');
						servers.push( server );
					} else if( newBlock.productNote && newBlock.productNote.noteServer )
						servers.push( response.productNote.noteServer );
				} else if( servers.length > 1 ){
					
					if( response.noteServer )
						servers.splice( 1, 0, response.noteServer );
					
					if( details.recipient && details.recipient.length == 171 && ! newBlock.productNote ) {
						server = this.#default_scriptbill_server + details.recipient.slice(0,24).replaceAll('/','');
						servers.splice( 2, 0, server );
					} else if( newBlock.productNote && newBlock.productNote.noteServer )
						servers.splice( 2, 0, newBlock.productNote.noteServer );
				} 
			}
		}
		
		//a quick check.
		/* if( transValue != newBlock.transValue )
			newBlock.transValue = transValue; 
		
		if( transType != newBlock.transType )
			newBlock.transType = transType;*/
		
		if( noteType != newBlock.noteType )
			newBlock.noteType = noteType;
		
		if( noteValue != newBlock.noteValue )
			newBlock.noteValue = noteValue;		
		
		//updating the transType on the note.
		note.transType 				= newBlock.transType;
		note.transTime 				= newBlock.transTime;
		
		
		//add the current block ID to the note.
		note.blockID 				= newBlock.blockID;
		
		//cdn: https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.2.1/jsencrypt.min.js
		//next we configure the transaction block to make it useful for the network. Since everything is perfect on the network
		//calculating the transaction time on the block and the exchange note block id
		
		if( newBlock.productID && newBlock.productNote && newBlock.productNote.exchangeID || this.#productBlock ){
				
			if( ! this.#productBlock )
				this.#productBlock 		= JSON.parse( JSON.stringify( newBlock ));
			
			this.#productBlock 			= await this.getCurrentProductBlock( "", this.#productBlock );
			
			newBlock.productFormerBlockID 	= this.#productBlock.productBlockID;
			newBlock.productBlockID 		= this.#productBlock.productNextBlockID;
			newBlock.productNextBlockID 	= await this.calculateNextBlockID( this.#productBlock.productNote, newBlock.productBlockID );
		
			/* var string 					= this.#productBlock.productNote.exchangeID;
			trivKey      					= this.hashed( string );
			
			this.sit 						= "Calculating Exchange Note ID";
			let trivTime 					= this.l[trivKey + "_triv_time"];
			
			if( this.l[trivKey] && trivTime && trivTime > newBlock.transTime )
				newBlock.productFormerBlockID 	= this.l[trivKey];
			
			else
				newBlock.productFormerBlockID 	= this.#productBlock.productBlockID;
			
			//newBlock.transTime 			= this.currentTime();
			var string 					= this.#productBlock.productID + newBlock.transTime + newBlock.productNote.exchangeKey;
			newBlock.productBlockID 			= this.hashed( string );	
			//this.seed 					= newBlock.exBlockID;
			//to be set by verifiers.
			newBlock.productNextBlockID 			= "";
			newBlock.productNote.transTime			= newBlock.transTime;
			//note.noteSecret 				= secret;

			//save the trivkey.
			this.l[trivKey + "_triv_time"] 	= newBlock.transTime;
			this.l[trivKey]					= newBlock.productBlockID; */
		}
		
		if( newBlock.transType == "UPDATE" ){
			newBlock.transValue = 0;
		}
		
		//signing the note.
		this.signTxt 					= newBlock.blockID;
		this.signKey					= this.#isExchangeMarketMining ? currentNote.blockKey : note.blockKey;
		newBlock.noteSign				= await this.Sign(this.signKey, this.signTxt);
		
		//generate new Block key
		note.blockKey				= await this.generateKey(30, true, true );
		var id 						= await this.generateKey(10);
		await this.setPrivateKey( note.blockKey, id );
		newBlock.blockKey 			= await this.getPublicKey( id, true );
		
		/* if( newBlock.transType == "CREATEBUDGET" && newBlock.agreem17164nt && ( newBlock.agreement.budgetType == "business" || newBlock.agreemen17164t.budgetType == "governmental" ) ){
			note.budgetKey 			= note.blockKey;
			newBlock.budgetSign 	= await this.Sign( note.budgetKey, newBlock.blockID );
		} */
		
		//signing the agreement for the user if the trans type is loan
		if( newBlock.tranType == "LOAN" ){
			newBlock.agreement.recieverSign = await this.Sign(note.blockKey, newBlock.blockID );
			newBlock.agreement.recieverID = this.signTxt;
			newBlock.agreement.recieverKey = newBlock.blockKey;
			newBlock.agreements[ newBlock.agreement.agreeID ] = newBlock.blockID;
		}			
		
		//give it a wallet signature.
		this.signTxt					= note.walletID;
		this.signKey					= note.blockKey;
		newBlock.walletSign				= await this.Sign( this.signKey, this.signTxt );
		
		//adding the expiry time to the block
		if( newBlock.transType != "PRODUCTSUB" )
			newBlock.expiry			= parseInt(this.currentTime()) + parseInt(this.calculateTime("2 weeks"));
		
		//ensuring the blocks note type talies with the note's note type.
		if( newBlock.noteType != note.noteType ){
			newBlock.noteType = note.noteType;
			
			//checking the currentNote
			if( newBlock.exchangeNote ){
				if( newBlock.exchangeNote.noteType != note.noteType ){
					newBlock.exchangeNote.noteType = note.noteType;
				}
			}
		}		
		
		note.blockID 			= newBlock.blockID;
		
		if( details.note ){
			newBlock.transNote = details.note;
		} else if( newBlock.transNote ){
			newBlock.transNote = "";
		}
		
		//parsing the argument so that other details from the details handler will be 
		//added to the newBlock forming a possibility of adding extra data to 
		//transaction blocks
		//newBlock 		= this.parseArgs( newBlock, details );

		//await this.createAlert( newBlock.blockID );
		
		//charging the gas fee.
		this.newBlock 	= JSON.parse( JSON.stringify( newBlock ));
		newBlock 		=  await this.chargeGasFee();
		
		if( this.scriptKey ){
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.scriptKey, id );
			newBlock.scriptSign = await this.Sign(this.scriptKey, newBlock.blockID);
			newBlock.scriptKey  = await this.getPublicKey(id, true);
		}
		
		//calculating the agreement hashes. This is important to secure the agreement entry against manipulation once set, except it must be updated through an agreementrequest transaction.
		newBlock.lastAgreeHash 		= formerAgreeHash;
		var string 				= JSON.stringify( newBlock.agreements );
		let agreeHASH 				= this.hashed( string );
		newBlock.agreeHash			= agreeHASH.slice(0,6) + agreeHASH.slice( agreeHASH.length - 7, agreeHASH.length );
				
		//this will be used to verify 
		//newBlock.lastBlockHash 	= note.transHash;
		//newBlock.lastNoteHash 		= note.noteHash;
		
		//creating the total hash variable.
		if( ! newBlock.totalHASH )
			newBlock.totalHASH = "";
		
				
		var string 				= formerHashB + newBlock.totalHASH;
		let totalHash 				= this.hashed( string );
		newBlock.totalHASH			= totalHash;
		
		//creating the real hash variable.
		if( ! newBlock.realHash )
			newBlock.realHash = "";
				
		//this is the total hash of the note stored in the r
		var string					= formerHash + newBlock.realHash;
		newBlock.realHash			= this.hashed( string );
		
		//adding the last variables to the block as supplied by the note
		//during this transaction request.
		newBlock.lastBlockHash	= formerHashB.slice( Math.round( formerHashB.length / 2 ), formerHashB.length );
		newBlock.lastNoteHash	= formerHash.slice( Math.round( formerHash.length / 2 ), formerHash.length );
		
		/* if( currentNote && newBlock.exchangeNote && currentNote.noteType == note.noteType && currentNote.noteAddress == newBlock.exchangeNote.exchangeID  && ! this.#isQuotedNote ){
			newBlock.exchangeNote = JSON.parse( JSON.stringify( currentNote ) );
			delete newBlock.exchangeNote.noteAddress;
			delete newBlock.exchangeNote.noteSecret;
		} */
		
		if( this.#isExchangeMarketMining ){
			currentNote 	= JSON.parse( JSON.stringify( note ) );
			currentNote.blockKey 	= note.blockKey;
			currentNote.blockID 	= newBlock.blockID;
		}
			
		if( this.#fiatCurrencies[ testType ] && ! this.#isQuotedNote){
			//await this.createAlert("Running Test Type! ");
			if( currentNote.noteSecret != motherKeys.noteAddresses[ newBlock.noteType ] ){
				//await this.createAlert("Note Secret Cheated");
				currentNote.noteSecret = motherKeys.noteAddresses[ newBlock.noteType ];
				var id 					= await this.generateKey(10);
				await this.setPrivateKey( currentNote.noteSecret, id );
				currentNote.noteAddress = await this.getPublicKey(id);
				
				if( newBlock.exchangeNote.exchangeID != currentNote.noteAddress ){
					newBlock.exchangeNote.exchangeID = currentNote.noteAddress;
					newBlock.exchangeNote.exchangeKey = currentNote.noteSecret;
				}
				
				if( ! currentNote.withdrawAccount || Object.keys( currentNote.withdrawAccount ).length < 1 ){
					currentNote.withdrawAccount = {accountType:"BTC",accountDetails: await this.getScriptbankAccounts()};
				}
			}
			
			if( currentNote.noteType != newBlock.noteType )
				currentNote.noteType = newBlock.noteType;
			
			let noteAdd = currentNote.noteAddress;
			let secret 	= currentNote.noteSecret;
			delete currentNote.noteAddress;
			delete currentNote.noteSecret;
			newBlock.exchangeNote = JSON.parse( JSON.stringify( currentNote ) );
			newBlock.exchangeNote.exchangeID = noteAdd;
			newBlock.exchangeNote.exchangeKey = secret;
			currentNote.noteAddress 	= noteAdd
			currentNote.noteSecret 	= secret;
		}
		
		if( currentNote && currentNote.exchangeID && currentNote.noteType == note.noteType && ! this.#isQuotedNote && ! newBlock.exchangeNote ){
			newBlock.exchangeNote = JSON.parse( JSON.stringify( currentNote ));//re-assuring exchangeBlocks on all generated blocks.
		}
		
		if( ! newBlock.exchangeNote || ! newBlock.exchangeNote.exchangeKey ){
			if( newBlock.noteType && this.l[ newBlock.noteType + 'ExchangeNote' ] ){
				newBlock.exchangeNote = JSON.parse( this.l[ newBlock.noteType + 'ExchangeNote' ] );				
			}
		}/*  else {
			if( formerBlock && newBlock.noteType && this.l[ newBlock.noteType + 'ExchangeNoteTime' ] > formerBlock.transTime && JSON.stringify( formerBlock.exchangeNote ) == JSON.stringify( newBlock.exchangeNote ) && this.l[ newBlock.noteType + 'ExchangeNote' ] ){
				newBlock.exchangeNote = JSON.parse( this.l[ newBlock.noteType + 'ExchangeNote' ] );
			}
		} */
		
		if( this.#isExchangeMarketMining || this.#isExchangeDeposit )
			newBlock.isExchangeMarketMining	= 1;
		
		else 
			newBlock.isExchangeMarketMining = 0;
		
		/* let dns 		= JSON.parse( this.l.DNS ? this.l.DNS : '{}' );
		
		if( dns[ note.walletID ] ){
			let rns 					= {};
			rns.serverDesc				= dns[ note.walletID ];
			rns.walletID 				= note.walletID;
			newBlock.noteServer 	= JSON.stringify( rns );
		} */
		
		//the trans type and the note type must be equal.
		//the trans type in the details handler will determine how the function handles the transaction,
		//this will ensure the block is describing the real transaction type that was handled by the function
		if( details.transType && newBlock.transType != details.transType ){
			newBlock.transType = details.transType;
		}
		if( details.transType && note.transType != details.transType ){
			note.transType = details.transType;
		}
		
		if( ( newBlock.transType == "UPDATE" || newBlock.transType == "CREATE" ) && newBlock.transValue > 0 ){
			newBlock.transValue = 0;
		}
		else if( details.transValue )
			newBlock.transValue = details.transValue;
		
		
		//console.log( "checking transValue: ", newBlock.transValue );
		if( details.transType == "DEPOSIT" && newBlock.transValue == 0 ) return;
		//await this.createAlert( "Merging note 6: " + newBlock.transType );
		//this will ensure that the block carries the right note or credit type information about the current note
		//handling the transaction. The note value which is another important information must have been gotten 
		//before the function start executing.
		if( newBlock.noteType != note.noteType ){
			newBlock.noteType = note.noteType;
		}
		
		if( ! newBlock.creditType || newBlock.creditType != note.creditType ){
			newBlock.creditType = note.creditType;
		}
		
		/* var string 					=  transKey;
		
		await this.createAlert( "Note Secret Length 3: " + note.noteSecret.length );	
		await this.createAlert( "Note Secret: " + note.noteSecret );	
		
		//if( ! this.#isExchangeMarketMining )
		string 					= this.hashed( string );
		//console.log( "note secret before encrypt: ", note.noteSecret, " key: ", string );
		note.noteSecret 		= this.encrypt( note.noteSecret, string ); 
	
		await this.createAlert( "Note Secret Length 4: " + note.noteSecret.length );	
		await this.createAlert( "Note Secret: " + note.noteSecret );*/	
		
		//to confirm the hashes of the block, you must delete these
		//variables from the block object: "transHash", "blockHash", 
		// and "noteHash" these are the variable added after the 
		//block and note object hashes was calculated.
		delete note.noteHash;
		delete note.transHash;
		delete note.noteSign;
		//hashing the note before saving the transaction block		
		let bleckID 				= note.blockID;
		
		/* if( newBlock && newBlock.productID && ( newBlock.transType == 'BUYPRODUCT' || newBlock.transType == 'PRODUCTSUB') && newBlock.agreement && newBlock.agreement.productConfig )
			note.blockID 			= shareBlock.blockID; */
		
		var string 					= JSON.stringify( note );
		let noteHash				= this.hashed( string );
		this.#noteHASH 				= noteHash;
		newBlock.noteHash			= noteHash.slice( 0, noteHash.length / 2 );
		
		//for the newBlock hashes to be correctly calculated we need to remove variables that changes
		//in the block like the exchangeNotes, exchangeIDs, data handler.
		newBlock.defaultKey 		= this.#odogwu;
		let BLOCK 					= JSON.parse( JSON.stringify( newBlock ));
		note.blockID 				= bleckID;
		
		delete BLOCK.exchangeNote;
		delete BLOCK.data;
		delete BLOCK.productNote;
		delete BLOCK.exBlockID;
		delete BLOCK.exFormerBlockID;
		delete BLOCK.exNextBlockID;
		delete BLOCK.productBlockID;
		delete BLOCK.productFormerBlockID;
		delete BLOCK.productNextBlockID;
		delete BLOCK.transHash;
		delete BLOCK.blockHash;
		delete BLOCK.blockSign;
		delete BLOCK.witnesses;
		delete BLOCK.blockHash;
		delete BLOCK.noteSign;
		
		for( let blockID in BLOCK ){
			if( ! KEYS.includes( blockID ) ){
				delete BLOCK[blockID];
			}
		}
		
		//calculate the transaction hashes of the block, before calculating the total hash of both the note and the block.
		var string 				= JSON.stringify( BLOCK );
		let transHash 				= this.hashed( string );
		newBlock.transHash   		= transHash.slice( 0, transHash.length / 2 );
		
		
		//since the transaction hash is gotten, we save the transaction hash from being manipulated by hashing the total hash of the block in the note.
		var string 					= transHash;
		//saving the half of the trans hash on the note as an evidence to the note.
		//that the note owns the transaction block.
		note.transHash 			= transHash.slice( transHash.length / 2, transHash.length );
		newBlock.blockHash 		= this.hashed( string );

		//let's sign the transaction block.
		newBlock.blockSign				= await this.Sign(note.blockKey, newBlock.blockHash);

		
		note.noteHash				= noteHash.slice( noteHash.length / 2, noteHash.length );
		var string 					= noteHash;
		note.noteSign 				= await this.Sign(note.blockKey, this.hashed( string ));
		//from this point forward, nothing else should be added to the note.
		//this may make the note invalid.
		//console.log( "Create Product ID " + newBlock.productID );
		
		//console.log('Current Note: ' + JSON.stringify(note));
		//await this.createAlert( "Note Secret Length 3: " + note.noteSecret.length );
		
		if( this.#isExchangeMarketMining && newBlock.exchangeNote && newBlock.exchangeNote.exchangeID == note.noteAddress && newBlock.exchangeNote.noteType == note.NoteType && this.#transRecieve.includes( details.transType ) ){
			newBlock.exchangeNote 	= JSON.parse( JSON.stringify( note ));
			newBlock.exchangeNote.noteValue 		= parseFloat( newBlock.exchangeNote.noteValue );
			newBlock.exchangeNote.noteValue 		-= parseFloat( newBlock.transValue );
			newBlock.exchangeNote.exchangeValue 	= parseFloat( newBlock.exchangeNote.exchangeValue );
			newBlock.exchangeNote.exchangeValue 	-= parseFloat( newBlock.transValue );
			delete newBlock.exchangeNote.noteAddress;
			delete newBlock.exchangeNote.noteSecret;
		}
		
		
		this.successMessage( "Transaction Created. Checking Trans Type: " +newBlock.transType );
		
		//console.log('Current Block: ' + JSON.stringify( newBlock ) );
		//save the current block		
		
		//this shows that the product note is the one recieving a transaction from
		//the buyer of a product.
		this.response = JSON.parse( JSON.stringify( newBlock ) );
			
		this.#note 					= JSON.parse( JSON.stringify( note ));
		this.#currentNote 			= JSON.parse( JSON.stringify( currentNote ));
		
		
		if( this.#isQuotedNote ){
			currentNote.transTime 	= note.transTime;
			currentNote.noteHash 	= note.noteHash;
			currentNote.blockKey 	= note.blockKey;
			currentNote.blockHash 	= note.blockHash;
			
			this.#password 		= await this.#getPassword();
			var string 		= this.#password;
			note 				= JSON.stringify( currentNote );
			let pass 			= this.hashed( string );
			//console.log("hashed: " + pass );
			//await this.createAlert("check hashed");
			this.noteEncrypt 	= this.encrypt( note, pass );
			
			let noteEncrypt = await this.binarilize();
			this.download( noteEncrypt, currentNote.noteAddress.toString() + ".script", "text/plain" );
			this.#currentNote = JSON.parse( JSON.stringify( newBlock.exchangeNote ));
			this.#isQuotedNote	= false;
		}
		
		
		//before storing the block we check for some automated instances.
		//if the transaction type running is a recieved transaction and the 
		//reception came from a product block.
		if( newBlock && newBlock.productID && ( newBlock.transType == 'BUYPRODUCT' || newBlock.transType == 'PRODUCTSUB') && newBlock.agreement && newBlock.agreement.productConfig ){
			let shareRate;
			
			if( ! newBlock.agreement.productConfig.shareRate || newBlock.agreement.productConfig.shareRate < 0.2 )
				shareRate 		= 0.2;
			
			else 
				shareRate 	= newBlock.agreement.productConfig.shareRate;
			
			let titheValue 			= newBlock.transValue * shareRate;			
			this.#shareValue 		= titheValue / 2;
			titheValue 				= titheValue - this.#shareValue;
			
			newBlock.exchangeNote.exchangeValue = parseFloat( newBlock.exchangeNote.exchangeValue ) + titheValue;
			
			newBlock.productNote.exchangeValue 	= parseFloat( newBlock.exchangeNote.exchangeValue ) - titheValue;
			
			if( ! newBlock.productNote.bondValue )
				newBlock.productNote.bondValue 		= 0;
			
			newBlock.productNote.bondValue 			= parseFloat( newBlock.productNote.bondValue ) + titheValue;
			
			this.response 						= JSON.parse( JSON.stringify( newBlock ) );
			this.#noVerify 						= false;
			return await this.storeBlock( newBlock, note ).then( async store =>{
				//console.log('stored 1: ' + store );
				//await this.createAlert('stored 1: ' );
				this.returnBlock 		= JSON.parse( JSON.stringify( newBlock ) );
				this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
				if( store ){
					await this.saveNote(note);					
					//this.shareData(false, newBlock);
					//console.log( "data gotten: " + getData, " Stringified: " + JSON.stringify( getData ) );
					
					
					return await this.#profitSharing( newBlock, note, BLOCK, this.response );
				}				
			});
			
		}
		
		else if( ( response && newBlock.transType == 'PROFITRECIEVE' &&  response.transType == 'PROFITSHARING' && response.nextRecipient && this.#shareValue && response.agreement ) ){
			
			block 					= await this.getTransBlock(1, {productBlockID: response.nextRecipient});
			block 					= block[0];
			let agreeTime			=	parseInt( this.calculateTime( response.agreement.payPeriod ) );
			
			if( isNaN( agreeTime ) )
				agreeTime			=	parseInt( this.calculateTime( "2 weeks" ) );
				
			let curTime				= parseInt( this.currentTime() );
			
			if( ! block || block.blockID == this.#note.blockID || block.blockID == '' || ! block.profitKey || this.#shareValue < 1 || block.transTime > ( curTime - agreeTime ) ) {
				//this shows there is no more blocks to recieve the profit.
				//the last block takes the last profit shared.
				//details.recipient = this.#note.noteAddress;
				details.transType	=	"PROFITRECIEVE";
				details.transValue	=	this.#shareValue;
				this.response		= JSON.parse( JSON.stringify( response ));
				block.formerProductBlockID = "";
				return	await this.generateScriptbillTransactionBlock( details, note, response );
			} 
			
			details.recipient = block.profitKey;
			
			
			this.response 		= JSON.parse( JSON.stringify( newBlock ) );
			this.#noVerify		= false;
			return await this.storeBlock( newBlock, note ).then( async store =>{
				//console.log('stored 2: ' + stored );
				//await this.createAlert('stored 2: ');
				this.returnBlock 		= JSON.parse( JSON.stringify( newBlock ) );
				this.returnNote 		= JSON.parse( JSON.stringify( note ) );
				if( store ){
					this.saveNote(note).then( async saved =>{
						
						if( saved ){
							this.shareData( false, newBlock );
					
					
							return await this.#profitSharing( newBlock, note, BLOCK, this.response );
						}
					});					
						
				} else {
					try {
						this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
						this.errorMessage("Couldn't save block " + newBlock.blockID);
						return false;
					} catch( e ){						
						this.l.clear();
						this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
						this.errorMessage("Couldn't save block " + newBlock.blockID);
						return false;
					}
				}
			});
					
		} 
		//await this.createAlert("lasting block");		
		//for transaction that would be quickly processed.
		if( currentNote && currentNote.noteAddress == details.recipient && this.#transSend.includes( newBlock.transType ) && ! this.#isExchangeMarketMining ){

			this.successMessage("Auto Transaction Now Running. Block Transaction Type " + newBlock.transType );
			
			let saveCurrentNote = JSON.parse( JSON.stringify( this.#note ) );
			//console.log("running auto recieve transaction for the exchange market with id: " + currentNote.noteAddress );
			
			this.response = JSON.parse( JSON.stringify( newBlock ) );
			this.details  = JSON.parse( JSON.stringify( newBlock ) );
			
			
			if( this.response.transType == "PROFITSHARING" ){
				this.details.transType 	= "PROFITRECIEVE";
			}
			else if( this.response.transType == "INVEST" ){
				this.details.transType = "INVESTRECIEVE";
			}
			else if( this.response.transType == "BUYBOND" ){
				this.details.transType 		= "SOLDBOND";
			}
			else if( this.response.transType == "BUYSTOCK" ){
				this.details.transType 		= "SOLDSTOCK";
			}
			else if( this.response.transType == "BUYPRODUCT" || this.response.transType == "PRODUCTSUB" ){
				//we remove the tithe value from the exchange note and run the 
				//profit sharing transaction instead of recieve transaction.
				this.details.transType 		= "PROFITSHARING";
				this.details.transValue 	= this.#shareValue;				
			} else {
				this.details.transType = "RECIEVE";
			}
			this.#noVerify		= false;
			return await this.storeBlock( newBlock, note ).then( async store =>{
				//console.log('stored 3: ' + store );
				//await this.createAlert('stored 3: ' );
				this.returnBlock 		= JSON.parse( JSON.stringify( newBlock ) );
				this.returnNote = JSON.parse( JSON.stringify( this.#note ));
				if( store ){
					//await this.createAlert("Stored");					
					await this.saveNote(note);
					this.#saveNote = false;
					this.#note 		= JSON.parse( JSON.stringify( this.#currentNote ) );
					
					this.shareData( false, newBlock );
					//console.log( "data gotten: " + getData, " Stringified: " + JSON.stringify( getData ) );
					
					if( currentNote.exchangeID && newBlock.exchangeNote.exchangeID == currentNote.exchangeID )
						this.#isExchangeMarketMining = true;
					
					if( ! this.#note.accountData )
						this.#note.accountData 			= {};
					
					//console.log("running auto transaction, trans Type: ", this.details.transType );
					return await this.generateScriptbillTransactionBlock(this.details, this.#note).then( block =>{
						this.#isExchangeMarketMining = false;
						this.#currentNote = JSON.parse( JSON.stringify( this.#note ) );
						this.#note = JSON.parse( JSON.stringify( saveCurrentNote ) );
						this.returnBlock 		= JSON.parse( JSON.stringify( newBlock ) );
						return block;
					});
				} else {
					/* //console.log( "store: " + store, "Stringified: " + JSON.stringify( store ) );
					await this.createAlert("Not Stored! "  ); */
					try {
						this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
						this.errorMessage("Couldn't save block " + newBlock.blockID);
						return false;
					} catch( e ){
						this.l.clear();
						this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
						this.errorMessage("Couldn't save block " + newBlock.blockID);
						return false;
					}
				}
			});
			
			
		}	
		
		//this.response = JSON.parse( JSON.stringify( newBlock ) );
		
		if( this.saveCurrentNote && typeof this.saveCurrentNote == "object" && this.saveCurrentNote.noteAddress ) {
			this.#currentNote 	= this.#note;
			this.#note 	= JSON.parse( JSON.stringify( this.saveCurrentNote ) );			
			delete this.saveCurrentNote;
			
			if( response.recipient ){
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( this.#note.blockKey, id );
				let dataAg		= this.decrypt( response.recipient, await this.getPublicKey( id, true ) );
				details 	= JSON.parse( JSON.stringify( newBlock ) );
				
				if( dataAg != response.recipient ){
					details.agreement 		= dataAg;
					if( response.transType == "SOLDBOND" ){
						details.transType = "QUOTEBOND";
					}
					this.#noVerify	= false;
					return await this.storeBlock( newBlock, note ).then( async store =>{
						if( store ){
							this.response 		= JSON.parse( JSON.stringify( response ));
							return await this.generateScriptbillTransactionBlock();
						} else{
							this.l[ newBlock.blockID ] 	= JSON.stringify( newBlock );
							return await this.generateScriptbillTransactionBlock();
						}
					});
				}
			}
		}		
		/* //console.log( newBlock.agreement );
		await this.createAlert( newBlock.agreement ); */
		this.#noVerify			= false;
		return await this.storeBlock( newBlock, note ).then( async store =>{
			//console.log( 'store: ', store );
			//alert('stored last: ' + store );
			//await this.createAlert('stored last: ' );
			this.returnBlock 		= JSON.parse( JSON.stringify( newBlock ) );
			this.returnNote 	= JSON.parse( JSON.stringify( this.#note ));
			if( store ){
				if( ( this.#note.transType == "QUOTEBOND" || this.#note.transType == "QUOTESTOCK" ) && ( response.transType == "SOLDBOND" || response.transType == "SOLDSTOCK" ) && ( this.#note.creditType == "BOND" || this.#note.creditType == "STOCK" ) ){
					this.#note.block = JSON.stringify( newBlock );
					 let accData 	 = await this.getAccountData();

					if( accData && this.#currentNote ){
						this.#note.accountData = JSON.stringify( accData[ this.#currentNote.noteAddress ] );
						
						if( this.#note.walletID != this.#currentNote.walletID )
							this.#note.walletID 		= this.#currentNote.walletID;
					}
					
					this.download_note();
					this.#note  	= JSON.parse( JSON.stringify( this.#currentNote));
					note 			= JSON.parse( JSON.stringify( this.#note ));
				}
				
				await this.saveNote(note);
				
				
				this.shareData( false, newBlock );
				//console.log( "data gotten: " + getData, " Stringified: " + JSON.stringify( getData ) );
				return newBlock;
			} else {
				try {
					//remember to return false here
					this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
					this.errorMessage("Couldn't save block " + newBlock.blockID);
					return false;
				} catch (e){
					this.l.clear();
					this.l[ newBlock.blockID ] = JSON.stringify( newBlock );
					this.errorMessage("Couldn't save block " + newBlock.blockID);
					console.error(e);
					return false;
				}
			}
		});
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}		
	}
	
	static timeToString( time = 1000, date = false ){
		time = parseInt( time );
		if( time < 1000 ){
			return time + " Ms";
		}
		
		if( date ){
			date 	= new Date( time );
			let days   = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
			let months = ["January", "Febuary", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
			let data = "";
			data += date.getDate();
			data = data.toString();
			let d = data[1] ? data[1] : data[0];
			let sts = "st";
			if( d > 3 )
				sts = "th";
			
			else if( d == 3 )
				sts = "rd";
			
			else if( d == 2 )
				sts = "nd";
			
			data += sts + " of";
			let month = months[ date.getMonth() ];
			let day 	= days[ date.getDay() ];
			
			data += " " + month + " " + date.getFullYear() + " at ";
			data = day + " " + data;
			let hr = date.getHours();
			let min = date.getMinutes();
			data += hr + ":" + min;
			return data;
		}
		
		if( time >= 1000 && time <= 60000 ){
			let mode = time % 1000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 1000 ) + " Seconds " + vals;
		}
		
		if( time > 60000 && time <= 3600000 ){
			let mode = time % 60000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 60000 ) + " Minutes " + vals;
			//return ( time / 60000 ).toFixed(2) + " Minutes";
		}
		
		if( time > 3600000 && time <= 86400000 ){
			let mode = time % 3600000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 3600000 ) + " Hours " + vals;
			//return ( time / 3600000 ).toFixed(2) + " Hours";
		}
		
		if( time > 86400000 && time <= 604800000 ){
			let mode = time % 86400000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 86400000 ) + " Days " + vals;
			//return ( time / 86400000 ).toFixed(2) + " Days";
		}
		
		if( time > 604800000 && time <= 2592000000 ){
			let mode = time % 604800000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 604800000 ) + " Weeks " + vals;
		}
		if( time > 2592000000 && time <= 31536000000 ){
			let mode = time % 2592000000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 2592000000 ) + " Months " + vals;
		}
		if( time > 31536000000 ){
			let mode = time % 31536000000;
			let vals = "";
			if( mode > 0 ){
				vals = this.timeToString( mode );
				time -= mode;
			}
			return ( time / 31536000000 ) + " Years " + vals;
		}		
	}
	static async viewAdvert( agreement ){
		
		if( typeof agreement != "object" ) return false;
		
		/* let keys = Object.keys( agreement );
		
		keys 	= keys.filter( (key)=>{
			return Object.keys( this.adsConfig ).includes( key );
		});
		
		if( ! keys.length || Object.keys( this.adsConfig ).length == keys.length ){
			this.errorMessage("agreement keys Poorly configured!");
			return false;
		} */
		
		if( ( ! agreement.banner || ! agreement.video || ! agreement.postUrl ) && ! agreement.productID ){
			this.errorMessage("no banner or video to view ads with!");
			return false;
		}
		
		return new Promise((resolve, reject)=>{
			
			try {
				
				let url = "";
				let isVideo = true;
				let isPost = false;
				if( agreement.video ){
					url = new URL( agreement.video );
				} else if( agreement.banner ) {
					isVideo = false;
					url = new URL( agreement.banner );
				} else if( agreement.postUrl ) {
					isVideo = false;
					isPost 	= true;
					url = new URL( agreement.postUrl );
				}
				let div = document.querySelector("#script-ads") || document.createElement("div");
				
				if(	! div.getAttribute("id") )
					div.setAttribute("style", "position:fixed; top:0; left:0; min-width:100%; min-height:100%; background-color:rgba(0,0,0,0.2); z-index:" + Date.now() + ";display:flex; justify-content:center; align-items:center;");
				
				let contentDiv 	= document.createElement("div");
				contentDiv.setAttribute("style", "width:80%; height:auto; background-color:white;padding:30px;position:relative;");
				let headerDiv 	= document.createElement("div");
				headerDiv.innerText = "View Ads";
				headerDiv.setAttribute("style", "position:absolute; top:0; width:100%; text-align:center;left:0; padding:10px;");
				let el = null;
				if( isVideo ){
					el 		= document.createElement("video");
					el.src 	= url.href;
					el.setAttribute("controls", "");
					el.setAttribute("autoplay", "1");
				} else if(! isPost ){
					el 		= document.createElement("img");
					el.src 	= url.href;
				}
				else {
					el 		= document.createElement("iframe");
					el.src 	= url.href;
				}
				
				el.setAttribute("style", "position:absolute; width:100%; height:70%; top:10%;");
				
				let button  = document.createElement("button");
				button.innerText = "Buy Product";
				
				if( agreement.action ){
					button.innerText 	= agreement.action;
				}
				
				let buttonDiv 		= document.createElement("div");
				buttonDiv.setAttribute("style", "position:position:absolute; bottom:5%; display:flex; justify-content:space-between; flex-direction:column; align-items:center;");
				button.setAttribute("style", "background-color: green; color:white; width:50%;  padding:10px; font-weight:900; text-align:center;");
				
				let close 		= button.cloneNode( true );
				close.innerText 	= "Close Ads";
				close.style.backgroundColor = "red";

				close.addEventListener("click", function(){
					div.remove();
					resolve( {closed:true,viewed:true} );
				}, false);
				
				let these = this;
				button.addEventListener("click", async function(){
					this.innerText 	= "Purchasing Product";
					let bought = await these.buy_product( agreement.productID );
					let $resolve = {viewed:true, closed:false};
					if( bought && bought.blockID && ( bought.transType == "BUYPRODUCT" || bought.transType == "PRODUCTSUB" ) ){
						this.innerText 	= "Product Purchase succcessful";
						$resolve.purchased = true;
						$resolve.value 		= bought.transValue;
						$resolve.blockID 	= bought.blockID;
					} else {
						this.innerText 	= "Product Purchase Unsuccessful";
						$resolve.purchased = false;
					}
					
					setTimeout(function(){
						div.remove();
						resolve( $resolve );
					}, 3000);
					
				}, false);
				
				buttonDiv.appendChild( button );
				buttonDiv.appendChild( close );						
				
				contentDiv.appendChild( headerDiv );
				contentDiv.appendChild( el );
				contentDiv.appendChild( buttonDiv );
				div.appendChild( contentDiv );
				document.body.appendChild( div );
			} catch (e){
				resolve( false );
			}
		});		
	}
	static async #updateNote( note, details ){
		try {			
			
			if( ! note || ! note.noteAddress || ! this.#note || ! this.#note.noteAddress == note.noteAddress || ! details || ! details.transType == "UPDATE" ) return;
			
			if( this.rankPref ){
				note.rankPref = this.rankPref;
				delete this.rankPref;
			}
			
			if( this.verifyID ){
				note.verifyID 	= this.verifyID;
				delete this.verifyID;
			}
			
			if( this.noteTypeU ){
				note.noteType = this.noteTypeU;
				delete this.noteTypeU;
			}
			if( this.BMKEY ){
				note.BMKey = this.BMKEY;
				delete this.BMKEY;
			}
			if( this.noteServer ){
				note.noteServer = this.noteServer;
				delete this.noteServer;
			}
			if( this.version ){
				note.version = this.version;
			}
			
			if( this.loanValue ){
				note.loanValue = this.loanValue;
				delete this.loanValue;
			}
			
			if( this.noteSecret ){
				note.noteSecret = this.noteSecret;
				delete this.noteSecret;
			}
			
			if( this.rankValue ){
				note.rankValue = this.rankValue;
				delete this.rankValue;
			}
			
			if( this.accountData ){
				if( typeof this.accountData == 'object' )
					this.accountData 	= JSON.stringify( this.accountData );
				
				note.accountData = this.accountData;
				delete this.accountData;
			}
			
			return note;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
		}
		
	}
	
	static async getCurrentExchangeBlock( exchangeBlock = null ){
		//console.log("getCurrentExchangeBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getCurrentExchangeBlock";
		
		if( ( ! exchangeBlock || ! exchangeBlock.blockID ) && ( ! this.exchangeBlocks  || ! this.exchangeBlocks.length || typeof this.exchangeBlocks == "object" ) ) return;
		
		if( this.exchangeBlocks && this.exchangeBlocks.length && typeof this.exchangeBlocks == "object" ){
			let x, lastBlock = null;
			for( x = 0; x < this.exchangeBlocks.length; x++ ){
				exchangeBlock = 	JSON.parse( this.exchangeBlocks[x] );
				if( lastBlock && lastBlock.transTime > this.exchangeBlock.transTime ){
					exchangeBlock 		= JSON.parse( JSON.stringify( lastBlock ) );
					lastBlock			= JSON.parse( JSON.stringify( exchangeBlock ) );
				}
				lastBlock 		= JSON.parse( JSON.stringify( exchangeBlock ) );
			}
			
		}
		
		let exBlockID 		= exchangeBlock.exNextBlockID;
		
		if( ! exBlockID )
			return exchangeBlock;
		
		let nextBlock 		= await this.getTransBlock(1, {	exBlockID });
		//console.log( nextBlock );
		
		if( ! nextBlock || ! nextBlock.length || ! nextBlock[0].blockID )
			return exchangeBlock;
		
		exchangeBlock 	= JSON.parse( JSON.stringify( nextBlock[0] ) );
		
		return await this.getCurrentExchangeBlock( exchangeBlock );
			
	}
	
	static async recieveAutoExecute(){
		//console.log("recieveAutoExecute running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "recieveAutoExecute";
		if( ! this.response || this.response.nextBlockID != "AUTOEXECUTE"  )
			return;
		
		let response 	= JSON.parse( JSON.stringify( this.response ) );
		
		this.#note = await this.getCurrentNote();
			
		if( ! this.#note && ! this.#note.noteAddress ) return;
		
		let agreement = response.blockRef;
		//test the agreement with the blockKey
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( this.#note.blockKey, id );
		agreement 		= this.decrypt( agreement, await this.getPublicKey( id, true ) );
		
		if( ! this.isJsonable( agreement ) ){
			//test using the agreement ID. the response blok must be a PRODUCTSUB block for it to work.
			if( response.transType != "PRODUCTSUB" ) return;
			
			let x, privKey, found = false;
			for( x = 0; x < this.#note.agreements.length; x++ ){
				privKey = this.#note.agreements[x];
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( privKey.key.split('----'), id );
				agreement = await this.#decrypt( response.blockRef, id );
				if( ! this.isJsonable( agreement ) ) continue;
				
				found = true;
			}
			
			if( ! found )
				return;
		}
		
		//agreement decrypted.
		this.details = response;
		this.details.transType = "RECIEVE";
		this.details.transValue = 0 - response.transValue;
		this.details.agreement 	= agreement;
		
		//configure the note as well
		//this.#note.blockID 		= response.blockID;
		return await this.generateScriptbillTransactionBlock( this.details, this.#note );
		
	}
	
	static async chargeGasFee(){
		//console.log("chargeGasFee running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "chargeGasFee";
		if( ! this.newBlock || this.newBlock.noteType == "SBCRD" || this.newBlock.noteType == "SBSTK" || this.newBlock.noteType == "SBBND") return this.newBlock;
		try {
			let newBlock 	= JSON.parse( JSON.stringify( this.newBlock ));
			
			let bytes = JSON.stringify( newBlock ).length;
			
			if( ! newBlock.GAS )
				newBlock.GAS = 0;
			
			let GAS 	= newBlock.GAS * 10000000;
			let remainingGas = GAS - bytes;
			newBlock.GAS = remainingGas / 10000000;
			
			return newBlock;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return this.newBlock;
		}
	}
	
	static async getCurrentBlock( blocks ){
		//console.log("getCurrentBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getCurrentBlock";
		
		let realBlock, y, block;
		
		if( typeof blocks == "object" && blocks.length ){
			for( y = 0; y < blocks.length; y++ ){
				block = blocks[y];
				
				if( realBlock && realBlock.transTime < block.transTime ){
					realBlock 		= block;
				} else if( ! realBlock ){
					realBlock 		= block;
				}				
			}
		}
		else {
			
			if( blocks.length == 0 && typeof blocks == "string" && this.isJsonable( blocks ))
				realBlock = JSON.parse( blocks );
			
			else if( typeof blocks == "object" && ! blocks.length )
				realBlock = blocks;
		}
		
		if( ! this.l["HASHTABLE"] || this.noRequest ) return realBlock;
		
		let hashTable = JSON.parse( this.isJsonable( this.l["HASHTABLE"] ) ? this.l["HASHTABLE"]: '{}' );
		
		if( ! hashTable ) return realBlock;
		
		let nextHash;
		//look for block with the wallet Hash.
		
		if( hashTable[ realBlock.nextBlockID ] ){
			nextHash 	= hashTable[ realBlock.nextBlockID ];
		}
		
		if( ! nextHash ) return realBlock;
		
		nextHash 		= nextHash[0];
		let x, lastHash, formerHash;
		
		let lastBlock 		= JSON.parse( JSON.stringify( realBlock ));
		
		for( x = 0; x < Infinity; x++ ){
			lastHash 	= nextHash;
			nextHash    = hashTable[ lastHash ];
			
			if( nextHash ) {
				nextHash 	= nextHash[0];
				formerHash 	= nextHash[1];
			}
			else {
				//time to get the transBlocks
				this.blockID 	= lastHash;
				realBlock		= await this.getTransBlock();
				realBlock 		= realBlock[0];
				
				if( realBlock && realBlock.blockID ) break;
				
				else {
					if( formerHash ){
						this.blockID 		= formerHash;
						realBlock		= await this.getTransBlock();
						realBlock 		= realBlock[0];
						
						if( ! realBlock && ! realBlock.blockID ){
							realBlock = lastBlock;
						}
					}
					
					break;
				}
				
			}
		}
		
		return realBlock;	
		
	}
	
	static async calculateInterestRate( interestType, interestRate ){
		//console.log("calculateInterestRate running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "calculateInterestRate";
		switch( interestType ){
			case "PT":
				return interestRate;
			break;
			case "DL":
				return interestRate;
			break;
			case "HL":
				return interestRate / 24;
			break;
			case "E1H":
				return interestRate / 24;
			break;
			case "E2H":
				return interestRate / 12;
			break;
			case "E3H":
				return interestRate / 8;
			break;
			case "E4H":
				return interestRate / 6;
			break;
			case "E5H":
				return interestRate / 4.8;
			break;
			case "E6H":
				return interestRate / 4;
			break;
			case "E7H":
				return interestRate / 3.43;
			break;
			case "E8H":
				return interestRate / 3;
			break;
			case "E9H":
				return interestRate / 2.67;
			break;
			case "E10H":
				return interestRate / 2.4;
			break;
			case "E11H":
				return interestRate / 2.2;
			break;
			case "E12H":
				return interestRate / 2;
			break;
			case "E13H":
				return interestRate / 1.85;
			break;
			case "E14H":
				return interestRate / 1.71;
			break;
			case "E15H":
				return interestRate / 1.6;
			break;
			case "E16H":
				return interestRate / 1.5;
			break;
			case "E17H":
				return interestRate / 1.41;
			break;
			case "E18H":
				return interestRate / 1.33;
			break;
			case "E19H":
				return interestRate / 1.26;
			break;
			case "E20H":
				return interestRate / 1.2;
			break;
			case "E21H":
				return interestRate / 1.14;
			break;
			case "E22H":
				return interestRate / 1.09;
			break;
			case "E23H":
				return interestRate / 1.04;
			break;
			case "E24H":
				return interestRate;
			break;
			case "E1D":
				return interestRate;
			break;
			case "E2D":
				return interestRate * 2;
			break;
			case "E3D":
				return interestRate * 3;
			break;
			case "E4D":
				return interestRate * 4;
			break;
			case "E5D":
				return interestRate * 5;
			break;
			case "E6D":
				return interestRate * 6;
			break;
			case "E7D":
				return interestRate * 7;
			break;
			case "E8D":
				return interestRate * 8;
			break;
			case "E9D":
				return interestRate * 9;
			break;
			case "E10D":
				return interestRate * 10;
			break;
			case "E11D":
				return interestRate * 11;
			break;
			case "E12D":
				return interestRate * 12;
			break;
			case "E13D":
				return interestRate * 13;
			break;
			case "E14D":
				return interestRate * 14;
			break;
			case "E15D":
				return interestRate * 15;
			break;
			case "E16D":
				return interestRate * 16;
			break;
			case "E17D":
				return interestRate * 17;
			break;
			case "E18D":
				return interestRate * 18;
			break;
			case "E19D":
				return interestRate * 19;
			break;
			case "E20D":
				return interestRate * 20;
			break;
			case "E21D":
				return interestRate * 21;
			break;
			case "E22D":
				return interestRate * 22;
			break;
			case "E23D":
				return interestRate * 23;
			break;
			case "E24D":
				return interestRate * 24;
			break;
			case "E25D":
				return interestRate * 25;
			break;
			case "E26D":
				return interestRate * 26;
			break;
			case "E27D":
				return interestRate * 27;
			break;
			case "E28D":
				return interestRate * 28;
			break;
			case "E29D":
				return interestRate * 29;
			break;
			case "E30D":
				return interestRate * 30;
			break;
			case "ML":
				return interestRate * 30;
			break;
			case "E2M":
				return interestRate * 60;
			break;
			case "E3M":
				return interestRate * 90;
			break;
			case "E4M":
				return interestRate * 120;
			break;
			case "E5M":
				return interestRate * 150;
			break;
			case "E6M":
				return interestRate * 180;
			break;
			case "E7M":
				return interestRate * 210;
			break;
			case "E8M":
				return interestRate * 240;
			break;
			case "E9M":
				return interestRate * 270;
			break;
			case "E10M":
				return interestRate * 300;
			break;
			case "E11M":
				return interestRate * 330;
			break;
			case "E12M":
				return interestRate * 360;
			break;
			case "YL":
				return interestRate * 360;
			break;
			case "E2Y":
				return this.calculateInterestRate( "YL", interestRate ) * 2;
			break;
			case "E3Y":
				return this.calculateInterestRate( "YL", interestRate ) * 3;
			break;
			case "E4Y":
				return this.calculateInterestRate( "YL", interestRate ) * 4;
			break;
			case "E5Y":
				return this.calculateInterestRate( "YL", interestRate ) * 5;
			break;
			case "E6Y":
				return this.calculateInterestRate( "YL", interestRate ) * 6;
			break;
			case "E7Y":
				return this.calculateInterestRate( "YL", interestRate ) * 7;
			break;
			case "E8Y":
				return this.calculateInterestRate( "YL", interestRate ) * 8;
			break;
			case "E9Y":
				return this.calculateInterestRate( "YL", interestRate ) * 9;
			break;
			case "E10Y":
				return this.calculateInterestRate( "YL", interestRate ) * 10;
			break;
			default:
				return interestRate;
			break;
		}			
	}
	
	static async calculateInterestType( rank = false ){
		//console.log("calculateInterestType running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "calculateInterestType";
		if( ! rank ) {
			rank = this.#scriptbillRanks[Object.keys( this.#scriptbillRanks )[0]];
		}
		
		let level = rank.level;
		
		switch(level){
			case 1:
				return "PT";
			break;
			case 2:
				return "PT";
			break;
			case 3:
				return "PT";
			break;
			case 4:
				return "E3H";
			break;
			case 5:
				return "E6H";
			break;
			case 6:
				return "E12H";
			break;
			case 7:
				return "E18H";
			break;
			case 8:
				return "E21H";
			break;
			case 9:
				return "DL";
			break;
			case 10:
				return "E1D";
			break;
			case 11:
				return "E2D";
			break;
			case 12:
				return "E3D";
			break;
			case 13:
				return "E4D";
			break;
			case 14:
				return "E5D";
			break;
			case 15:
				return "E6D";
			break;
			case 16:
				return "WL";
			break;
			case 17:
				return "E8D";
			break;
			case 18:
				return "E10D";
			break;
			case 19:
				return "E12D";
			break;
			case 20:
				return "E2W";
			break;
			case 21:
				return "E16D";
			break;
			case 22:
				return "E18D";
			break;
			case 23:
				return "E20D";
			break;
			case 24:
				return "E3W";
			break;
			case 25:
				return "E24D";
			break;
			case 26:
				return "E27D";
			break;
			case 27:
				return "ML";
			break;
			case 28:
				return "E40D";
			break;
			case 29:
				return "E5W";
			break;
			case 30:
				return "E6W";
			break;
			case 31:
				return "E7W";
			break;
			case 32:
				return "E8W";
			break;
			case 33:
				return "E2M";
			break;
			case 34:
				return "E10W";
			break;
			case 35:
				return "E12W";
			break;
			case 36:
				return "E3M";
			break;
			case 37:
				return "E16W";
			break;
			case 38:
				return "E4M";
			break;
			case 39:
				return "E18W";
			break;
			case 40:
				return "E19W";
			break;
			case 41:
				return "E20W";
			break;
			case 42:
				return "E5M";
			break;
			case 43:
				return "E21W";
			break;
			case 44:
				return "E22W";
			break;
			case 45:
				return "E23W";
			break;
			case 46:
				return "E24W";
			break;
			case 47:
				return "E6M";
			break;
			case 48:
				return "E25W";
			break;
			case 49:
				return "E26W";
			break;
			case 50:
				return "E9M";
			break;
			default:
				return "PT";
			break;
		}
	}
	
	
	static async getObjKey(obj, value) {
		//console.log("getObjKey running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getObjKey";
	  return Object.keys(obj).find(key => obj[key] === value);
	}
	static async getObjKeys(obj, value) {
		//console.log("getObjKeys running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getObjKeys";
	  return Object.keys(obj).filter(key => obj[key] === value);
	}
	
	static async parseArgs( array1, array2 ){
		//console.log("parseArgs running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "parseArgs";
		try {
			let arrKeys1 = Object.keys( array1 );
			let arrKeys2 = Object.keys( array2 );
			let x, val;
			
			//checking the keys in array1 that is not in 2
			for( x = 0; x < arrKeys1.length; x++ ){
				val = arrKeys1[x];
				
				if( arrKeys2.includes( val ) ){
					delete arrKeys2[ this.getObjKey( arrKeys2, val ) ];
				}
			}
			
			for( x = 0; x < arrKeys2.length; x++ ){
				val 	= arrKeys2[x];
				array1[ val ]	= array2[val];
			}
			
			return array1;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return array1;
		}
	}
	
	static async getCurrentWalletBlock( referenceBlock ){
		//console.log("getCurrentWalletBlock running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "getCurrentWalletBlock";
		//the current note must have a walvar id and a reference block with the tight wallet hashes to get the wallet blocks
		if( ! referenceBlock || ! this.walletID || ! referenceBlock.nextWalletHASH ) return referenceBlock;
		
		let walletHASH 	= referenceBlock.nextWalletHASH;
		
		if( ! walletHASH ){
			if( ! this.#note && this.s.currentNote )
				this.#note 		= await this.#getCurrentNote();
			
			walletHASH 	= await this.calculateNextBlockID( this.#note, false, 1, true );
		}
		
		let blocks 			= await this.getTransBlock(1, { walletHASH });
		
		if( blocks && blocks.length && blocks[0].blockID )
			return await this.getCurrentWalletBlock( blocks[0] );
		
		return referenceBlock;				
	}
	
	static async traceBlockIDFromWalletID( walletID = "" ){
		//console.log("traceBlockIDFromWalletID running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "traceBlockIDFromWalletID";
		if( ! walletID && ( this.walletID || this.#note.walletID ) ){
			if( this.walletID ){
				walletID = this.walletID;
			}
			else if( this.#note && this.#note.walletID ){
				walletID 	= this.#note.walletID;
			}
		}
				
		this.getTransactions(function( block, key, t ){
			t.setPrivateKey( walletID );
			if( block.walletHASH && block.nextWalletHASH ){
				let testHASH =  t.#encrypt( block.walletHASH );
				
				if( testHASH == block.nextWalletHASH ){
					t.this.l.walletBlock = JSON.stringify( block );
					t.stop = true;
				}
			}
		});
		
		if( this.l.walletBlock ) {
			let walletBlock = JSON.parse( this.isJsonable( this.l.walletBlock ) ? this.l.walletBlock: '{}' );			
			delete this.l.walletBlock;
			return walletBlock;
		}
		else {
			return false;
		}
	}
	
	static async Sign(key = false, text = false){
		//console.log("Sign running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "Sign";
		try {
			if( CryptoJS && CryptoJS.SHA256 ){
				if( ! key && this.signKey )
					key = this.signKey;
				
				if( ! text && this.signTxt )
					text = this.signTxt;
				try {
					if(  text && key && key.length == 192 ){
						let keyObj 	  = {
							"crv": "P-384",
							"d": "MVgTkLsFc_mU_eniuarTYuu6HLlY5i7xJRbQF4MpC_oaQVUBcaNHXzsTPlGVP9sw",
							"ext": true,
							"key_ops": [
								"sign"
							],
							"kty": "EC",
							"x": "_mB1lrWxcZ46mpR9LhbrKl0RG95DsqtSH67sR3FKc-ZK6l4f13itXd5fTBYc3GgN",
							"y": "YRsJnrdxUmckIOcSnEo_rxrCl4E4X_SVXgWEYSagyiyH8kCtNsN2s0UNDIuDEUi7"
						};
						keyObj.d 		= key.slice(0, 64 );
						keyObj.x 		= key.slice(64, 128 );
						keyObj.y 		= key.slice(128, 192 );
						let privateKey  = await window.crypto.subtle.importKey( 'jwk', keyObj, { name: "ECDSA", namedCurve: "P-384" }, keyObj.ext, keyObj.key_ops );
						let encoder 	= new TextEncoder();
						let encoded 	= encoder.encode( text );
						let signature = await window.crypto.subtle.sign(
						  {
							name: "ECDSA",
							hash: { name: "SHA-384" },
						  },
						  privateKey,
						  encoded
						);
						return this.Base64.encode( this.ab2str( signature ) );
					}
					else {
						return false;
					}
						
				} catch(ex) {
					this.errorMessage("SIGNATURE ERROR: " + ex);				
					return false;
				}
			}
			else {
				return false;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}

	static async Verify( signature, key, text ){
		//console.log("Verify running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "Verify";
		try {
			if( CryptoJS && CryptoJS.SHA256 ) {
				try {
					
					
					
					if( text && key && key.length == 128 && signature ){
						//console.log("VerifyText: " + this.VerifyText, "Sign Key: " + this.VerifyKey, "signature: " + this.signature );
						let keyObj 		= {
							"crv": "P-384",
							"ext": true,
							"key_ops": [
								"verify"
							],
							"kty": "EC",
							"x": "_mB1lrWxcZ46mpR9LhbrKl0RG95DsqtSH67sR3FKc-ZK6l4f13itXd5fTBYc3GgN",
							"y": "YRsJnrdxUmckIOcSnEo_rxrCl4E4X_SVXgWEYSagyiyH8kCtNsN2s0UNDIuDEUi7"
						};
						keyObj.x 				= key.slice( 0, 64 );
						keyObj.y 				= key.slice( 64, 128 );
						let publicKey 			= await window.crypto.subtle.importKey( 'jwk', keyObj, { name: "ECDSA", namedCurve: "P-384" }, keyObj.ext, keyObj.key_ops );
						let encoder 			= new TextEncoder();
						let encoded 			= encoder.encode( text );
						let sign 				= this.str2ab( this.Base64.decode( signature ) );
						//console.log("verifying...");
						return await window.crypto.subtle.verify(
							{
							  name: "ECDSA",
							  hash: { name: "SHA-384" },
							},
							publicKey,
							sign,
							encoded
						  );
					}
					else {
						//console.log("not verified ");
						return false;
					}
				}
				catch (ex){
					//console.log( "verify error: " + ex );
					return false;
				}
			}
			else {
				return false;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	//Scriptbill function can help us trace the blocks that belong to a particular note
	static async calculateNextBlockID( note = false, seed = false, depth = 1, walletID = false, run = 1 ){
		//console.log("calculateNextBlockID running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "calculateNextBlockID";
		if( ! this.runned )
			this.runned = 0;
				
		//the note secret is the key the note has used to calculate the note'this.s unique block ID.
		//the first seed of the note is the current time the note was created. From that time the seed will now be the 
		//current block ID
		
		try {

			if( this.executeStrictly && this.note )
				note = JSON.parse( JSON.stringify( this.note ));
			
			else if( ! note && this.#note )
				note 	= JSON.parse( JSON.stringify( this.#note ));
			
			if( note && ( note.noteSecret || note.exchangeKey ) ){
				if( note.blockID && ! seed ){
					seed = note.blockID;
				}
				
				else if( ! seed ){
					seed = this.currentTime().toString();
				}
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( note.noteSecret ? note.noteSecret : note.exchangeKey, id );
				
				//console.log( "FUNC: calculateNextBlockID: Params: noteSecret: " + note.noteSecret + " seed: " + this.seed + " runned: " + ++this.runned );
				
				if( run >= depth ) {
					let key 	= walletID ? note.walletID : await this.getPublicKey(id);
					let value = this.encrypt( seed, key );
					return CryptoJS.MD5( value.toString()).toString( CryptoJS.enc.Base64 );
				}
				else {
					let key 	= walletID ? note.walletID : await this.getPublicKey(id);
					seed 	= this.encrypt( seed, key );
					seed 	= CryptoJS.MD5( value.toString()).toString( CryptoJS.enc.Base64 );
					run++;
					return await this.calculateNextBlockID( note, seed, depth, walletID, run );				
				}
			} else {
				return seed;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return seed;
		}
		
	}
	
	static async calculateFormerBlockID( note = false, seed = false, depth = 1, walletID = false, run = 1 ){
		//console.log("calculateFormerBlockID running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "calculateFormerBlockID";
		if( ! this.frunned )
			this.frunned = 0;
		
		//the note key is a private key to the note secret, while the note secret is a private key to the note address. 
		//the note address is what is generally known in the network.
			
		
		if( this.executeStrictly && this.note )
			note = JSON.parse( JSON.stringify( this.note ));
		
		else if( ! note && this.#note )
			note 	= JSON.parse( JSON.stringify( this.#note ));
			
		
		if(  note && note.noteSecret ){
			if( note.blockID && ! seed ){
				seed = note.blockID;
			}
			
			else if( ! seed ){
				seed = this.currentTime().toString();
			}
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( note.noteSecret, id );
			
			//console.log( "FUNC: calculateFormerBlockID: Params: noteKey: " + this.#note.noteKey + " seed: " + this.seed + " runned: " + ++this.frunned );
			let key 	= walletID ? note.walletID : await this.getPublicKey(id);
			if( run == depth ) {
				let value = this.decrypt( seed, key );
				return value;
			}
			else {
				seed = this.decrypt( seed, key );
				seed = parseInt( seed );
				
				if( seed )
					return seed;
				
				run++;
				this.calculateFormerBlockID( note, seed, depth, walletID, run );	
			}
		} else {
			return seed;
		}
	}
	
	static async traceBlockIDFromAddress( address = undefined ){
		//console.log("traceBlockIDFromAddress running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "traceBlockIDFromAddress";
		
		//initializing storage.
		
		
		if( !this.#note && this.s.currentNote )
		this.#note  = await this.#getCurrentNote();			
		
		if( ! this.#note || typeof this.#note != 'object' )
			return false;
		
		//Scriptbill function is meant for external note address of which the current note want to transact with.
		//if the address is not set, then the function assumes you want to run the getTransBlock function
		if( address == undefined ) {
			return await this.getTransBlock();			
		}
		
		this.getTransactions(function(block, key, scriptbill ){
			//console.log("the blocks: " + JSON.stringify( block ), "type: " + typeof block, " loop key: " + key );
			//to test if the current block belongs to the current address we encrypt the blockID 
			//to see if it would return the next Block ID.
			//we'll test if the runner wants to search using walvar id
			if( block && block.blockID ){
				if( ! scriptbill.isWalletSearch ) {
					let blockID = block.blockID;
					scriptbill.setPublicKey( address );
					let nextID = scriptbill.#encrypt( blockID );
					
					if( nextID == block.nextBlockID ) {
						scriptbill.stop = true;
						scriptbill.this.s.currentBlock = JSON.stringify( block );
					}
				}
				else {
					let walletHash = block.walletHASH;
					scriptbill.setPrivateKey( address );
					let nextHASH 	= scriptbill.#encrypt( walletHash );
					
					if( nextHASH == block.nextWalletHASH ) {
						scriptbill.stop = true;
						scriptbill.this.s.currentBlock = JSON.stringify( block );
					}
				}
			}
			//we stop the loop after 10000 times
			if( key > 10000 ){
				scriptbill.stop = true;
				return false;
			}
		});
		
		let block = false;
		
		if( this.s.currentBlock != undefined )
			block = JSON.parse( this.isJsonable( this.s.currentBlock ) ? this.s.currentBlock: '{}' );
		
		return block;
		
	}
	
	static async compare(array1, array2, type = 'merge'){
		//console.log("compare running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "compare";
		
		try {
			if( typeof array1 != 'object' || typeof array2 != 'object' ) return [];
			let length;
			let array = [];
			if( array1.length >= array2.length )
				length = array1.length;
			else
				length = array2.length;
			
			if( type = 'merge' ){
				let x;
				for( x = 0; x < length; x++ ){
					if( typeof array1[x] == 'object' )
						array1[x] = JSON.stringify( array1[x] );
					
					if( typeof array2[x] == 'object' )
						array2[x] = JSON.stringify( array2[x] );
					
					if( array1[x] == array2[x] && ! array.includes( array1[x] ) ){
						array.push( this.isJsonable( array1[x] ) ? JSON.parse( array1[x] ) : array1[x] );
					}
					else  {
						if( array.includes( array1[x] ) && ! array.includes( array2[x] ) ){
							array.push( this.isJsonable( array2[x] ) ? JSON.parse( array2[x] ) : array2[x] );
						}
						if( ! array.includes( array1[x] ) && array.includes( array2[x] ) ) {
							array.push( array1[x] );
						}
					}
				}
			} else if( type == 'budgetID' ) {
				let x, IDs = [], times = {};
				for( x = 0; x < length; x++ ){
					if( ! array1[x].budgetID && array2[x].budgetID && ! IDs.includes( array2[x].budgetID ) ) {
						IDs.push( array2[x].budgetID );
						times[ array2[x].budgetID ] = array2[x].transTime;
						array.push( array2[x] );
					}
					else if( array1[x].budgetID && ! array2[x].budgetID && ! IDs.includes( array1[x].budgetID ) ) {
						IDs.push( array2[x].budgetID );
						times[ array2[x].budgetID ] = array2[x].transTime;
						array.push( array2[x] );
					}
					else if( array1[x].budgetID && array2[x].budgetID && array1[x].budgetID == array2[x].budgetID && ! IDs.includes( array1[x].budgetID ) ){
						if( array1[x].transTime >= array2[x].transTime ){
							IDs.push( array1[x].budgetID );
							times[ array1[x].budgetID ] = array1[x].transTime;
							array.push( array1[x] );
						} else {
							IDs.push( array2[x].budgetID );
							times[ array2[x].budgetID ] = array2[x].transTime;
							array.push( array2[x] );
						}
					}
					else if(  array1[x].budgetID && array2[x].budgetID && array1[x].budgetID != array2[x].budgetID ) {
						if( ! IDs.includes( array1[x].budgetID ) ) {
							IDs.push( array1[x].budgetID );
							times[ array1[x].budgetID ] = array1[x].transTime;
							array.push( array1[x] );
						}
						else if( times[ array1[x].budgetID ] < array1[x].transTime ){
							IDs.push( array1[x].budgetID );
							times[ array1[x].budgetID ] = array1[x].transTime;
							array.push( array1[x] );
						}
						if( ! IDs.includes( array2[x].budgetID ) ){
							IDs.push( array2[x].budgetID );
							times[ array2[x].budgetID ] = array2[x].transTime;
							array.push( array2[x] );
						} else if( times[ array2[x].budgetID ] < array2[x].transTime ) {
							IDs.push( array2[x].budgetID );
							times[ array2[x].budgetID ] = array2[x].transTime;
							array.push( array2[x] );
						}
					}
					
					if( IDs.includes( array1[x].budgetID ) && times[ array1[x].budgetID ] < array1[x].transTime ) {
						IDs.push( array1[x].budgetID );
						times[ array1[x].budgetID ] = array1[x].transTime;
						array.push( array1[x] );
					}
					if( IDs.includes( array2[x].budgetID ) && times[ array2[x].budgetID ] < array2[x].transTime ) {
						IDs.push( array2[x].budgetID );
						times[ array2[x].budgetID ] = array2[x].transTime;
						array.push( array2[x] );
					}
				}
			}
			return array;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return array1;
		}
	}
	
	static async getData( key, data, url = "", type = "GET" ){
		//console.log("getData running " + this.funcUp[ this.funcUp.length] );
		let funcUp  = this.funcUp[ this.funcUp.length];
		this.funcUp[ this.funcUp.length] = "getData";
		let note 	= this.#note;
				
		try {
			if( this.s.currentNote && ! this.#note )
				this.#note 	= await this.#getCurrentNote();
			
					
			if( ! url ){			
				
				if( ! this.#note || ! this.#note.noteServer ){
					url 	= this.#default_scriptbill_server;
				}
				else {
					url 	= this.#note.noteServer;
				}

				
			}
			//console.log("url setting: " + url);
			this.url 	= new URL(  url );
			
			if( type == "GET" ){
			
				if( typeof key == "object" && key.length && typeof data == "object" && data.length && data.length == key.length ){
					let x;
					for( x = 0; x < key.length; x++ ){
						this.url.searchParams.set(key[x], data[x]);
					}
				} else if( typeof key == "string" && typeof data == "string" ){
					this.url.searchParams.set( key, data );
				}
				else {
					this.errorMessage("data can't be gotten, Key and Data Gotten was not Properly Configured. Please Set the data and key as an array with the same length or as a String!!!");
					return false;
				}
				this.result = false;
				try {
					return await fetch( this.url.href ).then( response =>{
						return response.text();
					}).then( async result=>{
						if( this.isJsonable( result ) ){
							this.result = JSON.parse( result );					
						} else {			
							this.result = result;
						}
						
						return this.result;
					}).catch( error =>{
						return this.result;
					});
				} catch(e){
					console.error(e);
					return this.result;
				}
						
				return this.result;
			} 
			else if( type == "POST" ){
				let obj = {};
				if( typeof key == "object" && key.length && typeof data == "object" && data.length && data.length == key.length ){
					let x;
					for( x = 0; x < key.length; x++ ){
						obj[key[x]] =  data[x];
					}
				} else if( typeof key == "string" && typeof data == "string" ){
					obj[key] =  data;
				}else {
					this.errorMessage("data can't be gotten, Key and Data Gotten was not Properly Configured. Please Set the data and key as an array with the same length or as a String!!!");
					return false;
				}
				
				return await fetch( this.url.href, {
					method: "POST",
					mode: "no-cors",
					headers : {
						"Content-Type" : "application/json",
					},
					body: JSON.stringify( obj )
				}).then(response =>{
					return response.text();
				}).then(data =>{
					if( this.isJsonable( data ))
						return JSON.parse( data );
					
					return data;
				}).catch( error =>{
					//this.errorMessage( error.toString() );
					return false;
				});
			}
			else if(type == "socket"){
				const client = this.#createClient();
				if(typeof data == "object" && typeof key == "object" && data.length && key.length && data.length == key.length ){
					

					const datas = await Promise.all(data.map( async (dat,  x)=>{
						const {data: datad} 	= await client
											.from("block")
											.select("*")
											.eq(key[x], dat)
											.limit(100)
						return datad;
					}))
					return datas.reduce((all, dat, x)=>{
						if(! all ) all  = [];

						return all.concat(typeof dat == "object" && dat.length ? dat : [dat])
					})
					
				} else {
					data = typeof data == "object" && data.length ? data[0] : data;
					key = typeof key == "object" && key.length ? key[0] : key;
					const {data:datad}  = await client
						.from("blocks")
						.select("*")
						.eq(key, data)
						.limit(100)
						return datad?.length == 1 ?  datad[0]:datad;
				}
				
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
		
	}
	
		
	//Scriptbill function is recursive, ensures that the block is gotten, even though it'this.s not stored on the server.
	//Scriptbill way, the function allows the note to get data from the server that holds it.
	static async getTransBlock( limit = 500, config = {} ){
		//console.log("getTransBlock running " + this.funcUp[ this.funcUp.length - 1], config );
		this.funcUp[ this.funcUp.length] = "getTransBlock";

		//console.log("Used variables: this.blockID " + this.blockID + " " + typeof this.blockID," this.productBlockID: " +  this.productBlockID  + " " + typeof this.productBlockID, " this.walletHASH: " +  this.walletHASH  + " " + typeof this.walletHASH, " this.transType: " +  this.transType  + " " + typeof this.transType, " this.noteTypeS: " +  this.noteTypeS  + " " + typeof this.noteTypeS," this.productID: " +  this.productID  + " " + typeof this.productID , " this.sellCredit: " +  this.sellCredit  + " " + typeof this.sellCredit , " this.buyCredit: " +  this.buyCredit  + " " + typeof this.buyCredit, " this.budgetID: " +  this.budgetID  + " " + typeof this.budgetID , " this.blockRef: " +  this.blockRef  + " " + typeof this.blockRef , " this.exBlockID: " +  this.exBlockID  + " " + typeof this.exBlockID );		
			
						
		//console.log( JSON.stringify( this.#note ), "note as note" );
				
		/* if( ! this.#note || ! this.blockID || ! this.productBlockID || ! this.walletHASH || ! this.transType || ! this.noteTypeS || ! this.productID || ! this.sellCredit || ! this.buyCredit || ! this.budgetID || ! this.blockRef || ! this.exBlockID ) return false; */
		
				
		this.blocks = [];
		this.blockIDs = [];
		let blocks, blockIDs;
		let searched 	= [];
		
		try {	
			//sanitizing the supplied url we must be sure it's a scriptbill server and a valid url.
			if( this.server ){
				try {
					this.server = new URL( this.server );
					let resp 	= await this.getData("scriptbillPing", "TRUE", this.server.origin );
					if( resp && resp.isScriptbillServer && resp.isScriptbillServer == 'TRUE' ) {
						this.server = this.server.href;
					} else {
						delete this.server;
					}
				} catch( e ){
					//console.log("this.server: " + e);
					delete this.server;
				}
			}
			
			if( config.blockRef || this.blockRef ){
				if( ! config.blockRef )
					config.blockRef 	= this.blockRef;
				
				blocks 		= new Promise( (resolve, reject)=>{
					this.getDataPersistently('blockRef', config.blockRef ).then( blocks =>{
						setTimeout(()=>{
							resolve(blocks);
						},1000);
					});
				});
				blocks 		= await blocks;
				blockIDs 	= [];
				
				if( this.blocks.length < limit && blocks ){
					this.blocks = this.blocks.concat( blocks );
					
					if( blocks && blocks.length && typeof blocks == "object" ){
						blocks.forEach( block =>{
							blockIDs.push( block.blockID );
						});
					}
				}
				
				if( this.blocks.length < limit ){ 
				
					blocks 		= await this.getData("blockRef", config.blockRef, this.server ? this.server : "");
					
					if( blocks && blocks.length && typeof blocks == "object" ){
						blocks.forEach( block =>{
							if( ! blockIDs.includes( block.blockID )){
								blockIDs.push( block.blockID );
								this.blocks.push( block );
							}
						});
					}
				
				}
				
				if( this.blockIDs.length < limit && blockIDs.length )
					this.blockIDs = this.blockIDs.concat( blockIDs );
				
				delete this.blockRef;
				searched.push("blockRef");
			}
			if( config.noteType || this.noteTypeS ){
				if( ! config.noteType )
					config.noteType 	= this.noteTypeS; 
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.noteType != "object" )
							config.noteType 	= [ config.noteType ];
						config.noteType.forEach( (noteType)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.noteType == noteType;
								
								
							});
						});
						
					}
				} else {
					//console.log("Note Typing...");
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('noteType', config.noteType ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
										
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("noteType", config.noteType, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					
					}
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				/* //console.log( "block IDs: " + JSON.stringify( this.blockIDs ) );
				await this.createAlert("check Block IDs" ); */
							
				delete this.noteTypeS;
				searched.push("noteTypeS");
			}
			if( config.transType || this.transType ){
				if( ! config.transType )
					config.transType 	= this.transType;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.transType != "object" )
							config.transType 	= [ config.transType ];
						config.transType.forEach( (transType)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.transType == transType;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('transType', config.transType ).then( blocks =>{
							//console.log("blocks",blocks);
							setTimeout(()=>{
								//console.log("blocks 2",blocks, config.transType);
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					//console.log( "check blocks", blocks );
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("transType", config.transType, this.server ? this.server : "", "socket");
						//console.log( "check blocks", blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					
					}
								
					if( this.blockIDs.length >= 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				/* //console.log( "block IDs: " + JSON.stringify( this.blockIDs ) );	
				await this.createAlert("check Block IDs" ); */
							
				delete this.transType;
				searched.push("transType");
			}
			if( this.sellCredit || config.sellCredit ){
				
				if( ! config.sellCredit )
					config.sellCredit 	= this.sellCredit;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.sellCredit != "object" )
							config.sellCredit 	= [ config.sellCredit ];
						config.sellCredit.forEach( (sellCredit)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.noteType == sellCredit;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('noteType', config.sellCredit ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("noteType", config.sellCredit, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){ 
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					
					}			
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.sellCredit;
				searched.push("sellCredit");
			}
			if( config.buyCredit || this.buyCredit ){
				
				if( ! config.buyCredit )
					config.buyCredit 	= this.buyCredit;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.buyCredit != "object" )
							config.buyCredit 	= [ config.buyCredit ];
						config.buyCredit.forEach( (buyCredit)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.noteType == buyCredit;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('noteType', config.buyCredit ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("noteType", this.buyCredit, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					
					}
					
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}

				delete this.buyCredit;
				searched.push("buyCredit");
				
			}
			if( config.transValue || this.transValue ){
				
				if( ! config.transValue )
					config.transValue 	= this.transValue;
				
				let trans 		= config.transValue.toString().split(" ");
				config.transValue = parseFloat( trans[0] );
				let transCheck  = trans[1];
				let typeCheck;
				
				if( transCheck == ">" )
					typeCheck  = "greater";
				
				else if( transCheck == "=" )
					typeCheck  = "equal";
				
				else if( transCheck == ">=" )
					typeCheck  = "greater-equal";
				
				else if( transCheck == "<" )
					typeCheck  = "lesser";
				
				else if( transCheck == "<=" )
					typeCheck  = "lesser-equal";
				
				else
					typeCheck 	= "equal";
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.transValue != "object" )
							config.transValue 	= [ config.transValue ];
						
						config.transValue.forEach( (transValue)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								if( transCheck == "equal" )							
									return block.transValue == transValue;
								
								if( transCheck == "greater" )
									return block.transValue > transValue;
								
								if( transCheck == "greater-equal" )
									return block.transValue >= transValue;
								
								if( transCheck == "lesser" )
									return block.transValue < transValue;
								
								if( transCheck == "lesser-equal" )
									return block.transValue <= transValue;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('transValue', config.transValue, "transactions", typeCheck ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks = await this.getData(["transValue", "type"], [config.transValue, typeCheck ], this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
				}
							
				delete this.transValue;
				searched.push("transValue");
							
				if( this.blockIDs.length > 0 ){
					this.blockIDs = this.blockIDs.filter( blockID =>{
						return blockIDs.includes( blockID );
					});
				}
				
			}
			if( config.noteValue || this.noteValue ){
				
				if( ! config.noteValue )
					config.noteValue 	= this.noteValue;
				
				let trans = config.noteValue.split(" ");
				config.noteValue = parseFloat( trans[0] );
				let transCheck  = trans[1];
				let typeCheck;
				
				if( transCheck == ">" )
					typeCheck  = "greater";
				
				else if( transCheck == "=" )
					typeCheck  = "equal";
				
				else if( transCheck == ">=" )
					typeCheck  = "greater-equal";
				
				else if( transCheck == "<" )
					typeCheck  = "lesser";
				
				else if( transCheck == "<=" )
					typeCheck  = "lesser-equal";
				
				else
					typeCheck 	= "equal";
				
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.noteValue != "object" )
							config.noteValue 	= [ config.noteValue ];
						
						config.noteValue.forEach( (noteValue)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								if( transCheck == "equal" )							
									return block.noteValue == noteValue;
								
								if( transCheck == "greater" )
									return block.noteValue > noteValue;
								
								if( transCheck == "greater-equal" )
									return block.noteValue >= noteValue;
								
								if( transCheck == "lesser" )
									return block.noteValue < noteValue;
								
								if( transCheck == "lesser-equal" )
									return block.noteValue <= noteValue;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('noteValue', config.noteValue, "transactions", typeCheck ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );				
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks = await this.getData(["noteValue", "type"], [config.noteValue, typeCheck ], this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				
				delete this.noteValue;
				searched.push("noteValue");				
				
			}
			if( config.signRef || this.signRef ){
				
				if( ! config.signRef )
					config.signRef 		= this.signRef;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.signRef != "object" )
							config.signRef 	= [ config.signRef ];
						
						config.signRef.forEach( (signRef)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.signRef == signRef;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('signRef', config.signRef ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("signRef", config.signRef, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.signRef;
				searched.push("signRef");
			}
			if( config.referenceID || this.referenceID ){
				
				if( ! config.referenceID )
					config.referenceID 		= this.referenceID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.referenceID != "object" )
							config.referenceID 	= [ config.referenceID ];
						
						config.referenceID.forEach( (referenceID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.referenceID == referenceID;	
							});
						});					
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('referenceID', config.referenceID ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("referenceID", config.referenceID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.referenceID;
				searched.push("referenceID");
			}
			
			if( config.referenceKey || this.referenceKey ){
				
				if( ! config.referenceKey )
					config.referenceKey 		= this.referenceKey;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.referenceKey != "object" )
							config.referenceKey 	= [ config.referenceKey ];
						
						config.referenceKey.forEach( (referenceKey)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.referenceKey == referenceKey;	
							});
						});					
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('referenceKey', config.referenceKey ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks = await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("referenceKey", config.referenceKey, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.referenceKey;
				searched.push("referenceKey");
			}
			
			if( config.splitID || this.splitID ){
				
				if( ! config.splitID )
					config.splitID 		= this.splitID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.splitID != "object" )
							config.splitID 	= [ config.splitID ];
						
						config.splitID.forEach( (splitID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.splitID == splitID;	
							});
						});					
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('splitID', config.splitID ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks = await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("splitID", config.splitID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.splitID;
				searched.push("splitID");
			}
			if( config.budgetID || this.budgetID ){
				
				if( ! config.budgetID )
					config.budgetID 	= this.budgetID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.budgetID != "object" )
							config.budgetID 	= [ config.budgetID ];
						
						//console.log( "check this block ", this.blocks );
						
						config.budgetID.forEach( (budgetID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.budgetID == budgetID;				
							});
						});
						
						//console.log( "check this block after ", this.blocks );
						
					}
				} else {
					//let note = JSON.parse( sessionStorage.currentNote );
					//let block = await Scriptbill.getTransBlock(10, {budgetID:note.budgetID});
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('budgetID', config.budgetID ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks = await blocks;
					blockIDs 	= [];
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("budgetID", config.budgetID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}			
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.budgetID;
				searched.push("budgetID");
				
			}
			if( config.productID || this.productID ){
				
				if( ! config.productID )
					config.productID 	= this.productID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.productID != "object" )
							config.productID 	= [ config.productID ];
						
						config.productID.forEach( (productID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.productID == productID;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('productID', config.productID ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("productID", config.productID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}			
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.productID;
				searched.push("productID");
			}
			if( config.transTime || this.transTime ){
				
				if( ! config.transTime )
					config.transTime 	= this.transTime;
				
				let trans = config.transTime.toString().split(" ");
				config.transTime = parseFloat( trans[0] );
				let transCheck  = trans[1];
				let typeCheck;
				
				if( transCheck == ">" )
					typeCheck  = "greater";
				
				else if( transCheck == "=" )
					typeCheck  = "equal";
				
				else if( transCheck == ">=" )
					typeCheck  = "greater-equal";
				
				else if( transCheck == "<" )
					typeCheck  = "lesser";
				
				else if( transCheck == "<=" )
					typeCheck  = "lesser-equal";
				
				else
					typeCheck 	= "equal";
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.transTime != "object" )
							config.transTime 	= [ config.transTime ];
						
						config.transTime.forEach( (transTime)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								if( transCheck == "equal" )							
									return block.transTime == transTime;
								
								if( transCheck == "greater" )
									return block.transTime > transTime;
								
								if( transCheck == "greater-equal" )
									return block.transTime >= transTime;
								
								if( transCheck == "lesser" )
									return block.transTime < transTime;
								
								if( transCheck == "lesser-equal" )
									return block.transTime <= transTime;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('transTime', config.transTime, "transactions", typeCheck ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit && blocks )
						this.blocks = this.blocks.concat( blocks );
					
					if( this.blocks.length < limit ){ 
					
						blocks = await this.getData(["transTime", "type"], [config.transTime, typeCheck ], this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}							
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.transTime;
				searched.push("transTime");
				
			}
			if( config.agreeID || this.agreeID ){
				
				if( ! config.agreeID )
					config.agreeID 		= this.agreeID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.agreeID != "object" )
							config.agreeID 	= [ config.agreeID ];
						
						config.agreeID.forEach( (agreeID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.agreeID == agreeID;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('agreeID', config.agreeID, "agreements" ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if( this.blocks.length < limit && blocks ) {
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					if( this.blocks.length < limit ){ 
					
						blocks 	= await this.getData("agreeID", config.agreeID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								if( ! blockIDs.includes( block.blockID )){
									blockIDs.push( block.blockID );
									this.blocks.push( block );
								}
							});
						}
					}
								
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.agreeID;
				searched.push("agreeID");
			}
			//this will only return a single block or id
			if( config.productBlockID || this.productBlockID ){
				
				if( ! config.productBlockID )
					config.productBlockID = this.productBlockID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.productBlockID != "object" )
							config.productBlockID 	= [ config.productBlockID ];
						
						config.productBlockID.forEach( (productBlockID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.productBlockID == productBlockID;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('productBlockID', config.productBlockID ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;					
					blockIDs 	= [];
								
					if( blocks.length ){
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}			
					else { 
					
						blocks 	= await this.getData("productBlockID", config.productBlockID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.blockID ){
							this.blocks.push( blocks );
							blockIDs.push( blocks.blockID );
						}				
						else if( blocks.length && typeof blocks == "object") {
							this.blocks.concat( blocks );
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					
					}
					
					
					blockIDs = this.l[ config.productBlockID ];							
					

					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
				
				delete this.productBlockID;
				searched.push("productBlockID");
			}
			if( config.exBlockID || this.exBlockID ){
				
				if( ! config.exBlockID )
					config.exBlockID 	= this.exBlockID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.exBlockID != "object" )
							config.exBlockID 	= [ config.exBlockID ];
						
						config.exBlockID.forEach( (exBlockID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.exBlockID == exBlockID;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('exBlockID', config.exBlockID ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					blockIDs 	= [];
					
					if(  blocks && blocks.length && typeof blocks == "object" ){
						this.blocks = this.blocks.concat( blocks );
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					else { 
					
						blocks 	= await this.getData("exBlockID", config.exBlockID, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.blockID ){
							this.blocks.push( blocks );
							blockIDs.push( blocks.blockID );
						}				
						else if( blocks.length && typeof blocks == "object" ) {
							this.blocks.concat( blocks );
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					
					}
					
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				}
							
				delete this.exBlockID;
				searched.push("exBlockID");				
			}
			if( config.walletHASH || this.walletHASH ){
				
				if( ! config.walletHASH	)
					config.walletHASH 		= this.walletHASH;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.walletHASH != "object" )
							config.walletHASH 	= [ config.walletHASH ];
						
						config.walletHASH.forEach( (walletHASH)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.walletHASH == walletHASH;
								
								
							});
						});
						
					}
				} else {
					blocks 		= new Promise( (resolve, reject)=>{
						this.getDataPersistently('walletHASH', config.walletHASH ).then( blocks =>{
							setTimeout(()=>{
								resolve(blocks);
							},1000);
						});
					});
					blocks 		= await blocks;
					//reset the blockIDs array here
					blockIDs 	= [];
					
					if( blocks && blocks.length && typeof blocks == "object" ){
						this.blocks = this.blocks.concat( blocks );
						
						if( blocks && blocks.length && typeof blocks == "object" ){
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					else { 
					
						blocks 	= await this.getData("walletHASH", config.walletHASH, this.server ? this.server : "", "socket");
						
						if( blocks && blocks.blockID ){
							this.blocks.push( blocks );
							blockIDs.push( block.blockID );
						}
						
						else if( blocks.length && typeof blocks == "object" ){
							this.blocks.concat( blocks );
							blocks.forEach( block =>{
								blockIDs.push( block.blockID );
							});
						}
					}
					
					
					if( this.blockIDs.length > 0 ){
						this.blockIDs = this.blockIDs.filter( blockID =>{
							return blockIDs.includes( blockID );
						});
					}
				
				}
							
				delete this.walletHASH;
				searched.push("walletHASH");			
				
			}
			
			if( this.blocks.length == 0 && searched.length < 1 ){
				//console.log( "test blocks", this.blocks );
				if( this.#note && ! this.blockID )
					this.blockID = this.#note.blockID;
			}
			
			if( config.blockID || this.blockID ){
				
				if( ! config.blockID )
					config.blockID 		= this.blockID;
				
				if( searched.length ){
					if( this.blocks.length ){
						if( typeof config.blockID != "object" )
							config.blockID 	= [ config.blockID ];
						
						config.blockID.forEach( (blockID)=>{
							this.blocks = this.blocks.filter( (block)=>{
								if( typeof block == "string" && this.isJsonable( block ) )
									block 		= JSON.parse( block );
								
								if( typeof block == "string" && ! this.isJsonable( block ) )
									return false;
								
								return block.blockID == blockID;
								
								
							});
						});
						
					}
				} else {
					//console.log( typeof config.blockID, "transblock getting" );
					
					if( typeof config.blockID == "string" )
						blocks 		= await this.resolvePersistentData( config.blockID );
					
					else {
						if( config.blockID.length ){
							if( typeof blocks != "object" || ! blocks.length )
								blocks = [];
							
							for( let r = 0; r < config.blockID.length; r++ ){
								blocks.push( await this.resolvePersistentData( config.blockID[r]) );
							}
						}
					}
					// //console.log("blocks: " + blocks);
					// await this.createAlert("blocking");
					if( this.blocks.length < limit && blocks )
						this.blocks = this.blocks.concat( blocks );
					
					if( this.blocks.length < limit ){ 
						if( typeof config.blockID == "string" )
							blocks 	= await this.getData("blockID", config.blockID, this.server ? this.server : "", "socket");
						
						else {
							if( config.blockID.length ){
								if( typeof blocks != "object" || ! blocks.length )
									blocks = [];
								
								for( let r = 0; r < config.blockID.length; r++ ){
									blocks.push( await this.getData("blockID", config.blockID[r], this.server ? this.server : "", "socket") );
								}
							}
						}
						
						if( this.blocks.length < limit && blocks )
							this.blocks = this.blocks.concat( blocks );
					
					}
					
					//blockIDs = this.l[ this.blockID ];
										
								
					if( blocks && this.blocks.length < limit )
						this.blocks.push( blocks );
					
					if( this.blockIDs.length < limit )
						this.blockIDs.push( this.blockID );
				
				}
				
				delete this.blockID;
				
			}

			/* this.blocks = this.blocks.filter( block =>{
				return this.blockIDs.includes( block.blockID );
			}); */
			
			/* if( ( this.blocks.length == 1 && this.blocks[0].blockID == "" && this.#note && this.l[ this.#note.noteAddress + "_current_block"] && this.isJsonable( this.l[ this.#note.noteAddress + "_current_block"] ) ) || ! this.blocks.length ){
				this.blocks.splice(0,1);
				this.blocks.push( JSON.parse( this.l[ this.#note.noteAddress + "_current_block"] ) );
			} */
					
			//always returns an array of values or blocks.
			return this.blocks;	
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return [ this.defaultBlock ];
		}		
	}

		
	static async getTransactions( callback ){
		//console.log("getTransactions running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "getTransactions";
		if( this.key == undefined )
			this.key = 0;
		
		this.data = await this.l;
		let keys = Object.keys( this.data );
		let key 	= keys[ this.key ];
		let block = false;
		let x;
		
		if( key == undefined ) return;
		
		//console.log( 'blcokkey: ' + key );
		//10000 * 10000 means an 100 million maximum loop
		for( x = 0; x < 10000; x++ ) {

			if( await this.stop )
				break;
			
			
			this.key++;
			key = keys[ this.key ];
			
			if( key == undefined ) break;
			
			if( key != 'personal' || key != 'account' || key != 'ScriptNotes' || key != null ) {
				let data 	= this.data[ key ];
				
				if( data && typeof data == 'string' && data.indexOf('{') == 0 && data.lastIndexOf('}') == ( data.length - 1 ) )
					block = JSON.parse( data );
				
				//handling the agreements on the note.
				this.response = block;
				/* this.handleAgreement();
				this.monitorScriptbillCredit(); */
				
				if( block && typeof block == 'object' )
					callback( block, this.key, this );
			}
			
		}
		
		this.key++;
		
		if( key != null || ! await this.stop )
			this.getTransactions(callback);
	}
	
	//this function is expected to run with a user Inputed password.
	static async changeLoginPassword( newPassword, oldPassword ){
		//console.log("changeLoginPassword running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "changeLoginPassword";
		this.#password = await this.#getPassword( oldPassword );
		
		//initializing storage.
		
		try {
			if( !this.#note && this.s.currentNote )
				this.#note = await this.#getCurrentNote();
			
			if( this.noteAddress ){
				this.#note = await this.#getNote();
			}
			
			if( ! this.#note ){
				this.errorMessage("Cannot Change The Login Password When The Current Note is Note Initialized!");
				return false;
			}
			
			this.#password = await this.#generatePassword( newPassword );
			await this.saveNote( this.#note );
					
			if( this.#note && this.#note.noteAddress && this.#note.noteBudgets && this.#note.noteBudgets.length )
				return true;
			
			return false;
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}	
	
	//creating a product is just simply creating a transaction block optimized for product creation. For now we are not creating budgets
	static async create_product(){
		//console.log("create_product running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "create_product";
		//console.log( "product Config: " + JSON.stringify( this.productConfig ) );
		
		//initializing storage.
		
		try {
			//run Scriptbill function only if the product config has been truely configured.
			if( ! this.productConfig.value || ! this.productConfig.units || ! this.productConfig.name || ! this.productConfig.description ) {
				return null;
			}
			
					
			if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
				this.#note = await this.#getCurrentNote();
			
			
			if( ! this.productConfig.totalUnits || this.productConfig.totalUnits < this.productConfig.units )
				this.productConfig.totalUnits = this.productConfig.units;

			if( ! this.#note || ! this.#note.budgetID ){
				
				if( ! this.#note )
					this.errorMessage("Can't Create a Product Without a Running Note!!!");
				
				else
					this.errorMessage("Can't Create a Product Without a Running Scriptbill Business Budget. Please Create One And Try Again!!!");
				
				return null;
			}
			
			//set the business budget ID as private key.
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.budgetID, id );
			let budgetID 		= await this.getPublicKey(id);
			let budgetBlock 	= await this.getCurrentBudgetBlock( budgetID );
			
			if( ! budgetBlock || ! budgetBlock.blockID || ! budgetBlock.budgetID || ! budgetBlock.agreement || ! budgetBlock.agreement.stockID ) {
				this.errorMessage("Can't Create a Product Without a Running Scriptbill Business Budget. Please Create One And Try Again!!!");	
				return null;
			}
			
			this.productConfig.stockID 		= budgetBlock.agreement.stockID;
			this.productConfig.budgetID		= budgetID;
					
			if( this.productConfig.productID ){
				this.productID 		= this.productConfig.productID;
				let transBlock 		= await this.getTransBlock(100, {productID: this.productID});
				
				if( transBlock[0].blockID ){
					this.noRequest	= true;
					transBlock  	=  await this.getCurrentBlock( transBlock );
					this.details 	= JSON.parse( JSON.stringify( transBlock ));
				}
				else {
					this.details  = JSON.parse( JSON.stringify( this.defaultBlock ) );
				}
				this.details.transType 		= 'UPDATEPRODUCT';
			}
			else {
				this.details  = JSON.parse( JSON.stringify( this.defaultBlock ) );
				this.details.transType 		= 'CREATEPRODUCT';
			}
			
			let agreement 			= await this.createAgreement();
			/* var string 			= this.productConfig.storeID;
			this.productConfig.storeID = this.hashed( string ); */
			agreement.productConfig = JSON.parse( JSON.stringify( this.productConfig ));
			agreement.agreeType			= "PRODUCT";
			delete agreement.privateKey;
			
			this.details.transValue 	= this.productConfig.value;
			this.details.agreement 		= agreement;			
			this.details.budgetID 		= budgetID;
			//the business manager key is the public key to the Business Manager'this.s note, where he will be recieving proceeds from the Profit SHaring on Scriptbill 
			//product
			if( this.#note.BMKey ){
				this.details.businessKey = this.#note.BMKey;
			}
			this.walletID 				= this.#note.walletID;
			
			return await this.generateScriptbillTransactionBlock( this.details, this.#note );
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static async buy_product( productID, value = 0 ){
		//console.log("buy_product running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "buy_product";
		//first look for the product on the Scriptbill database.
		this.productID = productID;
		let block = await this.getTransBlock();
		
		try {
		
			if( ! block[0].blockID ) {
				this.errorMessage("No Product Found Associated With This Product ID: " + productID + ". Please Check The Product ID and Try Again!");
				return false;
			}		
			
			block = block[0];
			//console.log("the block: " + block, "stringified: " + JSON.stringify( block ) );
			this.productBlock = JSON.parse( JSON.stringify( block ));
			//console.log( "block found " + block, "stringified " + JSON.stringify( block ) );
			let prodValue = 0;
			
					
			if( block.agreement && block.agreement.productConfig )
				prodValue = block.agreement.productConfig.value;
			
			else if( block.agreement && block.agreement.value )
				prodValue 	= block.agreement.value;
			
			else if( block.transValue )
				prodValue 	= block.transValue;
			
			/* if( block.noteServer ){
				let currentNote = await this.getData(["noteAddress", "#getNote"], [this.#note.noteAddress, block.productID], block.noteServer );
				
				if( currentNote && typeof currentNote == "string" ){
					await this.setPrivateKey( this.#note.noteSecret );
					let data 			= await this.#decrypt( currentNote );
					this.#currentNote 	= this.isJsonable( data ) ? JSON.parse( data ) : false;
				}
			} */
			
			
			await this.#getCurrentNote();		
			
			
			this.details = JSON.parse( JSON.stringify( block ) );
			this.details.recipient = this.details.productID;
			//check if the current note has the value of the product.
			if( this.#note.noteValue >= prodValue && ! value ){
				
				this.details.transType = 'BUYPRODUCT';
				this.details.transValue = prodValue;
				//block.agreement.productURL = location.href;
				this.details.agreement 	= JSON.parse( JSON.stringify( block.agreement ) );
				return await this.generateScriptbillTransactionBlock();
			}
			else {
							
				if( ! value && this.alertDetails ) {
					let con = await this.createConfirm( "Your Note Value is: " + this.#note.noteValue + " and you are about to purchase a product of value: " + prodValue + " You'll Need " + ( prodValue - this.#note.noteValue ) + " To Complete this Transaction Without a Credit. You Can Choose to Buy A Credit To Complete This Transaction or Continue With a Scriptbank Credit and Pay a Compound Interest of " + ( this.interestRate * 100 ) + "% Daily. Click Okay To Continue the transaction as a credit and Cancel to Subscribe to this Product..." );
					
					if( ! con ){
						this.details.transValue = this.#note.noteValue;
						this.details.transType = 'PRODUCTSUB';
						this.details.subConfig = JSON.parse( JSON.stringify( this.subConfig));
						this.details.subConfig.value = this.details.transValue;
						this.details.subConfig.productID = this.details.productID;
					}
					else {
						this.details.transType = "BUYPRODUCT";
						this.details.transValue = prodValue;					
					}
				}
				else {
					this.details.transValue = value;
					this.details.transType = 'PRODUCTSUB';
					this.details.subConfig = JSON.parse( JSON.stringify( this.subConfig ) );
					this.details.subConfig.value = this.details.transValue;
					this.details.subConfig.productID = this.details.productID;
				}
				
				//this.details.agreement 		= await this.createAgreement();
				
				
				return await this.generateScriptbillTransactionBlock( this.details, this.#note );
				
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}		
		
	}
	
	static async #profitSharing( shareBlock, note, BLOCK, response = null ){
		//console.log("profitSharing running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "profitSharing";
		//the block must be configured as an object for the function to work and not an array.
		if( typeof BLOCK != 'object' || BLOCK.length ) return;
		
		//initializing storage.
		this.s 			= await this.s;
		this.l 			= await this.l;
		
		if( ! response && this.response )
			response = JSON.parse( JSON.stringify( this.response ));
		
		try {
			
			shareBlock.blockID 			= shareBlock.nextBlockID;
			shareBlock.formerBlockID 	= shareBlock.blockID;
			shareBlock.nextBlockID 		= await this.calculateNextBlockID(note);
			
			shareBlock.transType 		= 'PROFITSHARING';
			shareBlock.transValue 		= this.#shareValue;
			//this.#shareValue 			= false;
			block 						= await this.getTransBlock(1, {productBlockID: shareBlock.formerProductBlockID});
			block 						= block[0];//PERERE
			
			let agreeTime			=	parseInt( this.calculateTime( shareBlock.agreement.payPeriod ) );
			
			if( isNaN( agreeTime ) )
				agreeTime			=	parseInt( this.calculateTime( "2 weeks" ) );
				
			let curTime				= parseInt( this.currentTime() );
			
			if( ! block || block.blockID == '' || ! block.profitKey  || ( block.transTime + agreeTime ) < curTime ) {
				//this shows there is no more blocks to recieve the profit.
				//the last block takes the last profit shared.
				response.productNote.exchangeValue 	= parseFloat( response.productNote.exchangeValue ) + this.#shareValue;
				this.#noVerify		= false;
				this.storeBlock( response, note );
				return response;
			} 
			note.blockID 				= shareBlock.blockID;
	
			var string 				= JSON.stringify( note );
			let noteHASH				= this.hashed( string );
			shareBlock.noteHash			= noteHASH.slice( 0, noteHASH.length / 2 );
			note.noteHash				= noteHASH.slice( noteHASH.length / 2, noteHASH.length );
			var string 				= noteHASH;
			note.noteSign 				= await this.Sign(note.blockKey, this.hashed( string ));
			this.returnNote 			= JSON.parse( JSON.stringify( this.#note ));
			note.blockID 				= shareBlock.blockID;				
			//this.response 		= JSON.parse( JSON.stringify( block ));
			//await this.generateScriptbillTransactionBlock(details, note);
			var id 						= await this.generateKey(10);
			await this.setPublicKey( block.profitKey, id);
			let privKeyd 					= await this.generateKey(10, true );
			shareBlock.agreement.privateKey 	= privKeyd;
			shareBlock.recipient 				=	this.#encrypt( shareBlock.agreement, id );
			await this.setPrivateKey( shareBlock.agreement.privateKey, id );
			delete shareBlock.agreement.privateKey;
			shareBlock.blockRef 				= await this.getPublicKey(id, true);
			shareBlock.signRef 					= await this.generateKey(20);
			shareBlock.nextRecipient			= block.formerProductBlockID;
			
			BLOCK.nextBlockID			= shareBlock.nextBlockID;
			BLOCK.blockID				= shareBlock.blockID;
			BLOCK.formerBlockID			= shareBlock.formerBlockID;
			BLOCK.blockRef				= shareBlock.blockRef;
			BLOCK.signRef				= shareBlock.signRef;
			BLOCK.transValue			= shareBlock.transValue;
			BLOCK.transType				= shareBlock.transType;
			
			var string 				= JSON.stringify( BLOCK );
			let transHASH				= this.hashed( string );
			shareBlock.transHash   		= transHASH.slice( 0, transHASH.length / 2 );
			
			note.transHash 				= transHASH.slice( transHASH.length / 2, transHASH.length );
			
			
			var string 				= transHASH;
			shareBlock.blockHash		= this.hashed( string );
			
			
			shareBlock.blockSign			= await this.Sign(note.blockKey, shareBlock.blockHash);
			
			this.shareData( false, shareBlock );				
			this.storeBlock( shareBlock, note );
			this.saveNote( note );
			return shareBlock;
		} catch(e) {
			this.errorMessage(e.toString());
			return false;
		}
	}

	/*
		Logining in a user to the server will be done with the user'this.s walletID as the username, the user'this.s password and the note address.
		If the user note address is not found, the user may be logeddin to the Scriptbill Application but will not be able to use any funds associated with that account 
		on the app. 
	*/
	static async loginUserDetails(){
		//console.log("loginUserDetails running " + this.funcUp[ this.funcUp.length]);
		this.funcUp[ this.funcUp.length] = "loginUserDetails";
		
		try {		
			if( ! this.#password && ! this.password ) {
				this.#password 	= await this.#getPassword();
				
				if( ! this.#password )
					return null; 
			} 
			
			if( this.password ){
				this.#password 		= await this.#getPassword( this.password );
			}
			
			if( ! CryptoJS || ! CryptoJS.MD5  ) {
				this.errorMessage('CryptoJS Hashing Libraries Are Needed To Log You In Securely. Please Include and Rerun Scriptbill Class Again!!!');
				return null;
			}
			
			////console.log( "personal: " + this.l.personal, "string: " + var string, "hash: " + this.hashed( string ) );
			if( this.l.personal ){
				let local = JSON.parse( this.isJsonable( this.l.personal ) ? this.l.personal : '{}' );
				let blockID, note, noteBlock, noteHash;
				
				if( local ){
					
					let localHash 	= local.hash;
					delete local.hash;
					var string 	= JSON.stringify( local ) + this.#password;				
					let hash 		= this.hashed( string );

					if( hash != localHash ) {
						//if we don't trust the local data we use the database information.
						if( this.s.currentNote ){
							note = JSON.parse( this.s.currentNote );						 
							noteBlock = JSON.parse( this.l.data );
							noteHash =  noteBlock.walletHASH;
								
							//the current block of a particular wallet carries the current walletHASH and it'this.s signature.
							//if the hash gotten is not equal to the hash saved, then there is a tamper error on the wallet
							//Scriptbill may have to block the wallet from taken anymore transaction.
							//Scriptbill shows that there is no tamper error on the walletHASH, the fault came from the client who had entered a wrong password
							if( noteHash == localHash ){
								this.errorMessage('Password Entered Was Incorrect and Won\'t Be Able To Decrypt Important Note Information!!!');
								return;
							}
							else{
								this.errorMessage('Invalid Scriptbill Note or Password!!!');
								return;
							}
									
						}
						else {
							this.errorMessage(' Incorrect Password Entered!!! ');
						}
					}
					else {
						//the user has proven that he is the rightful owner of the current wallet.
						//if the note aaddress is supplied, we attempt getting the note from his local server.
						
						if( this.noteAddress ){						
							this.#note = await this.#getNote();
							
							if( this.#note && typeof this.#note == 'object' && this.#note.noteAddress == this.noteAddress ) {
								await this.successMessage('Scriptbill Note Successfully Found. Scriptbill Now Initializing!!!');
								this.setCurrentNote().then( currentNote =>{
									//this.shareData();
									return currentNote;
								});
								
							}
							return null;
						}
						else {
							this.defaultScriptbill.walletID = this.walletID;
							return await this.createNewScriptbillWallet();
							
						}
					}

					/* let url = new URL( this.#default_scriptbill_server );
					url.searchParams.set('walletHASH', hash);
					url.searchParams.set('transTime', local.transTime);
					try {
						fetch( url).then( response =>{
							return response.text();
						}).then( async result =>{
							
							if( this.isJsonable( result ) ) { 
								this.response = JSON.parse( result );
								this.recieveData();
								return this.response;
							}
						});
					} catch(e){
						this.errorMessage("Cannot fetch " + e);
					}			 */	
								
				}
				
				else {
					local = {};
					local.walletID = this.walletID;
					local.transTime = this.currentTime();
					local.password 	= this.#password;
					var string = JSON.stringify( local );
					local.hash	= this.hashed( string );
					this.l.personal = JSON.stringify( local );
					return false;
				}
			}
			else {
				return false;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	//invest on a budget or company.
	//when creating a budget, it will be added as a product in the database
	//this will avoid it being expired after a long time as long as the stocks are being 
	//traded, the transaction block or the budget will remain active in the database.
	static async invest( budgetID, value ){
		//console.log("invest running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "invest";
		try {
			this.noteTypeS 			= this.#note.noteType;
			this.transType 			= "CREATEBUDGET";
			//this will get the most recent transaction block that carries the budget.
			
			let productBlock 		= await this.getTransBlock();
			productBlock 			= await this.getCurrentBlock( productBlock );
				
			
			if( productBlock && typeof productBlock == 'object' && productBlock.blockID ) {
				let agreement = productBlock.agreement;
				
				if( typeof agreement == 'string' && this.isJsonable( agreement ) )
					agreement = JSON.parse( agreement );
				
				if( agreement ){
					//the budget must have Scriptbill variable to be true, value, items, investors pouch
					let budget = typeof agreement == 'string' ? JSON.parse( agreement ) : agreement;
					
					if( budget.value && budget.budgetItems && budget.investorsHub ){
						//looop through the items to be sure that it is a valid item.
						let items = typeof budget.budgetItems == 'string' ? JSON.parse( budget.budgetItems ) : budget.budgetItems;
						let itemDetails, values = 0;
						for( itemID in items ){
							itemDetails = typeof items[ itemID ] == 'string' ? JSON.parse( items[ itemID ] ) : items[ itemID ];
							
							if( itemDetails.itemValue && itemDetails.itemName && itemDetails.scriptbillAddress && itemDetails.description ) {
								values += itemDetails.itemValue;
							}
						}
						
						//the budget value may be escalated by investors, or the proprietor of the 
						//bsuiness, so may be larger than the item values;
						if( values <= budget.value && value <= budget.value ){
							this.details = JSON.parse( JSON.stringify( this.defaultBlock ) );
							this.details.transValue = value;
							
							if( this.details.transType == "CREATE" )
								this.details.transType = 'INVEST';
							
							this.details.recipient = this.stockNoteAddress ? this.stockNoteAddress: budgetID;
							this.details.agreement =	JSON.parse( JSON.stringify( agreement ));
							return await this.generateScriptbillTransactionBlock();
						}
					}
				}
			} else {
				this.errorMessage("Invalid Investment Key Supplied");
				return false;
			}
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}
	}
	
	static budgetConfig = {
		"name"					: "Scriptbank Budget", //unique name for the budget, can be a business or website name.
		"value"					: 0, //the total value of a Scriptbill Budget. Always Used to Increase stock value manually
		"max_exec"				: "1 Months", //maximum time the budget would execute.
		"budgetID"				: "",//the public Key of the Budget,the private ke would be set on the note with the block ID where the budget is kept.
		"sleepingPartner" 		: "percent-low", //this is the description for a sleeping investor.
		"workingPartner"		: "perent-high", //this is the description for a working investor.
		"sleepingPartnerShare"	: 0.1, //this is the rate that describes the sleepig investor share.
		"workingPartnerShare"	: 0.1, //this is the rate that describes the sleepig investor share.
		"budgetItems"			: [],//items that are in the budget that constitute the budget
		"budgetSign"			: "", //the signature on the budget
		"budgetRef"				: "",//reference to the budget signature.
		"budgetType"			: "personal", // "personal" & "family" tells that this budget 
		//is not business related budget and won't accept investment. Any investment to this budget type will not 
		//issue any stocks. "governmental" budget will issue bonds not stocks to the investor and used by 
		//business managers and any persons or organization who support the economy, business budget will issue stocks to investor.
		"orientation"			: "straight",//telling whether this budget is a "straight" or "recursive" 
		//budget. If straight the budget block expires when the budget executes. but if recursive, the budget 
		//block will renew until the time for the recursion stops.
		"recursion"				: Infinity,//used to describe how many times the budget will execute if the budget is a recursive budget
		"budgetSpread"			: "1 weeks", //time required for the budget to spread after it has executed. Works for a recursive budgetType
		"budgetCredit"			: "SBCRD", //the acceptable credit for investing and executing this budget. Budget credit should be set according to how the item in the budget is valued.
		"budgetDesc"			: "", //the description of the budget. This will give investors view of what product or products that will be produced under this budget, and everything investors need to know about this budget.
		"budgetImages"			: [],//array of image url that can describe the budget products and effects.
		"budgetVideos"			: [], //array of videos that describe the budgets to investors.
		"companyRanks"			: [],//rank codes that will be occupied by users in the company. If you are employed in the company, a special rank code will be assigned you and the public key stored on the budget block
		"stockID"				: "SBSTK",//default scriptbill stocks code.
		"investorsHub"			: [],//an array of hashes that can only be verified by people who hold stocks to this budget. This hash also test for the values on their stock note.
		//if an investor sell his stock, the exchange market must test to see if the stock is 
		//true by testing the hashes, deduct the sold value from his account, issue out money 
		//to the seller and updating the hub hashes if only the investor hash stocks with the company who owns this budget. InvestorHub works majorly for business and 
		//governmental budget types. Personal and Family budget types will not trade their 
		//stocks because it does not have a real business value.
		'agreement'				: JSON.parse( JSON.stringify( this.defaultAgree ) ),//describes the extra agreenebt the budget creator would like to have with 
		//their investor. This should only be configured using the this.defaultAgree option.
		
	};
	
	static defaultItem  = {
		"itemID"	: "",//a unique ID that would be generated when the item is being created in the Scriptbill database system.
		"itemName"	: "Scriptbill Adverts",//the name of the item, note really neccessary but used to ID the item on the budget
		"itemValue"	: 50000,
		"itemProduct"	: "ADVERT", //the product ID that would be affected when this item is executed. This is compulsory for business budget types.
		"scriptbillAddress"	: "SCRIPTBILLADVERTS", //this is the scriptbill note address of the item. If this is empty, the create budget function will automatically create a Scriptbill note and send to the recipient
		"businessName"	: "",//the business name or storeID of the business that wants to sell this item. storeID is not a Scriptbill language but a Scriptbank System of storing businesses in the network. Scriptbill recognizes business using their noteAddress or budget ID.
		"itemCredit"	: "NGNCRD",//the credit if the product that would be purchase by the 
		//note. Most of the time, the credit is in fiat, especially at the early stages of 
		//scriptbill.
		"businessPhone"	: "",//phone number of the merchant.
		"businessEmail"	: "info@scriptads.ml",//email address of the merchant
		"businessAddress"	: "",//the street address of the merchant'this.s business
		"businessRegion"	: "",//the region where the business resides.
		"businessCountry"	: "Nigeria",//the country where the business resides.
		"execTime"			: "1 month", //time when this item would execute
		"time"				: this.currentTime(), //the time the item was created
	};
	
	//this function allows a user to employ a Scriptbill worker to his own company. This will allow the user buy 
	//stocks from the company with special priviledges.
	static async employScriptbillWorker( budgetID, workerNote ){
		//console.log("employScriptbillWorker running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "employScriptbillWorker";
		if( ! this.#note || ! this.#note.noteBugdets  || ! this.#note.noteBudgets.length || ! this.#note.noteBudgets.includes( budgetID ) ) return false;
		
		this.budgetID = budgetID;
		let budgetBlock = await this.getTransBlock();
		budgetBlock 	= budgetBlock[ budgetBlock.length - 1 ];
		
		if( ! budgetBlock && ! budgetBlock.agreement ){
			this.errorMessage("You can't employ a worker to the a Budget that Doesn't Exist. Please Check the Budget ID and Try Again. Budget ID worked with is: " + budgetID );
			return false;
		}
		
		let agreement 		= budgetBlock.agreement;
		let privKey 		= await this.generateKey(30, true);
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( privKey, id );
		var string 		= await this.getPublicKey(id);
		agreement.companyRanks.push(  this.hashed( string ) );
		budgetBlock.agreement = agreement;
		this.details	 	= budgetBlock;
		this.details.transType = "EMPLOY";
		this.details.transValue = 0;
		this.details.noteValue = this.#note.noteValue;
		this.details.recipient = workerNote;
		return await this.generateScriptbillTransactionBlock();	
	}
	
	static async createScriptbillBudgetItem( budgetID ){
		//console.log("createScriptbillBudgetItem running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "createScriptbillBudgetItem";
				
		if( !this.#note && this.s.currentNote )
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note ) return false;
		
		if( ! this.#note.noteBudgets || ! this.#note.noteBudgets.length ){
			this.errorMessage("Only notes that has budgets can update an Item on a budget");
		}
		
		this.#budgetSecret 			= false;
		
		for( let x = 0; x < this.#note.noteBudgets.length; x++ ){
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.noteBudgets[x], id );
			
			if( budgetID == await this.getPublicKey(id) )
				this.#budgetSecret 		= this.#note.noteBudgets[x];
			
			else if( budgetID == await this.getPublicKey(id, true ) )
				this.#budgetSecret 		= this.#note.noteBudgets[x];
		}
		
		if( ( ! this.defaultItem.itemName && ! this.defaultItem.itemValue ) || ! this.#budgetSecret ) {
			if( this.#budgetSecret )
				this.errorMessage("Item note properly configured");
			
			else 
				this.errorMessage("You are not authorized to create Item on this budget");
			
			return false;
		}
		let budgetBlock 		= await this.getCurrentBudgetBlock( budgetID );
		
		if( ! budgetBlock || ! budgetBlock.agreement || ! budgetBlock.agreement.budgetType ) {
			this.errorMessage("No Budget Block was Found Associated with the supplied budgetID  " + budgetID );
			return false;
		}
		
		if( budgetBlock.agreement.budgetType == "business" ){
			if( ! this.defaultItem.itemProduct ){
				this.errorMessage("The Product ID or Product IDs that this Item would affect is not listed. This is a requirement for a Business Budget Type");
				return false;
			} else {
				let productIDs 		= this.defaultItem.itemProduct.split(',');
				let forBudget 		= true, productID;
				
				for( let x = 0; x < productIDs.length; x++ ){
					this.#productBlock 	= await this.getCurrentProductBlock( productIDs[x] );
					
					if( ! this.#productBlock || ! this.#productBlock.productNote || this.#productBlock.productNote.budgetID != budgetID ){
						productID 	= productIDs[x];
						forBudget = false;
						break;
					}
				}
				
				if( ! forBudget ){
					this.errorMessage("We found at least one product ID Supplied not belonging to a budget ID Supplied. Product ID affected: " + (productID ? productID : "" ) + " Budget ID Supplied: " + budgetID );
					return false;
				}
			}
		}
		
		//next we check if there are means of communicating with the seller of the Product
		let contact = false;
		if( ! this.defaultItem.scriptbillAddress ){
			//if there is no Scriptbill address in item record, then we check if there IS
			//a phone number or email to send the funds to.
			if( ! this.defaultItem.businessPhone || ! this.defaultItem.businessEmail ) return false;
			
			contact 	= this.defaultItem.businessPhone || this.defaultItem.businessEmail;
			let note 	= JSON.parse( JSON.stringify( this.#note ) );
			if( this.defaultItem.itemCredit && this.defaultItem.itemCredit.includes('CRD') )
				this.defaultScriptbill.noteType = this.defaultItem.itemCredit;
			
			else if( this.defaultItem.itemCredit && ! this.defaultItem.itemCredit.includes('CRD') )
				this.defaultScriptbill.noteType = this.defaultItem.itemCredit + 'CRD';
			
			else
				this.defaultScriptbill.noteType = this.#note.noteType;
			
			this.defaultScriptbill.walletID     = await this.generateKey(30);
				
			this.#note   = false;
			this.#saveNote = false;
			return this.createNewScriptbillWallet().then( async block =>{
				if( block && block.transType == "CREATE" ){
					if( ! this.defaultItem.data ){
						this.defaultItem.data = {};
					}
					let transKey 				= await this.generateKey(10);
					var string 				= contact + transKey;
					this.defaultItem.data.note = this.encrypt( JSON.stringify( this.#note ), this.hashed( string ));
					this.defaultItem.scriptbillAddress = this.#note.noteAddress;
					this.#note 					= JSON.parse( JSON.stringify( note ));
					this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );		
					this.details.recipient 		= this.defaultItem.scriptbillAddress;
					this.details.transType      = "ADDITEM";
					this.details.budgetID 		= budgetID;
					this.details.transValue 	= this.defaultItem.itemValue;
					this.details.agreement 		= JSON.parse( JSON.stringify( this.defaultItem ));
					let $block = await this.generateScriptbillTransactionBlock();
					
					if( $block && $block.blockID && $block.transType == "ADDITEM" ){
						block.transKey = transKey;
						this.successMessage("Item Successfully Added, Check the transKey handler on the Block and send it to the recipient. He will need it to receive fund from this budget Item since the recipient do not have a Scriptbill note" );
					}
					
					return $block;
				} else {
					this.errorMessage("Could not create recipient note.");
					return false;
				}
			});
		} else {
			this.details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );		
			this.details.recipient 		= this.defaultItem.scriptbillAddress;
			this.details.transType      = "ADDITEM";
			this.details.budgetID 		= budgetID;
			this.details.transValue 	= this.defaultItem.itemValue;
			this.details.agreement 		= JSON.parse( JSON.stringify( this.defaultItem ));
			return await this.generateScriptbillTransactionBlock(this.details, this.#note );
		}
		
		return false;
	}
	
	static async updateScriptbillBudgetItem( budgetID, itemID, config = {} ){
		this.funcUp[ this.funcUp.length] = "createScriptbillBudgetItem";
				
		if( !this.#note && this.s.currentNote )
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note.noteBudgets || ! this.#note.noteBudgets.length ){
			this.errorMessage("Only notes that has budgets can update an Item on a budget");
		}
		
		this.#budgetSecret 			= false;
		
		for( let x = 0; x < this.#note.noteBudgets.length; x++ ){
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.noteBudgets[x], id );
			
			if( budgetID == await this.getPublicKey(id) )
				this.#budgetSecret 		= this.#note.noteBudgets[x];
			
			else if( budgetID == await this.getPublicKey(id, true ) )
				this.#budgetSecret 		= this.#note.noteBudgets[x];
		}
		
		//getting the item's block
		this.blockID 	= itemID;
		let block 		= await this.getTransBlock(1);
		
		if( ! block || ! block[0] || ! block[0].blockID || ! block[0].agreement || block[0].agreement.budgetID != budgetID ){
			this.errorMessage("We couldn't find the budget item stored on the database");
			return false;
		}
		
		if( typeof config != "object" || ! Object.keys( config ).length || config.length ){
			this.errorMessage("update configuration poorly configured.");
			return false;
		}
		
		let budgetConfig 	=   JSON.parse( JSON.stringify( block[0].agreement ));
		
		if( ! budgetConfig.item || typeof budgetConfig.item != "object" ){
			this.errorMessage("Item ID Supplied, does not fall to a real Scriptbill budget Item. Please Check the ID and Try Again!");
			return false;
		}
		
		if( ! budgetConfig.budgetItems || ! budgetConfig.budgetItems.length || ! budgetConfig.budgetItems.includes( itemID )){
			this.errorMessage("Couldn't find item in the original budget configuration");
			return false;
		}
		
		for( let ID in config ){
			budgetConfig.item[ ID ] = config[ID];				
		}
		
		this.details 			= JSON.parse( JSON.stringify( block[0] ) );
		this.details.agreement 	= JSON.parse( JSON.stringify( budgetConfig.item ) );
		this.details.transType 	= "UPDATEITEM";
		this.details.transValue = this.details.agreement.item.itemValue;
		this.details.itemID 	= itemID;
		this.details.budgetID 	= budgetID;
		return await this.generateScriptbillTransactionBlock( this.details, this.#note );
	}
	18245
	static async removeScriptbillBudgetItem( budgetID, itemID ){
		this.funcUp[ this.funcUp.length] = "removeScriptbillBudgetItem";
				
		if( !this.#note && this.s.currentNote )
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note.noteBudgets || ! this.#note.noteBudgets.length ){
			this.errorMessage("Only notes that has budgets can remove an Item on a budget");
		}
		
		this.#budgetSecret 			= false;
		
		for( let x = 0; x < this.#note.noteBudgets.length; x++ ){
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.noteBudgets[x], id );
			
			if( budgetID == await this.getPublicKey(id) )
				this.#budgetSecret 		= this.#note.noteBudgets[x];
			
			else if( budgetID == await this.getPublicKey(id, true) )
				this.#budgetSecret 		= this.#note.noteBudgets[x];
		}
		
		//getting the item's block
		this.blockID 	= itemID;
		let block 		= await this.getTransBlock(1);
		
		if( ! block || ! block[0] || ! block[0].blockID || ! block[0].agreement || block[0].agreement.budgetID != budgetID ){
			this.errorMessage("We couldn't find the budget item stored on the database");
			return false;
		}
		
		let budgetConfig 	=   JSON.parse( JSON.stringify( block[0].agreement ));
		
		if( ! budgetConfig.item || typeof budgetConfig.item != "object" ){
			this.errorMessage("Item ID Supplied, does not fall to a real Scriptbill budget Item. Please Check the ID and Try Again!");
			return false;
		}
		
		if( ! budgetConfig.budgetItems || ! budgetConfig.budgetItems.length || ! budgetConfig.budgetItems.includes( itemID )){
			this.errorMessage("Couldn't find item in the original budget configuration");
			return false;
		}
		
		let index 		= budgetConfig.budgetItems.indexOf( itemID );
		budgetConfig.budgetItems.splice(index, 1 );
		delete budgetConfig.item;
		
		
		this.details 			= JSON.parse( JSON.stringify( block[0] ) );
		this.details.agreement 	= JSON.parse( JSON.stringify( budgetConfig ) );
		this.details.transType 	= "CANCELITEM";
		this.details.transValue = 0;
		this.details.itemID 	= itemID;
		this.details.budgetID 	= budgetID;
		return await this.generateScriptbillTransactionBlock( this.details, this.#note );
	}
	
	//before calling this function please set the budget Config variable to your desired value
	static async createScriptbillBudget( config = false, note = false ){
		//console.log("createScriptbillBudget running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "createScriptbillBudget";
		
		try {
			if( ! this.#note && this.s.currentNote )
				this.#note = await this.#getCurrentNote();
			
			if( ! note && this.#note )
				note 		= JSON.parse( JSON.stringify( this.#note ));
			
			//alert(" Create Budget Running");
			
			let testType 	= note.noteType.slice( 0, note.noteType.lastIndexOf("CRD"));
			
			//we need at least the name and value set before continuing
			if(  ! this.budgetConfig.name || ! config || ! config.name ){
				this.errorMessage("Budget Can't be Created Without name", "createScriptbillBudget");
				return false;
			}
			
			if( config && config.name )
				this.budgetConfig 		= JSON.parse( JSON.stringify( config ));
			
			let budgetConfig 			= JSON.parse( JSON.stringify( this.budgetConfig ));
			
			//this shows the budget creator has not set the appropraite stockID for his budget
			//the SBSTK is a Scriptbank stock id and it's the default stock id On
			//the budget config handler.
			if( ! budgetConfig.stockID || ( budgetConfig.stockID == "SBSTK" && budgetConfig.name != "Scriptbank Budget" ) ){
				if( budgetConfig.budgetType == 'business' )
					budgetConfig.stockID = budgetConfig.name.toUpperCase().replaceAll(' ', '').slice(0,7) + "STK";
				
				else if( budgetConfig.budgetType == 'governmental' )
					budgetConfig.stockID = budgetConfig.name.toUpperCase().replaceAll(' ', '').slice(0,5) + "CRD";
				
				else //personal budget don't have stock IDs
					budgetConfig.stockID = "";
			}
			
			
			
			//the budget items are things that must be purchased using this budget.
			//budget items can be added to the budget anytime by the budget creator.
			let budgetItems = budgetConfig.budgetItems;
			let x, item, found = false, value = 0;
			let time 	=  parseInt( this.currentTime() );
			let maxExecTime;
			let budgetID;
			
			//await this.createAlert(" Create Budget Running");
			
			/*//we loop through the budget items to calculate the value and check if an advert budget was included
			if( budgetItems.length > 0 ){
				for( x = 0; x < budgetItems.length; x++ ) {
					item = budgetItems[ x ];
					
					if( ! item ) continue;
					
					if( ! item.itemCredit )
						item.itemCredit 	= budgetConfig.budgetCredit;	
					
					value += item.itemValue;
					if( item.itemName == 'Scriptbill Adverts' ){
						found = true;
						if( item.itemCredit != budgetConfig.budgetCredit ){
							let exValues 		= await this.getExchangeValue( budgetConfig.budgetCredit, item.itemCredit );
							item.itemValue 		= item.itemValue * exValues[0];
							item.itemCredit 	= budgetConfig.budgetCredit;
						}
					}
					
					if( typeof item.execTime == 'string' ){
						maxExecTime = parseInt( this.calculateTime( item.execTime ));
						
						if( ! isNaN( maxExecTime ) )
							item.execTime = time + maxExecTime;
						
						else {
							maxExecTime 	= parseInt( this.calculateTime( "1 Months" ));
							item.execTime 	= time + maxExecTime;
						}
					}
				}
			} */
			//alert(" Create Budget Running 2");
					
			if( typeof budgetConfig.max_exec == 'string' ) {
				maxExecTime = parseInt( this.calculateTime( budgetConfig.max_exec ) );
				
				if( ! isNaN( maxExecTime ) ){
					budgetConfig.max_exec = time + maxExecTime;
				} else {
					maxExecTime =	parseInt( this.calculateTime( "1 Months" ) );
					budgetConfig.max_exec = time + maxExecTime;
				}
			}
			
			
			//alert(" Create Budget Running 3");
			
			//reconfiguring the value of the budget to equal the actual value of items in the budget.
			
			let isFound = false;
			
			if( typeof note.noteBudgets != "object" || ! note.noteBudgets.length )
				note.noteBudgets 		= [];
			
			//generate the budget id.
			if( budgetConfig.budgetID ) {			
				for( x = 0; x < note.noteBudgets.length; x++ ){
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( note.noteBudgets[x], id );
					budgetID 	= await this.getPublicKey(id);
					if( budgetConfig.budgetID == budgetID ){
						isFound				= true;
						budgetID 			= note.noteBudgets[x];
						//this.#budgetSecret 	= budgetID;
					}
					else {
						budgetID 	= await this.getPublicKey( id, true );
						if( budgetConfig.budgetID == budgetID ){
							isFound				= true;
							budgetID 			= note.noteBudgets[x];
						}
					}
				}
			}	
			//alert(" Create Budget Running 4 " + budgetConfig.budgetID );		
			
			let details 	= JSON.parse( JSON.stringify( this.defaultBlock ) );
			
			if( ! isFound ){
				if( budgetConfig.budgetType == 'governmental' ){
					if( ! this.#fiatCurrencies[testType] ){
						budgetID 						= await this.generateKey( 50, true );	
						this.#currentNote.walletID 		= await this.generateKey(24);
						note.noteBudgets.push( budgetID );					
					}
					else {
						let motherKeys 				= await this.#generateMotherKeys();
						budgetID 					= motherKeys.budgetIDS[ note.noteType ];
						var string 				= "SCRIPTBANKFIATEXCHANGEWALLET";
						this.#currentNote.walletID 	= this.hashed( string );
					}
					var id 				= await this.generateKey(10);
					await this.setPrivateKey( budgetID, id );
					budgetConfig.budgetID 	= await this.getPublicKey(id);
				} else if( budgetConfig.budgetType == 'business' ){
					budgetID 				= await this.generateKey( 50, true );
				} else {
					budgetID 				= await this.generateKey( 50, true, true );
					//note.noteBudgets.push( budgetID );
				}
				//this.#budgetSecret 		= budgetID;				
				details.transType 		= "CREATEBUDGET";
			} else {
				details.transType = "UPDATEBUDGET";
			}
			
			let productNote 		= await this.getCurrentExchangeNote( budgetConfig.stockID );
			//console.log("prodNote: ", productNote, "budCon: ", budgetConfig);
			if( productNote && productNote.exchangeID && productNote.budgetID ){
				if( ! note.budgetID ){					
					this.errorMessage("Budget already created by another user. ");
					return false;
				} else {
					var id 	= await this.generateKey(10);
					await this.setPrivateKey( note.budgetID, id );
					let testID 		= await this.getPublicKey(id);
					
					if( testID != productNote.budgetID ){
						this.errorMessage("Budget already created by another user.");
						return false;
					} else {
						details.transType = "UPDATEBUDGET";
					}
				}
			}
			
			if( typeof budgetConfig.budgetItems != 'object' || ! budgetConfig.budgetItems.length )
				budgetConfig.budgetItems = [];
			
			//console.log("note: " + JSON.stringify( note ) );
			
			details.agreement 		= JSON.parse( JSON.stringify( budgetConfig));
			details.recipient 		= budgetConfig.budgetID;
			details.expiry			= budgetConfig.max_exec;
			details.transValue 		= budgetConfig.value;
			this.#budgetSecret  	= budgetID;
			
			if( ! this.walletID )
				this.walletID 		= note.walletID;
		
			
			let $return = await this.generateScriptbillTransactionBlock(details, note);
			
			//this condition makes an agreement a budget
			if( $return && $return.agreement && $return.agreement.budgetID )
				budgetConfig 		= JSON.parse( JSON.stringify( $return.agreement ));
			
			
			/* if( budgetConfig.budgetType == "business" && $return.transType == "CREATEBUDGET" ){
				alert("Creating Item");
				if( this.defaultItem.itemCredit != budgetConfig.budgetCredit ){
					let exValues 		= await this.getExchangeValue( budgetConfig.budgetCredit, this.defaultItem.itemCredit );
					this.defaultItem.itemValue 		= this.defaultItem.itemValue * exValues[0];
					this.defaultItem.itemCredit 	= budgetConfig.budgetCredit;
				}
				await this.createScriptbillBudgetItem( $return.budgetID );
			} */
			
			return $return;
			
		} catch( e ){
			this.errorMessage( e.toString() );
			//console.log('na error be this', e);
			return false;
		}
	}
	
	//to run auto investment. we run it locally on the server first and the network gets to know based on the 
	//transactional data sent afterwards
	static async autoInvestScriptbillBudget(){
		//console.log("autoInvestScriptbillBudget running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "autoInvestScriptbillBudget";
		
		//if( ! this.#isExchangeMarketMining ) return;
		try {
			if( ! this.#note && this.s.currentNote ){
				this.#note = await this.#getCurrentNote();
			}
			
			if( ! this.#note || ! this.#note.budgetID ){
				return false;
			}		
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.budgetID, id );
			let budgetID 		= await this.getPublicKey(id);
			let budgetBlock 	= await this.getCurrentBlock( budgetID );
			
			if( ! budgetBlock || ! budgetBlock.agreement || ! budgetBlock.agreement.budgetType )
				return;
			
			let note 			= await this.getCurrentExchangeNote( budgetBlock.agreement.stockID );
			
			if( ! note ) return;

			this.#currentNote 	= await this.getCurrentExchangeNote( this.#note.noteType );
			
			if( ! this.#currentNote || ! typeof this.#currentNote == "object") return;
			
			let demandValue = this.#currentNote.demandValue ? parseFloat( this.#currentNote.demandValue ): 0.0;
			
			let exchangeValue = this.#currentNote.exchangeValue ? parseFloat( this.#currentNote.exchangeValue ): 0.0;
			
			let noteValue = this.#currentNote.noteValue ? parseFloat( this.#currentNote.noteValue ): 0.0;
			
			let totalMinable 	=  await this.calculateLoanEligibility();
			
					
			let budgetKey, budgetValue = 0;
			let x, item, blk;
			let time = this.currentTime(), week	= 604800, day 	= 86400, hour 	= 3600;
			let execTime, itemExec, execResult, value = 0;
			
			let budget 		= JSON.parse( JSON.stringify( budgetBlock.agreement ));
			//for auto investment to work, the budget must belong to a valid product
			//a governmental budget type will only attract investment from investors in the bond market
			//auto investment will not work with such budget.
			if( ! budget || budget.budgetType != "business" ) 
				return;			
			
			budgetValue = budget.value;
				
			//check the execution time for each item, we will invest on budget whose execution time is at 
			//least three weeks
			execTime = budget.max_exec;
				
			let budgetItems = budget.budgetItems;
			let len 		= budgetItems && budgetItems.length ? budgetItems.length : 0;
			for( x = 0; x < len; x++ ){
				this.blockID 	= budgetItems[x];
				blk 			= await this.getTransBlock(1);
				
				if( ! blk.length || ! blk[0].agreement || ! blk[0].agreement.item )
					continue;
				
				item 			= JSON.parse( JSON.stringify( blk[0].agreement.item ));
				
				execResult 		= parseInt( item.execTime ) - parseInt( time );
				
				//any item lesser than 4 weeks in the execution time 
				if( Math.round( execResult / week ) < 4 ) continue;
					
				value += item.itemValue;
			}
				
			if( value && ( value <= totalMinable || value <= exchangeValue ) ) {
									
				//checking the note value
				//we can only auto invest if the value on the note is lesser than the budget value.
				if( value > note.exchangeValue ){
					value -= parseFloat( note.exchangeValue );
					
					if( Math.round( value / 100 ) > note.exchangeValue ){
						this.errorMessage("Note Value too Small to Validate The Auto Investment. Will Revert To A Smaller Investment If any Value is Found on The Note.");
						
						let exValue 		= await this.getExchangeValue("USDCRD", note.noteType );
						exValue 			= parseFloat( note.exchangeValue ) * exValue[0];
						
						//this shows there must be some little investment of up to $10
						//on the note before auto investment can work.
						if( note.exchangeValue <= 0 && exValue <= 10 ){
							this.errorMessage("No Value Found on Business Note. Scriptbill Auto Investment Function Cannot Validate Your Budget.");
							return false;
						}
						
						//value 		= parseFloat( note.noteValue ) * 100;
					} 
					//to invest we check if the BM Key is there to create the transaction.	
					this.details   			= JSON.parse( JSON.stringify( this.defaultBlock ) );
					this.details.transType 	= "INVEST";
					this.details.transValue = value;
					this.details.noteType   = budget.budgetCredit;
					this.details.recipient  = budget.budgetID;
					this.details.agreement  = budget;
					
					this.#isExchangeMarketMining 	= true;
					await this.generateScriptbillTransactionBlock();
					this.#isExchangeMarketMining 	= false;					
				}
			}
			
		} catch(e){
			this.errorMessage(e.toString());
			console.error(e);
			return false;
		}		
	}
	
	static async getBudgetBlocks(){
		//console.log("getBudgetBlocks running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "getBudgetBlocks";
		
		//initializing storage
		this.s 		= await this.s;
		this.l 		= await this.l;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note || ! this.#note.budgetID ) return false;
		
		this.budgetID = this.#note.budgetID;
		let budgetBlocks = await this.getTransBlock();
		
		if( ! budgetBlocks.length ) {
			this.errorMessage("No Budget Block(s) is Found. Create a Budget and Try again ");
			return false;
		}
		
		return budgetBlocks;
	}
	
	static async monitorScriptbillStock(){
		//console.log("monitorScriptbillStock running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "monitorScriptbillStock";
		if( ( ! this.response || ! this.response.blockID ) && ( ! this.#note || ! this.#note.noteType.includes("STK") && ! this.response.productID ) ) return false;
		
		let response = JSON.parse( JSON.stringify( this.response ) );
		
		//get the budget ID of the current stock to know if the current product block belongs to the current budget.
		this.budgetID 	= this.#note.budgetID;
		let budgetBlock	= await this.getTransBlock();
		
		//this may show that the current budget have been updated by the note that created this
		//budget, so we check the update budget transaction.
		if( ! budgetBlock.length ){
			this.budgetID 	= this.#note.budgetID;			
			this.transType 	= "UPDATEBUDGET";
			budgetBlock		= await this.getTransBlock();
			
			//this shows that the budget is not existence in the netowrk so we abort the
			//transaction.
			if( ! budgetBlock.length ) {
				this.errorMessage( "This Stock note with budget ID: " + this.#note.budgetID + " appears to be invalid! Budget Associated with the stock was not found. Please contact the company you bought this stock from for assistance."); 
				return false;
			}
			else {
				this.noRequest 	= true;
				budgetBlock 	= budgetBlock[ budgetBlock.length - 1 ];
			}
		}
		
		let products 	= budgetBlock.budgetProducts;
		let budget		= budgetBlock.agreement;
		let x, productID, pay, productBlock, prodAgree, soldValue, purchaseValue, y, item, profitRate, profit, stockProfit;
		
		if( products.indexOf( response.productID ) ) {
			productID 	= response.productID;
			//the pay value of the stock describe the amount from the profit that would be paid to the stock note per transaction.
			pay			= this.#note.pay;
			//to get the right amount of money to be paid, the profit from this transaction must be calculated.
			//to get the right profit, we have to get the product block to understand the value
			this.productID 		= productID;
			producBlock			= await this.getTransBlock();
			productBlock		= productBlock[productBlock.length - 1 ];
			prodAgree			= productBlock.agreement;
			soldValue 			= prodAgree.units * prodAgree.value;
			//to get the profit rate we need to get the purchase value of the product. we'll have to loop through the budget items
			//to find the purchase value.
			purchaseValue = 0;
			for( y = 0; y < budget.budgetItems.length; y++ ){
				item = budget.budgetItems[y];
				if( item.itemProduct == productID ){
					purchaseValue 	+= item.itemValue;
				}
			}
				
			//we can now calculate the profit we get from the profit rate gotten through the purchase value.
			profitRate		= (soldValue - purchaseValue)/soldValue;
			profit			= response.transValue * profitRate;
			stockProfit 	= profit * pay;
			
			//letting the budget block discoverable.
			this.budgetBlock 		= budgetBlock;
			
			//generate a transaction that will pay up the mother note of this stock.
			this.details 			= JSON.parse( JSON.stringify( this.defaultBlock ) );
			this.details.recipient = this.#note.motherKey;
			this.details.transType = "STOCKPAY";
			//the block verifiers will need the stock note to reference the budget in his transactional request to confirm the 
			//transaction. to do this, we need to provide both the budgetID and stock hashes.
			var string				= this.#note.stockKey + this.#note.pay + this.#note.noteValue;
			this.details.reference	= this.hashed( string );
			this.details.budgetID	= budget.budgetID;
			this.details.transValue = stockProfit;
			this.details.noteType 	= budget.budgetCredit;
			this.details.blockID	= response.blockID;
			return await this.generateScriptbillTransactionBlock();			
		}		
	}
	
	//the stock ID, if the stock will be bought directly from the note.
	//the value of stock you want to buy
	//the noteAddress if the stock will be bought from a stock note holder. the note address should be the 
	//note address of the recipient stock. the recipient mother key will be used to recieve the funding.
	static async buyScriptbillStocks( stockID, value ){
		//console.log("buyScriptbillStocks running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "buyScriptbillStocks";
		if( this.#note.noteType.includes("STK") || this.#note.noteType.includes("BND") ){
			this.errorMessage("You Can't Use A Stock or Bond Note To Purchase a Scriptbill Stock! Please Try Again With a Valid Credit Note.");
			return false;
		}
		
		if( this.#note.noteValue < value ){
			this.errorMessage("You don't have sufficient Scriptbill Credit to Complete this Transaction!");
			return false;
		}
		
		let stockBlock 	= await this.getCurrentBudgetBlock( stockID );
		
		if( ! stockBlock ) {
			this.errorMessage("Sorry, No Transaction Block Was Found Associated With Ths Stock Note!");
			return false;
		}
		
		let budget 	= stockBlock.agreement;
		this.budgetID 	= stockID;
		this.transType 	= "SELLSTOCK";
		let stockBlocks = await this.getTransBlock(100, {transType:"SELLSTOCK", budgetID: stockID});
		
		if( ! budget.budgetType || budget.budgetType != "business" ){
			this.errorMessage("The Stock ID " + stockID + " Was Not Found Associated With Any Valid Scriptbill Stock. Please Check and Try Again or Contact Your Company");
			return false;
		}
		
		//trying to get the stock seller'this.s address;
		let x;
		this.stockNoteAddress 	= false;
		for( let z = 0; z < stockBlocks.length ; z++ ){
			
			stockBlock		= stockBlocks[z];
			
			if( stockBlock.transType == "SELLSTOCK" ){
				this.blockRef = stockBlock.blockRef;
				let blocks = await this.getTransBlock(5, {blockRef: stockBlock.blockRef});
				let soldstock = false;
				
				if( blocks && blocks.length && typeof blocks == "object" ){
					for( x = 0; x < blocks.length; x++ ){
						if( blocks[x].transType == "SOLDSTOCK" )
							soldstock = true;
					}
				}
				
				if( ! soldstock ){
					this.stockNoteAddress = stockBlock.blockKey;
					break;
				}
			}
		
		}
		
		this.defaultBlock.transType = "BUYSTOCK";		
		return await this.invest( stockID, value );
	}
	
	//function to sell your current scriptbill stock at a particular stock rate.
	//stock rate is not equal to the rate of stock you want sold, but to the rate of
	//stock you have tjat you want sold. If your stock rate is 1, this means you want the 
	//whole of your stock sold.
	static async sellScriptbillStocks( stockRate ){
		//console.log("sellScriptbillStocks running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "sellScriptbillStocks";
		
		//initializing storage.
		this.s		= await this.s;
		this.l 		= await this.l;
		
		if( stockRate > 1 ){
			this.errorMessage("Please Set Your Stock Rate equal to or Lesser Than 1!");
			return false;
		}
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note || this.#note.noteType.lastIndexOf( "STK" ) != ( this.#note.noteType.length - 3 ) ) {
			this.errorMessage("Only Scriptbill Stock Note Can Sell a Scriptbill Stock");
			return false;
		}
		
		if( stockRate > 1 ){
			this.errorMessage("Your Stock Rate can't be Greater than 1!! Converting to the appropraite rate...");
			stockRate = stockRate / 100;
			
			if( stockRate > 1 ){
				this.errorMessage("Can't Successfully Convert Your Stock Rate. Please Try Again With Values Lesser Than or equal to 100 or 1");
				return false;
			}
		}		
				
		if( ! this.#note.budgetID ){
			this.errorMessage("Your Stock note doesn't Appear to Be Valid. No Budget ID Stored on this Note. Please Contact Your Company For Rectification!");
			return false;
		}
		
		this.budgetID 		= this.#note.budgetID;
		let budgetBlocks  	= await this.getTransBlock();
				
		if( ! budgetBlocks.length && ! budgetBlocks[0].agreement && ! budgetBlocks[0].agreement.value ){
			this.errorMessage("Your Stock note doesn't Appear to Be Valid. No Budget Block Was Found Associated With The Budget ID on this Note!");
			return false;
		}
		
		if( ! budgetBlocks[0].agreement.budgetType || budgetBlocks[0].agreement.budgetType != "straight" ||  budgetBlocks[0].agreement.budgetType != "recursive" || ! budgetBlocks[0].agreement.budgetProducts || ! budgetBlocks[0].agreement.budgetProducts.length || ! budgetBlocks[0].agreement.budgetProducts.length > 0 ){
			this.errorMessage("Your Stock note doesn't Appear to Be Valid. The Budget on Your Stock Note Does Not Appear to Belong To a Valid Company!");
			return false;
		}
		
		let x, budgetBlock = false, buyBlocks, y, sold = false;
		
		for( x = ( budgetBlocks.length - 1); x > ( budgetBlocks.length - 500 ) && x >= 0 ; x-- ){
			
			if( budgetBlocks[x].transType != "BUYSTOCK" ) continue;
			
			budgetBlock = budgetBlocks[x];
			this.blockRef = budgetBlock.blockRef;
			buyBlocks 		= await this.getTransBlock();
			
			if( buyBlocks && buyBlocks.length ) {
				for( y = ( buyBlocks.length - 1); y > ( buyBlocks.length - 500 ) && y >= 0 ; y-- ) {
					if( buyBlocks[x].transType == "SOLDSTOCK" ){
						sold = true;
						break;
					}
				}
			}
			if( ! sold  ){
				//check the transaction value to be equal to the stock value.
				let transValue = budgetBlock.agreement.value * stockRate;
				
				if( budgetBlock.transValue >= transValue  ){					
					break;
				}
				else {
					budgetBlock = false;
				}
					
			}
				
		}
		
		if( ! budgetBlock || ( budgetBlock && sold ) ){
			this.noRequest 		= true;
			budgetBlock 		= budgetBlocks.length ? budgetBlocks[ budgetBlocks.length - 1 ] : budgetBlocks;
			this.details 		= JSON.parse( JSON.stringify( budgetBlock ) );
			this.details.recipient = this.#note.budgetID;
			this.details.transValue = parseFloat( budgetBlocks[0].agreement.value ) * parseFloat( stockRate );
			this.details.transType	= "SELLSTOCK";
		}
		else if( budgetBlock && ! sold && budgetBlock.transType == "BUYSTOCK" ) {
			this.details 			= JSON.parse( JSON.stringify( budgetBlock ) );
			this.details.recipient = budgetBlock.blockKey;
			this.details.transValue = budgetBlock.agreement.value * stockRate;
			this.details.transType	= "SOLDSTOCK";
		}
		
		this.isBudget 			= true;		
		this.details.stock		= this.#note.noteValue;
		this.details.pay 		= stockRate;		
		return await this.generateScriptbillTransactionBlock();
	}
	
	static async buyScriptbillBonds( value ){
		//console.log("buyScriptbillBonds running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "buyScriptbillBonds";
		
		//initializing storage.
		this.s 			= await this.s;
		this.l			= await this.l;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
			
		if( ! this.#note ){
			this.errorMessage("Can't Purchase a Valid Scriptbill Note Data!!!");
			return false;
		}
		
		if( this.#note.noteValue < value ){
			this.errorMessage("You don't have sufficient Scriptbill Credit to Complete this Transaction!");
			return false;
		}
		//exchangeNote
		let block;
		if( this.response && this.response.blockID && this.response.noteType == this.#note.noteType )
			block = JSON.parse( JSON.stringify( this.response ));
		
		else
			block = await this.getTransBlock(10, {blockID: this.#note.blockID});
		
				
		if(!block || ! block.blockID || typeof block != "object" || ! block.length || ! block[0].blockID ){
			
			if( this.l[ this.#note.noteAddress + "_current_block" ] )
				block = JSON.parse( this.l[ this.#note.noteAddress + "_current_block" ] );
			
			else {
				this.errorMessage("Can't Buy Scriptbill Bonds without a Valid Scriptbill Block Data!!!");
				return false;
			}
		}
		else if( block.length ){
			block 	= block[0];
		}
		
		let exchangeNote 	= await this.getCurrentExchangeNote( this.#note.noteType );
		
		if( ! exchangeNote || ! exchangeNote.exchangeID ){
			if( block.exchangeNote && typeof block.exchangeNote == "object" && block.exchangeNote.exchangeID ){
				exchangeNote		= block.exchangeNote;
			} else {
				this.errorMessage("No Exchange Note in the request to Buy Bonds");
				return false;
			}
		}
		
		//when creating a governmental budget, only an exchange note can do that.
		this.#currentNote 	= JSON.parse( JSON.stringify( exchangeNote ) );
		this.#currentNote.noteAddress 	= exchangeNote.exchangeID;
		this.#currentNote.noteSecret 	= exchangeNote.exchangeKey;
		
		/* this.budgetID 	= this.#currentNote.budgetID;
		this.transType  = "CREATEBUDGET";
		let blocks 		= await this.getTransBlock();
		
		if(  ! blocks.length ){
			this.budgetID 	= this.#currentNote.budgetID;
			this.transType  = "UPDATEBUDGET";
			let blocks 		= await this.getTransBlock();
			
			if( ! blocks.length ){
				this.errorMessage("No Transaction Block Was Found Associated With The Current Bond With This ID: "+this.#currentNote.budgetID+"!");
				return false;				
			}
		}
		
		//confirming if it is a bond block.
		let budget 		= blocks[0].agreement;
		
		if( ! budget || budget.budgetType != "governmental" ){
			this.errorMessage( "The Current Bond With ID: " + this.#currentNote.budgetID + " Can't be Bought as a Bond. Please Try Purchasing as a Stock Instead" );
		} */
		
		//looking for a SELLBOND request in the network to fulfill rather.
		let x, y, sellBlocks, bought = false;
		block = false;
		this.transType		= "SELLBOND";
		this.noteTypeS 		= this.#note.noteType;
		let blocks 				= await this.getTransBlock();
		
		for( x = ( blocks.length - 1); x > ( blocks.length - 500 ) && x >= 0 ; x-- ){
			
			if( blocks[x].transType != "SELLBOND" ) continue;
			
			block = blocks[x];
			this.blockRef = block.blockRef;
			sellBlocks 		= await this.getTransBlock();
			
			if( sellBlocks && sellBlocks.length ) {
				for( y = ( sellBlocks.length - 1); y > ( sellBlocks.length - 500 ) && y >= 0 ; y-- ) {
					if( sellBlocks[x].transType == "SOLDBOND" ){
						bought = true;
						break;
					}
				}
			}
			if( ! bought  ){
				
				if( block.transValue >= value  ){
					this.response = JSON.parse( JSON.stringify( block ));
					this.stockNoteAddress = block.blockKey;
					break;
				}								
			}
			
		}
		
		if( ! this.stockNoteAddress )
			this.stockNoteAddress = this.#currentNote.noteAddress;
		
		this.details				= JSON.parse( JSON.stringify( this.defaultBlock ));
		this.details.recipient 		= this.stockNoteAddress;
		this.details.transValue 	= value;
		this.details.transType 		= "BUYBOND";
		

		return await this.generateScriptbillTransactionBlock();
		
		/* this.defaultBlock.transType = "BUYBOND";
		return await this.invest( this.#currentNote.budgetID, value ); */
	}
	
	static async sellScriptbillBonds( bondValue ){
		//console.log("sellScriptbillBonds running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "sellScriptbillBonds";
		
		//initializing storage.
		this.s			= await this.s;
		this.l			= await this.l;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note || await this.testNoteType( "BND", this.#note ) ) return false;
		
		if( this.#note.noteValue < bondValue ){
			this.errorMessage("Your Bond note Value is low Compare to What you Applied To Sell!");
			return false;
		}
		
		if( ! this.#note.budgetID ){
			this.errorMessage("Your Bond note doesn't Appear to Be Valid. No Exchange ID Stored on this Note. Please Contact Your Company For Rectification!");
			return false;
		}
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( this.#note.budgetID, id );
		this.budgetID 	= await this.getPublicKey(id);
		this.transType 	= "BUYBOND";
		let budgetBlocks  = await this.getTransBlock();
		
		if( ! budgetBlocks.length && ! budgetBlocks[0].agreement && ! budgetBlocks[0].agreement.value ){
			this.errorMessage("Your Bond note doesn't Appear to Be Valid. No Exchange Block Was Found Associated With The Exchange ID on this Note!");
			return false;
		}
		
		
		let x, budgetBlock = false, buyBlocks, y, sold = false;
		
		for( x = ( budgetBlocks.length - 1); x > ( budgetBlocks.length - 500 ) && x >= 0 ; x-- ){
			
			if( budgetBlocks[x].transType != "BUYBOND" ) continue;
			
			budgetBlock = budgetBlocks[x];
			this.blockRef = budgetBlock.blockRef;
			buyBlocks 		= await this.getTransBlock();
			
			if( buyBlocks && buyBlocks.length ) {
				for( y = ( buyBlocks.length - 1); y > ( buyBlocks.length - 500 ) && y >= 0 ; y-- ) {
					if( buyBlocks[x].transType == "SOLDBOND" ){
						sold = true;
						break;
					}
				}
			}
			if( ! sold  ){
				break;					
			} else {
				budgetBlock = false;
			}
				
		}
		
		if( ! budgetBlock  ){
			this.details = JSON.parse( JSON.stringify( budgetBlocks[0]));
			this.details.recipient = this.#note.budgetID;
			this.details.transValue = bondValue;
			this.details.transType	= "SELLBOND";
		}
		else if( budgetBlock && ! sold ) {
			this.details = JSON.parse( JSON.stringify( budgetBlock ));
			this.details.recipient = budgetBlock.blockKey;
			this.details.transValue = bondValue;
			this.details.transType	= "SOLDBOND";
		}
		
		this.isBudget 			= true;				
		return await this.generateScriptbillTransactionBlock(this.details);	
	}
	/*
	*/
	static async monitorScriptbillBudget(){
		//console.log("monitorScriptbillBudget running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "monitorScriptbillBudget";
		
		//initializing storage.
		this.s 		= await this.s;
		this.l		= await this.l;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&  ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note ) return;
		
		/* let config 			= {};
		
		config.noteTypeS    	= this.#note.noteType;
		config.transType    	= "CREATEBUDGET";
		let budgetBlocks  		= await this.getTransBlock(1, config);
		config.noteTypeS	  	= this.#note.noteType;
		config.transType 	  	= "UPDATEBUDGET";
		let budgetBlocks2 		= await this.getTransBlock(100, config );
		budgetBlocks 			= budgetBlocks.concat( budgetBlocks2 );
		budgetBlocks 			= [...new Set( budgetBlocks )];
		config.noteTypeS	  	= this.#note.noteType;
		config.transType 	  	= "UPDATEITEM";
		budgetBlocks2 			= await this.getTransBlock(100, config);
		budgetBlocks 			= budgetBlocks.concat( budgetBlocks2 );
		budgetBlocks 			= [...new Set( budgetBlocks )];
		config.noteTypeS	  	= this.#note.noteType;
		config.transType 	  	= "ADDITEM";
		budgetBlocks2 			= await this.getTransBlock(100, config);
		budgetBlocks 			= budgetBlocks.concat( budgetBlocks2 );
		budgetBlocks 			= [...new Set( budgetBlocks )];
		config.noteTypeS	  	= this.#note.noteType;
		config.transType 	  	= "CANCELITEM";
		budgetBlocks2 			= await this.getTransBlock(100, config);
		budgetBlocks 			= budgetBlocks.concat( budgetBlocks2 );
		budgetBlocks 			= [...new Set( budgetBlocks )];
		config.noteTypeS	  	= this.#note.noteType;
		config.transType 	  	= "BUSINESS";
		budgetBlocks2 			= await this.getTransBlock(1, config);
		budgetBlocks 			= budgetBlocks.concat( budgetBlocks2 );
		budgetBlocks 			= [...new Set( budgetBlocks )];//await this.compare( budgetBlocks2, budgetBlocks, "budgetID" ); */
		
		let x, budget, agreement, govBudget, budgetItems = {}, budgetValue = 0, govBlock, budgetBlock, budgetID;
		//the exec time can be manipulated using the budgetMin handler. The value should be in string.
		//indicating the time interval the budget should run
		let tenMins  = parseInt( this.calculateTime( this.budgetMin ? this.budgetMin : "10 minutes" ) );
		let execTime = this.s.budgetRunned ? ( parseInt( this.s.budgetRunned ) + tenMins) : 0;
		let currentTime = parseInt( this.currentTime() );
		
		if( currentTime < execTime ){		
		
			//the note holds the governmental budget as a priority over other budgets.
			if( ! this.#note.budgetID || ! this.#note.noteBudgets.length || ! typeof this.#note.noteBudgets == "object" )
				return false;
			
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.budgetID, id );
			
			let executeBudget	= async (budgetID)=>{
				var id 				= await this.generateKey(10);
				await this.setPrivateKey( budgetID, id );
				
				budgetID 		= await this.getPublicKey(id);
				budgetBlock 	= await this.getCurrentBudgetBlock( budgetID );
				
				if( ! budgetBlock && ! budgetBlock.blockID ) return false;
				
				let budget 			= wbudgetBlock.agreement;
				let currentTime 	= this.currentTime();
				
				if( budget.budgetItems ){
					let x, item, itemTime, blk;
					for( x = 0; x < budget.budgetItems.length; x++ ){
						var blockID 	=  budget.budgetItems[x];
						if( typeof blockID == "string" && ! this.isJsonable( blockID ) ){
							blk 			= await this.getTransBlock(1, {blockID: blockID });
							
							//not a valid item block.
							if( ! blk || ! blk[0].agreement || ! blk[0].agreement.item ) continue;
						} else {
							let agreement 		= JSON.parse( blockID );
							blockID 			= this.budgetBlock.blockID;
							
							if( ! agreement.itemName || ! agreement.itemID ) continue;
							
							blk 			= JSON.parse( JSON.stringify( this.budgetBlock ) );
							blk.agreement.item 	= JSON.parse( JSON.stringify( agreement ));
						}
						
						this.itemBlockID 		= blockID;
						
						item 		= JSON.parse( JSON.stringify( blk.agreement.item ));
						itemTime 	= parseInt( item.time ) + parseInt( this.calculateTime( item.execTime ) );
						if( ! isNaN( itemTime ) && currentTime >= itemTime ){
							//creating a send transaction to the item recipient.
							this.details = JSON.parse( JSON.stringify( this.defaultBlock ) );
							
							if( budget.budgetCredit != this.#note.noteType ){
								let exValues = await this.getExchangeValue( budget.budgetCredit, this.#note.noteType );
								this.details.transValue = parseFloat( item.itemValue )* exValues[0];
							}
							else 
								this.details.transValue = item.itemValue;
							
							if( budget.budgetType == "business" ){
								this.details.transType 	= "EXECUTEBUDGET";
								this.#isExchangeMarketMining	= true;
							}
							
							else if( item.productID )
								this.details.transType = "BUYPRODUCT";
							
							else
								this.details.transType = "SEND";
							
							this.details.recipient = item.scriptbillAddress;
							
							//if the recipient is empty, we create a new Scriptbill note, where the recipient would 
							//recieve his funds.
							if( ! this.details.recipient || ( this.details.recipient == "SCRIPTBILLADVERTS" && item.itemName != "Scriptbill Adverts" ) ) {
								//first we save the current note so that the note variable won't be replaced by the 
								//recipient note we want to create.
								let note 		= JSON.parse( JSON.stringify( this.#note ) );
								//the recipient would only recieve his transaction in the budget credit value.
								this.defaultScriptbill.noteType 	= budget.budgetCredit;
								//to get the budget credit currency type we get the blocks connected to the budget 
								//credit. If found we get the currency type, if not found, then we classify the 
								//budget credit type as fiat.
								this.noteTypeS 			= budget.budgetCredit;
								let block 				= await this.getTransBlock();
								block 					= block[0];
								
								if( block && block.blockID ){
									this.defaultScriptbill.creditType = block.creditType;
								}
								else {
									this.defaultScriptbill.creditType = "fiat";
								}
								//to avoid saving the note to the current instance.
								this.#saveNote = false;
								await this.createNewScriptbillWallet();
								//since no one is claiming the note, we save the note in the agreement handler.
								this.details.agreement 		= await this.createAgreement();
								this.details.agreement.claimNote = JSON.parse( JSON.stringify( this.#note ) );
								this.details.recipient 		= this.#note.noteAddress;
								
								//next is to securely store the key on the Scriptbank server
								let url 				= new URL( this.#default_scriptbill_server );
								this.data 				= {
									privateKey 			: this.#note.noteSecret,
									blockID 			: this.#note.blockID,
									sender				: note.noteAddress,
									transTime			: newBlock.transTime
								};								
								
								this.#note 		= JSON.parse( JSON.stringify( note ));
							} else this.data = null;
							
							block = await this.generateScriptbillTransactionBlock( this.details, this.#note );
							
							if( this.data && block && block.blockID ){
								this.data.sendBlockID = block.blockID;
								await this.secureSend( this.data );
							}
						}
					}
				}			
				this.s.budgetRunned = this.currentTime();
			}
			
			if( this.#note.budgetID ){
				setTimeout( ()=>{
					executeBudget(this.#note.budgetID);
				}, 5000 );
			}
			let budgetID;
			for( let x = 0, y = 1; x < this.#note.noteBudgets.length; x++, y++ ){
				budgetID 		= this.#note.noteBudgets[x];
				setTimeout( (budgetID)=>{
					executeBudget( budgetID );
				}, y * 5000, budgetID );
				 
			}
		}/*  else if( budgetBlocks && budgetBlocks.length && false ){
			for(  x = ( budgetBlocks.length - 1); x > ( budgetBlocks.length - 500 ) && x >= 0 ; x-- ){
				budget = budgetBlocks[x];
				agreement = budget.agreement;
				
				if( agreement && agreement.budgetType && agreement.budgetType == "governmental" ){
					govBudget 	= agreement;
					govBlock 	= budget;
				}
				else if( agreement && agreement.budgetItems && agreement.budgetType ){
					budgetItems[agreement.budgetID] = agreement;
					budgetValue += agreement.value;
					
					//next, checking the if the value of the current budget is equal to the items value.
					let item, itemID, value = 0;
					for( itemID in agreement.budgetItems ) {
						item = agreement.budgetItems[ itemID ];
						value += item.itemValue;
					}
					
					if( agreement.value && agreement.value != value ){
						agreement.value = value;
						this.details =  budget;
						this.details.transType = "UPDATEBUDGET";
						this.details.transValue = 0;
						this.details.agreement = agreement;
						this.details.recipient = agreement.budgetID;
						return await this.generateScriptbillTransactionBlock();
					}
				}
			}
		}
		
		if( govBudget && govBudget.value != budgetValue && false){
			govBudget.value = budgetValue;
			govBudget.budgetItems = budgetItems;
			this.details = govBlock;
			this.details.transType = "UPDATEBUDGET";
			this.details.agreement = govBudget;
			this.details.recipient = govBudget.budgetID;
			return await this.generateScriptbillTransactionBlock();
		} */
		
		
	}
	
	static async secureSend( data ){
		//console.log("secureSend running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "secureSend";
		
		//initializing storage.
		this.s 			= await this.s;
		this.l			= await this.l;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
		
		if( ! this.#note )
			return false;
		
		let url	= new URL( this.#default_scriptbill_server );
		url.searchParams.set("getKEY", "");
		url.searchParams.set( "noteAddress", this.#note.noteAddress );
		
		try {
		fetch( url ).then( response =>{
			return response.text();
		}).then( async result =>{
			var id 				= await this.generateKey(10);
			await this.setPrivateKey( this.#note.noteSecret, id );
			let privKey	= await this.#decrypt( result, id );
							
			if( privKey && privKey.length == 171 ){				
				await this.setPrivateKey( privKey, id );
				data 	= await this.#encrypt( typeof data == "object" ? JSON.stringify( data ) : data, id );
			}
			else if( privKey && privKey.length < 171 ){
				await this.setPrivateKey( privKey, id );
				data 	= this.encrypt( typeof data == "object" ? JSON.stringify( data ) : data, await this.getPublicKey(id, true));
			}
			
			url.search = "";
								
			fetch( url,  {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				mode: 'no-cors', // no-cors, *cors, same-origin
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				credentials: 'same-origin', // include, *same-origin, omit
				headers: {
					'Content-Type': 'application/json'
					// 'Content-Type': 'application/x-www-form-urlencoded',
				},
				redirect: 'follow', // manual, *follow, error
				referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
				body: JSON.stringify({"secureData": data}) // body data type must match "Content-Type" header
			} ).then( resp =>{ return resp.json(); } ).then( ret =>{ this.s.secureResponse = JSON.stringify( ret ); } );
		}); 
		} catch( e ){
			this.errorMessage("couldn't send secured data: " + e );
		}
		
	}
	/*
		Monitoring Scriptbill Credit means Monitoring any transactions that are linked with the current node
		or any note whose block we have access to.
		This function should be runned in a mood where all blocks are accessed.
	*/
	static async monitorScriptbillCredit(){
		//console.log("monitorScriptbillCredit running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "monitorScriptbillCredit";
		
		//initializing storage.
		this.s 		= await this.s;
		this.l		= await this.l;
		
		if( ( ! this.#note && this.s.currentNote ) || ( this.s.currentNote &&    ! this.s.currentNote.includes( this.#note.walletID ) && ! this.s.currentNote.includes( this.#note.noteAddress ) && ! this.#isExchangeMarketMining ) || ( ! this.#isExchangeMarketMining && ! this.#note && this.s.currentNote ))
			this.#note = await this.#getCurrentNote();
		
		//
		if( ! this.#note || this.#note.noteValue > 0 || ! this.response ) return false;
		
		if( this.#note.noteValue < 0 ) {
			this.response = await this.getTransBlock();
			this.response = this.response[0];
		}
		
		if( ! this.response && ! this.response.blockID || ! this.response.noteValue ) return false;
		
		//first we check the current note value of the block.
		let noteValue = this.response.noteValue;
		
		//calculating the note value entails checking the transaction type.
		let transType = this.response.transType;
		
		if( this.#transSend.includes( transType ) ){
			noteValue 	+= this.response.transValue; 
		}
		else if( this.#transRecieve.includes( transType ) ){
			noteValue  	-= this.response.transValue;
		}
		
		//non credit holders are not going to be monitored.
		if( noteValue >= 0 ) return false;
		
		//next we check the transaction type. if is related to recieving we take our interest rate.
		if( this.#transRecieve.includes( transType ) ){			
			this.details 			= JSON.parse( JSON.stringify( this.response ) );
			//the nonce parameter is used to caliberate the auto transactions in the scriptbill network.
			//the nonce is created using the block ID hashes. This means the value will be the same for
			//every node that create the nonce. Transactions with the latest transtime and the same nonce
			//will be honoured by the node using it.
			var string 			= this.details.blockID;
			this.details.nonce		= this.hashed( string );
			//the interest type are written on the transaction block of crediters
			if( this.response.interestType && this.response.interestType == 'PT' )
				this.details.transValue 	= parseFloat( this.response.transValue ) * this.response.interestRate;
			
			else {
				//check if the interest is due and ready to be paid.
				if( this.response.payTime <= this.currentTime() ){
					this.response.interestRate = this.calculateInterestRate( this.response.interestType, this.response.interestRate );
					let amount = Math.abs( this.response.noteValue ) * this.response.interestRate;
					
					if( amount > this.response.transValue ){
						this.details.transValue = this.response.transValue;
						this.details.toPay		= amount - this.response.transValue;
					}
				}
			}
			
			//creating the nonce. Required for an automatically executed transaction.
			//since the nonce will be the same thing. If the concerned note get'this.s this block, it won't recieve such request again from 
			//the network
			var string 			= this.block.blockID;
			this.details.nonce 		= this.hashed( string );
			this.details.transType 	= "INTERESTPAY";
			var string 			= "SCRIPTBANK";
			this.details.recipient	= this.hashed( string );
			return await this.generateScriptbillTransactionBlock();
		}
		
	}
	
	//this is a mining function that works with auto investment on Scriptbill Budget and 
	//the exchange market. The function monitors the demand supply to and from the exchange
	//market and monitor the consequences to decide whether to make a supply or create a demand
	//demand comes for the exchange market using stock market sale and supply when purchasing
	//stocks.
	static async monitorScriptbillExchanges(){
		//console.log("monitorScriptbillExchanges running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "monitorScriptbillExchanges";
		if( ! this.response || this.response.transType != "EXCHANGE" || ! this.#note.budgetID || this.#note.noteType != this.response.buyCredit || this.#note.noteType != this.response.sellCredit ) return;
		
		//if it is an exchange block we get the exchange market value.
		//getting the exchange market of the sell credit.
		let sellMarket, buyMarket;
		
		//the sell Market will be the response block.
		if( ! this.response.exchangeNote ) return;
		
		if( this.response.sellCredit == this.#note.noteType ) {
		
			sellMarket 	= JSON.parse( JSON.stringify( this.response.exchangeNote ) );
			sellMarket.noteAddress 		= this.response.exchangeNote.exchangeID;
			sellMarket.noteSecret 		= this.response.exchangeNote.exchangeKey;
		}
		else if( this.response.buyCredit == this.#note.noteType ){
			this.sellCredit 		= this.#note.noteType;
			this.transType			= "EXCHANGE";
			this.exchangeBlocks		= await this.getTransBlock();
			this.noRequest 			= true;
			let sellBlock 			= await this.getCurrentExchangeBlock();
			
			if( sellBlock && sellBlock.exchangeNote ){
				sellMarket 			= JSON.parse( JSON.stringify( sellBlock.exchangeNote ) );
				sellMarket.noteAddress 		= sellBlock.exchangeNote.exchangeID;
				sellMarket.noteSecret 		= sellBlock.exchangeNote.exchangeKey;
			}
		}
		
		//getting the exchange rate of the buycredit agains the sellcredit.
		//or how much sell credit can purchase buy credit
		let exRates 		= await this.getExchangeValue( this.response.sellCredit, this.response.buyCredit );
		
		//checking if the exchange rate favours the current budget value of the note'this.s budget.
		var id 				= await this.generateKey(10);
		await this.setPrivateKey( this.#note.budgetID, id );
		this.budgetID 		= await this.getPublicKey(id);
		let budgetBlock		= await this.getCurrentBudgetBlock( this.budgetID );
		
		if( ! budgetBlock && ! budgetBlock.blockID && ! budgetBlock.agreement ) return;
		
		let budget 		= JSON.parse( JSON.stringify( budgetBlock.agreement ) );
		let budgetItems = budget.budgetItems;
		let item, cred, lastCred = null, exValue, totalValue = 0, execs = [];
		
		for( x = 0; x < budgetItems.length; x++){
			item 		= budgetItems[0];
			cred 		= item.itemCredit;
			
			if( lastCred && lastCred != cred ){
				//getting the exchange value in respect to cred. Meaning how many cred
				//can purchase lastCred. The totalValue of the transaction, will be calculated
				//in cred value.
				var exValues =await this.getExchangeValue( lastCred, cred );
				exValue 	= exValues[1];
				totalValue 	+= item.itemValue;
				totalValue 	= totalValue * exValue;
				lastCred 	= cred;
			}
			else {
				totalValue 	+= item.itemValue;
				lastCred 	= cred;
			}
		}
		
		//checking if the budget has dropped or risen based on the total item value we've
		//just gotten by converting the total value to the note'this.s credit value.
		exValues 		= await this.getExchangeValue( this.#note.noteType, lastCred );
		let budgetRate 		= exValues[0];
		let budgetValue 	= totalValue * budgetRate;
		
		//the auto investment would not run in this, because based on the note value.
		//and the budget value, the investment is okay.
		if( budget.value < budgetValue ){
			//we sell Scriptbill stocks to get more credit to the exchange market.
			//to sell scriptbill stocks we get all stocks connected to the exchange account.
			//for exchange market stocks, the blockSign is the hash of the exchange market
			//note address.			
			var string 		= sellMarket.noteAddress;
			var string 		= this.hashed( string );
			this.blockSign		= this.hashed( string );
			this.transType 		= "QUOTESTOCK";
			this.budgetID 		= this.#note.budgetID;
			
			//all existing stock blocks for the current budget will be returned. 
			let stockBlocks 	= await this.getTransBlock(), stockBlock, found = false;
			
			for( x = ( stockBlocks.length - 1); x > ( stockBlocks.length - 500 ) && x >= 0 ; x-- ){
				
				stockBlock 		= stockBlocks[x];
				
				if( stockBlock && stockBlock.blockSign == this.blockSign ){
					found = true;
					break;
				}
			}
			
			//this means we have found a stock block connected to this particular budget.
			if( found ){
				//sell 50% of the budget stocks to raise credit for the exchange market.
				let note = this.#note;
				this.#note = JSON.parse( JSON.stringify( this.defaultScriptbill ));
				this.#note.noteType 	= stockBlock.noteType;
				//generating a new key for the stock note.
				this.#note.noteSecret	= await this.generateKey(50, true);
				var id 					= await this.generateKey(10);
				await this.setPrivateKey( this.#note.noteSecret, id );
				this.#note.noteAddress 	= await this.getPublicKey(id);
				this.#note.noteValue 	= stockBlock.noteValue;
				this.#note.blockID 		= stockBlock.blockID;
				this.#note.budgetID 	= stockBlock.budgetID;
				this.#note.motherKey 	= sellMarket.noteAddress;
				await this.sellScriptbillStocks( 0.5 );
				this.#note				= note;
				await this.saveNote( note );
			}
		}
		else if( budget.value > budgetValue ) {
			let buyValue 	= budget.value - budgetValue;
			let note 		= JSON.parse( JSON.stringify( this.#note ) );
			this.#note 		= JSON.parse( JSON.stringify( sellMarket ) );
			this.buyScriptbillStocks( budget.budgetID, buyValue );
			this.#note 		= note;
			await this.saveNote( note );
		}
		
	}
	
	//this function will only run when the this.block handler is there. 
	//we will only check the block that has productsub as a transaction type.
	static async handleSubscriptions(){
		//console.log("handleSubscriptions running " + this.funcUp[ this.funcUp.length] );
		this.funcUp[ this.funcUp.length] = "handleSubscriptions";
		if(  ( ! this.block || ! this.block.blockID || this.block.transType != "PRODUCTSUB" || ! this.block.agreement || ! this.block.agreement.subUnit ) || ! this.#note ){
			return false;
		}
		
		if( this.block ) {
			//the subconfiguration is stored in the agreement handler of the block.
			let spread 	= this.block.agreement.subConfig.subSpread;
			let nextSub	= this.block.agreement.subConfig.nextSub;
			let time 	= this.currentTime();
			
			if( nextSub <= time ){
				this.block.agreement.subConfig.nextSub = parseInt( time ) + parseInt( this.calculateTime( this.block.agreement.subConfig.subSpread ) );
				this.details 			= this.block;
				var string 			= this.block.blockID;
				this.details.nonce		= this.hashed( string );
				this.details.transValue = this.block.agreement.subConfig.value;
				this.details.recipient  = this.block.productID;
				this.details.transType 	= "PRODUCTSUB";
				
				//to make it easy for the recipient to recieve an auto generated transation we set the agreement into the block
				//ref handler. 
				this.details.blockRef   = this.encrypt( JSON.stringify( this.block.agreement ), this.block.agreement.agreeID );
				this.autoExecute		= true;
				
				//configure a fake note to make the function use it as a current note.
				//saving the current note.
				let note 				= JSON.parse( JSON.stringify( this.#note));
				await this.saveNote( note );
				this.#saveNote 			= false;
				this.#note 				= JSON.parse( JSON.stringify( this.defaultScriptbill ) );
				this.#note.noteAddress 	= this.block.blockKey;
				this.#note.noteID		= this.block.noteID;
				this.#note.noteValue 	= this.block.noteValue;
				this.#note.blockID 		= this.block.blockID;
				this.#note.noteSecret	= "AUTOEXECUTE";
				this.#note.transValue 	= this.block.transValue;
				this.#note.transTime 	= this.block.transTime;
				let block 				= await this.generateScriptbillTransactionBlock();
				this.#note 				= JSON.parse( JSON.stringify( note ));
				return block;
				
			}
		}
		
		//for the current note subscription.
		else if( this.#note && this.#note.noteSubs && this.#note.noteSubs.length ){
			let x, sub, blocks = [];
			for( x = 0; x < this.#note.noteSubs.length; x++ ){
				sub 	= this.#note.noteSubs[x];
				
				if( sub.nextSub <= time ){
					sub.nextSub = parseInt( time ) + parseInt( this.calculateTime( sub.subSpread ) );
					this.details	= this.block;
					this.details.transValue = sub.value;
					this.details.recipient = sub.productID;
					blocks.push( await this.generateScriptbillTransactionBlock() );
				}
			}
			
			return blocks;
		}
	}
}
